import { a as MDCFoundation, b as MDCComponent, s as MDCRipple, C as MDCRippleFoundation, c as createCommonjsModule, d as _interopRequireDefault, n as require$$0, e as require$$0$1, f as require$$1, g as require$$2, h as require$$3, i as require$$4, j as require$$5, l as _preact, m as unwrapExports, q as styleInject, r as h, x as v, y as _slicedToArray, B as p, w as commonjsGlobal } from './chunk-42fdbf08.js';
import { a as process, b as global$1 } from './index-d70776de.js';
import { a as _regeneratorRuntime } from './chunk-6229c86f.js';

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  ACTIVE: 'mdc-tab-indicator--active',
  FADE: 'mdc-tab-indicator--fade',
  NO_TRANSITION: 'mdc-tab-indicator--no-transition'
};
/** @enum {string} */

const strings = {
  CONTENT_SELECTOR: '.mdc-tab-indicator__content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
 * @abstract
 */

class MDCTabIndicatorFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }
  /** @return enum {string} */


  static get strings() {
    return strings;
  }
  /**
   * @see MDCTabIndicatorAdapter for typing information
   * @return {!MDCTabIndicatorAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabIndicatorAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        computeContentClientRect: () => {},
        setContentStyleProperty: () => {}
      }
    );
  }
  /** @param {!MDCTabIndicatorAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter));
  }
  /** @return {!ClientRect} */


  computeContentClientRect() {
    return this.adapter_.computeContentClientRect();
  }
  /**
   * Activates the indicator
   * @param {!ClientRect=} previousIndicatorClientRect
   * @abstract
   */


  activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

  /** @abstract */


  deactivate() {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCSlidingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  /** @param {!ClientRect=} previousIndicatorClientRect */
  activate(previousIndicatorClientRect) {
    // Early exit if no indicator is present to handle cases where an indicator
    // may be activated without a prior indicator state
    if (!previousIndicatorClientRect) {
      this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
      return;
    } // This animation uses the FLIP approach. You can read more about it at the link below:
    // https://aerotwist.com/blog/flip-your-animations/
    // Calculate the dimensions based on the dimensions of the previous indicator


    const currentClientRect = this.computeContentClientRect();
    const widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
    const xPosition = previousIndicatorClientRect.left - currentClientRect.left;
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.setContentStyleProperty('transform', `translateX(${xPosition}px) scaleX(${widthDelta})`); // Force repaint before updating classes and transform to ensure the transform properly takes effect

    this.computeContentClientRect();
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    this.adapter_.setContentStyleProperty('transform', '');
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCFadingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  activate() {
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
 * @final
 */

class MDCTabIndicator extends MDCComponent {
  /**
   * @param {!Element} root
   * @return {!MDCTabIndicator}
   */
  static attachTo(root) {
    return new MDCTabIndicator(root);
  }
  /**
   * @param {...?} args
   */


  constructor(...args) {
    super(...args);
    /** @type {?Element} */

    this.content_;
  }

  initialize() {
    this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
  }
  /**
   * @return {!ClientRect}
   */


  computeContentClientRect() {
    return this.foundation_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabIndicatorFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabIndicatorAdapter} */
    Object.assign({
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      computeContentClientRect: () => this.content_.getBoundingClientRect(),
      setContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value)
    });

    if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
      return new MDCFadingTabIndicatorFoundation(adapter);
    } // Default to the sliding indicator


    return new MDCSlidingTabIndicatorFoundation(adapter);
  }
  /**
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.foundation_.activate(previousIndicatorClientRect);
  }

  deactivate() {
    this.foundation_.deactivate();
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$1 = {
  ACTIVE: 'mdc-tab--active'
};
/** @enum {string} */

const strings$1 = {
  ARIA_SELECTED: 'aria-selected',
  RIPPLE_SELECTOR: '.mdc-tab__ripple',
  CONTENT_SELECTOR: '.mdc-tab__content',
  TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
  TABINDEX: 'tabIndex',
  INTERACTED_EVENT: 'MDCTab:interacted'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabAdapter>}
 * @final
 */

class MDCTabFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$1;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$1;
  }
  /**
   * @see MDCTabAdapter for typing information
   * @return {!MDCTabAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        hasClass: () => {},
        setAttr: () => {},
        activateIndicator: () => {},
        deactivateIndicator: () => {},
        notifyInteracted: () => {},
        getOffsetLeft: () => {},
        getOffsetWidth: () => {},
        getContentOffsetLeft: () => {},
        getContentOffsetWidth: () => {},
        focus: () => {}
      }
    );
  }
  /** @param {!MDCTabAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabFoundation.defaultAdapter, adapter));
    /** @private {function(?Event): undefined} */

    this.handleClick_ = () => this.handleClick();
  }
  /**
   * Handles the "click" event
   */


  handleClick() {
    // It's up to the parent component to keep track of the active Tab and
    // ensure we don't activate a Tab that's already active.
    this.adapter_.notifyInteracted();
  }
  /**
   * Returns the Tab's active state
   * @return {boolean}
   */


  isActive() {
    return this.adapter_.hasClass(cssClasses$1.ACTIVE);
  }
  /**
   * Activates the Tab
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.adapter_.addClass(cssClasses$1.ACTIVE);
    this.adapter_.setAttr(strings$1.ARIA_SELECTED, 'true');
    this.adapter_.setAttr(strings$1.TABINDEX, '0');
    this.adapter_.activateIndicator(previousIndicatorClientRect);
    this.adapter_.focus();
  }
  /**
   * Deactivates the Tab
   */


  deactivate() {
    // Early exit
    if (!this.isActive()) {
      return;
    }

    this.adapter_.removeClass(cssClasses$1.ACTIVE);
    this.adapter_.setAttr(strings$1.ARIA_SELECTED, 'false');
    this.adapter_.setAttr(strings$1.TABINDEX, '-1');
    this.adapter_.deactivateIndicator();
  }
  /**
   * Returns the dimensions of the Tab
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    const rootWidth = this.adapter_.getOffsetWidth();
    const rootLeft = this.adapter_.getOffsetLeft();
    const contentWidth = this.adapter_.getContentOffsetWidth();
    const contentLeft = this.adapter_.getContentOffsetLeft();
    return {
      rootLeft,
      rootRight: rootLeft + rootWidth,
      contentLeft: rootLeft + contentLeft,
      contentRight: rootLeft + contentLeft + contentWidth
    };
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabFoundation>}
 * @final
 */

class MDCTab extends MDCComponent {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {?MDCRipple} */

    this.ripple_;
    /** @private {?MDCTabIndicator} */

    this.tabIndicator_;
    /** @private {?Element} */

    this.content_;
    /** @private {?Function} */

    this.handleClick_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTab}
   */


  static attachTo(root) {
    return new MDCTab(root);
  }

  initialize(rippleFactory = (el, foundation) => new MDCRipple(el, foundation), tabIndicatorFactory = el => new MDCTabIndicator(el)) {
    const rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
    const rippleAdapter = Object.assign(MDCRipple.createAdapter(
    /** @type {!RippleCapableSurface} */
    this), {
      addClass: className => rippleSurface.classList.add(className),
      removeClass: className => rippleSurface.classList.remove(className),
      updateCssVariable: (varName, value) => rippleSurface.style.setProperty(varName, value)
    });
    const rippleFoundation = new MDCRippleFoundation(rippleAdapter);
    this.ripple_ = rippleFactory(this.root_, rippleFoundation);
    const tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
    this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
    this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
    this.listen('click', this.handleClick_);
  }

  destroy() {
    this.unlisten('click',
    /** @type {!Function} */
    this.handleClick_);
    this.ripple_.destroy();
    super.destroy();
  }
  /**
   * @return {!MDCTabFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabFoundation(
    /** @type {!MDCTabAdapter} */
    {
      setAttr: (attr, value) => this.root_.setAttribute(attr, value),
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      hasClass: className => this.root_.classList.contains(className),
      activateIndicator: previousIndicatorClientRect => this.tabIndicator_.activate(previousIndicatorClientRect),
      deactivateIndicator: () => this.tabIndicator_.deactivate(),
      notifyInteracted: () => this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, {
        tab: this
      }, true
      /* bubble */
      ),
      getOffsetLeft: () => this.root_.offsetLeft,
      getOffsetWidth: () => this.root_.offsetWidth,
      getContentOffsetLeft: () => this.content_.offsetLeft,
      getContentOffsetWidth: () => this.content_.offsetWidth,
      focus: () => this.root_.focus()
    });
  }
  /**
   * Getter for the active state of the tab
   * @return {boolean}
   */


  get active() {
    return this.foundation_.isActive();
  }
  /**
   * Activates the tab
   * @param {!ClientRect=} computeIndicatorClientRect
   */


  activate(computeIndicatorClientRect) {
    this.foundation_.activate(computeIndicatorClientRect);
  }
  /**
   * Deactivates the tab
   */


  deactivate() {
    this.foundation_.deactivate();
  }
  /**
   * Returns the indicator's client rect
   * @return {!ClientRect}
   */


  computeIndicatorClientRect() {
    return this.tabIndicator_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    return this.foundation_.computeDimensions();
  }
  /**
   * Focuses the tab
   */


  focus() {
    this.root_.focus();
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$2 = {
  ANIMATING: 'mdc-tab-scroller--animating',
  SCROLL_TEST: 'mdc-tab-scroller__test',
  SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
};
/** @enum {string} */

const strings$2 = {
  AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
  CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @abstract
 */

class MDCTabScrollerRTL {
  /** @param {!MDCTabScrollerAdapter} adapter */
  constructor(adapter) {
    /** @private */
    this.adapter_ = adapter;
  }
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getScrollPositionRTL(translateX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  scrollToRTL(scrollX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  incrementScrollRTL(scrollX) {}
  /**
   * @param {number} scrollX The current scrollX position
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getAnimatingScrollPosition(scrollX, translateX) {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLDefault extends MDCTabScrollerRTL {
  /**
   * @return {number}
   */
  getScrollPositionRTL() {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const {
      right
    } = this.calculateScrollEdges_(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(right - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const edges = this.calculateScrollEdges_();
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX) {
    return scrollX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLNegative extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return Math.round(translateX - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(-scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @param {number} translateX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX - translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: rootWidth - contentWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.max(Math.min(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLReverse extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(currentScrollLeft - translateX);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX + translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: contentWidth - rootWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
 * @final
 */

class MDCTabScrollerFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$2;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$2;
  }
  /**
   * @see MDCTabScrollerAdapter for typing information
   * @return {!MDCTabScrollerAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabScrollerAdapter} */
      {
        eventTargetMatchesSelector: () => {},
        addClass: () => {},
        removeClass: () => {},
        addScrollAreaClass: () => {},
        setScrollAreaStyleProperty: () => {},
        setScrollContentStyleProperty: () => {},
        getScrollContentStyleValue: () => {},
        setScrollAreaScrollLeft: () => {},
        getScrollAreaScrollLeft: () => {},
        getScrollContentOffsetWidth: () => {},
        getScrollAreaOffsetWidth: () => {},
        computeScrollAreaClientRect: () => {},
        computeScrollContentClientRect: () => {},
        computeHorizontalScrollbarHeight: () => {}
      }
    );
  }
  /** @param {!MDCTabScrollerAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabScrollerFoundation.defaultAdapter, adapter));
    /**
     * This boolean controls whether we should handle the transitionend and interaction events during the animation.
     * @private {boolean}
     */

    this.isAnimating_ = false;
    /**
     * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
     * of RTL scrolling in it's own class.
     * @private {?MDCTabScrollerRTL}
     */

    this.rtlScrollerInstance_;
  }

  init() {
    // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
    // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
    const horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
    this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
    this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
  }
  /**
   * Computes the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    if (this.isRTL_()) {
      return this.computeCurrentScrollPositionRTL_();
    }

    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return scrollLeft - currentTranslateX;
  }
  /**
   * Handles interaction events that occur during transition
   */


  handleInteraction() {
    // Early exit if we aren't animating
    if (!this.isAnimating_) {
      return;
    } // Prevent other event listeners from handling this event


    this.stopScrollAnimation_();
  }
  /**
   * Handles the transitionend event
   * @param {!Event} evt
   */


  handleTransitionEnd(evt) {
    // Early exit if we aren't animating or the event was triggered by a different element.
    if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
      return;
    }

    this.isAnimating_ = false;
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
  }
  /**
   * Increment the scroll value by the scrollXIncrement
   * @param {number} scrollXIncrement The value by which to increment the scroll position
   */


  incrementScroll(scrollXIncrement) {
    // Early exit for non-operational increment values
    if (scrollXIncrement === 0) {
      return;
    }

    if (this.isRTL_()) {
      return this.incrementScrollRTL_(scrollXIncrement);
    }

    this.incrementScroll_(scrollXIncrement);
  }
  /**
   * Scrolls to the given scrollX value
   * @param {number} scrollX
   */


  scrollTo(scrollX) {
    if (this.isRTL_()) {
      return this.scrollToRTL_(scrollX);
    }

    this.scrollTo_(scrollX);
  }
  /**
   * Returns the appropriate version of the MDCTabScrollerRTL
   * @return {!MDCTabScrollerRTL}
   */


  getRTLScroller() {
    if (!this.rtlScrollerInstance_) {
      this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
    }

    return this.rtlScrollerInstance_;
  }
  /**
   * Returns the translateX value from a CSS matrix transform function string
   * @return {number}
   * @private
   */


  calculateCurrentTranslateX_() {
    const transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

    if (transformValue === 'none') {
      return 0;
    } // The transform value comes back as a matrix transformation in the form
    // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
    // we're going to grab all the parenthesized values, strip out tx, and
    // parse it.


    const results = /\((.+)\)/.exec(transformValue)[1];
    const parts = results.split(',');
    return parseFloat(parts[4]);
  }
  /**
   * Calculates a safe scroll value that is > 0 and < the max scroll value
   * @param {number} scrollX The distance to scroll
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }
  /**
   * @return {number}
   * @private
   */


  computeCurrentScrollPositionRTL_() {
    const translateX = this.calculateCurrentTranslateX_();
    return this.getRTLScroller().getScrollPositionRTL(translateX);
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * Internal scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollTo_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const safeScrollX = this.clampScrollValue_(scrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal RTL scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollToRTL_(scrollX) {
    const animation = this.getRTLScroller().scrollToRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Internal increment scroll method
   * @param {number} scrollX The new scroll position increment
   * @private
   */


  incrementScroll_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const targetScrollX = scrollX + currentScrollX;
    const safeScrollX = this.clampScrollValue_(targetScrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal incremenet scroll RTL method
   * @param {number} scrollX The new scroll position RTL increment
   * @private
   */


  incrementScrollRTL_(scrollX) {
    const animation = this.getRTLScroller().incrementScrollRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Animates the tab scrolling
   * @param {!MDCTabScrollerAnimation} animation The animation to apply
   * @private
   */


  animate_(animation) {
    // Early exit if translateX is 0, which means there's no animation to perform
    if (animation.scrollDelta === 0) {
      return;
    }

    this.stopScrollAnimation_(); // This animation uses the FLIP approach.
    // Read more here: https://aerotwist.com/blog/flip-your-animations/

    this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
    this.adapter_.setScrollContentStyleProperty('transform', `translateX(${animation.scrollDelta}px)`); // Force repaint

    this.adapter_.computeScrollAreaClientRect();
    requestAnimationFrame(() => {
      this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
      this.adapter_.setScrollContentStyleProperty('transform', 'none');
    });
    this.isAnimating_ = true;
  }
  /**
   * Stops scroll animation
   * @private
   */


  stopScrollAnimation_() {
    this.isAnimating_ = false;
    const currentScrollPosition = this.getAnimatingScrollPosition_();
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
    this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
    this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
  }
  /**
   * Gets the current scroll position during animation
   * @return {number}
   * @private
   */


  getAnimatingScrollPosition_() {
    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();

    if (this.isRTL_()) {
      return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
    }

    return scrollLeft - currentTranslateX;
  }
  /**
   * Determines the RTL Scroller to use
   * @return {!MDCTabScrollerRTL}
   * @private
   */


  rtlScrollerFactory_() {
    // Browsers have three different implementations of scrollLeft in RTL mode,
    // dependent on the browser. The behavior is based off the max LTR
    // scrollleft value and 0.
    //
    // * Default scrolling in RTL *
    //    - Left-most value: 0
    //    - Right-most value: Max LTR scrollLeft value
    //
    // * Negative scrolling in RTL *
    //    - Left-most value: Negated max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // * Reverse scrolling in RTL *
    //    - Left-most value: Max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // We use those principles below to determine which RTL scrollLeft
    // behavior is implemented in the current browser.
    const initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
    const newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
    // implemented negative RTL scrolling, since all other implementations have
    // only positive values.

    if (newScrollLeft < 0) {
      // Undo the scrollLeft test check
      this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
      return new MDCTabScrollerRTLNegative(this.adapter_);
    }

    const rootClientRect = this.adapter_.computeScrollAreaClientRect();
    const contentClientRect = this.adapter_.computeScrollContentClientRect();
    const rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
    // the content element, we can determine how much the scroll value changed
    // when we performed the scrollLeft subtraction above.

    if (rightEdgeDelta === newScrollLeft) {
      return new MDCTabScrollerRTLReverse(this.adapter_);
    }

    return new MDCTabScrollerRTLDefault(this.adapter_);
  }
  /**
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
 * @private {number|undefined}
 */

let horizontalScrollbarHeight_;
/**
 * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
 * May return 0 (e.g. on OS X browsers under default configuration).
 * @param {!Document} documentObj
 * @param {boolean=} shouldCacheResult
 * @return {number}
 */

function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult = true) {
  if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
    return horizontalScrollbarHeight_;
  }

  const el = documentObj.createElement('div');
  el.classList.add(cssClasses$2.SCROLL_TEST);
  documentObj.body.appendChild(el);
  const horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
  documentObj.body.removeChild(el);

  if (shouldCacheResult) {
    horizontalScrollbarHeight_ = horizontalScrollbarHeight;
  }

  return horizontalScrollbarHeight;
}
/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */


function getMatchesProperty(HTMLElementPrototype) {
  return ['msMatchesSelector', 'matches'].filter(p$$1 => p$$1 in HTMLElementPrototype).pop();
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabScrollerFoundation>}
 * @final
 */

class MDCTabScroller extends MDCComponent {
  /**
   * @param {!Element} root
   * @return {!MDCTabScroller}
   */
  static attachTo(root) {
    return new MDCTabScroller(root);
  }

  constructor(...args) {
    super(...args);
    /** @private {?Element} */

    this.content_;
    /** @private {?Element} */

    this.area_;
    /** @private {?function(?Event): undefined} */

    this.handleInteraction_;
    /** @private {?function(!Event): undefined} */

    this.handleTransitionEnd_;
  }

  initialize() {
    this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
    this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleInteraction_ = () => this.foundation_.handleInteraction();

    this.handleTransitionEnd_ = evt => this.foundation_.handleTransitionEnd(evt);

    this.area_.addEventListener('wheel', this.handleInteraction_);
    this.area_.addEventListener('touchstart', this.handleInteraction_);
    this.area_.addEventListener('pointerdown', this.handleInteraction_);
    this.area_.addEventListener('mousedown', this.handleInteraction_);
    this.area_.addEventListener('keydown', this.handleInteraction_);
    this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
  }

  destroy() {
    super.destroy();
    this.area_.removeEventListener('wheel', this.handleInteraction_);
    this.area_.removeEventListener('touchstart', this.handleInteraction_);
    this.area_.removeEventListener('pointerdown', this.handleInteraction_);
    this.area_.removeEventListener('mousedown', this.handleInteraction_);
    this.area_.removeEventListener('keydown', this.handleInteraction_);
    this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
  }
  /**
   * @return {!MDCTabScrollerFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabScrollerAdapter} */
    {
      eventTargetMatchesSelector: (evtTarget, selector) => {
        const MATCHES = getMatchesProperty(HTMLElement.prototype);
        return evtTarget[MATCHES](selector);
      },
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      addScrollAreaClass: className => this.area_.classList.add(className),
      setScrollAreaStyleProperty: (prop, value) => this.area_.style.setProperty(prop, value),
      setScrollContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value),
      getScrollContentStyleValue: propName => window.getComputedStyle(this.content_).getPropertyValue(propName),
      setScrollAreaScrollLeft: scrollX => this.area_.scrollLeft = scrollX,
      getScrollAreaScrollLeft: () => this.area_.scrollLeft,
      getScrollContentOffsetWidth: () => this.content_.offsetWidth,
      getScrollAreaOffsetWidth: () => this.area_.offsetWidth,
      computeScrollAreaClientRect: () => this.area_.getBoundingClientRect(),
      computeScrollContentClientRect: () => this.content_.getBoundingClientRect(),
      computeHorizontalScrollbarHeight: () => computeHorizontalScrollbarHeight(document)
    };
    return new MDCTabScrollerFoundation(adapter);
  }
  /**
   * Returns the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    return this.foundation_.getScrollPosition();
  }
  /**
   * Returns the width of the scroll content
   * @return {number}
   */


  getScrollContentWidth() {
    return this.content_.offsetWidth;
  }
  /**
   * Increments the scroll value by the given amount
   * @param {number} scrollXIncrement The pixel value by which to increment the scroll value
   */


  incrementScroll(scrollXIncrement) {
    this.foundation_.incrementScroll(scrollXIncrement);
  }
  /**
   * Scrolls to the given pixel position
   * @param {number} scrollX The pixel value to scroll to
   */


  scrollTo(scrollX) {
    this.foundation_.scrollTo(scrollX);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const strings$3 = {
  TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
  TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
  TAB_SELECTOR: '.mdc-tab',
  ARROW_LEFT_KEY: 'ArrowLeft',
  ARROW_RIGHT_KEY: 'ArrowRight',
  END_KEY: 'End',
  HOME_KEY: 'Home',
  ENTER_KEY: 'Enter',
  SPACE_KEY: 'Space'
};
/** @enum {number} */

const numbers = {
  EXTRA_SCROLL_AMOUNT: 20,
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  HOME_KEYCODE: 36,
  ENTER_KEYCODE: 13,
  SPACE_KEYCODE: 32
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @type {Set<string>}
 */

const ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand

ACCEPTABLE_KEYS.add(strings$3.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings$3.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings$3.END_KEY);
ACCEPTABLE_KEYS.add(strings$3.HOME_KEY);
ACCEPTABLE_KEYS.add(strings$3.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings$3.SPACE_KEY);
/**
 * @type {Map<number, string>}
 */

const KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand

KEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings$3.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings$3.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers.END_KEYCODE, strings$3.END_KEY);
KEYCODE_MAP.set(numbers.HOME_KEYCODE, strings$3.HOME_KEY);
KEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings$3.ENTER_KEY);
KEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings$3.SPACE_KEY);
/**
 * @extends {MDCFoundation<!MDCTabBarAdapter>}
 * @final
 */

class MDCTabBarFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$3;
  }
  /** @return enum {number} */


  static get numbers() {
    return numbers;
  }
  /**
   * @see MDCTabBarAdapter for typing information
   * @return {!MDCTabBarAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabBarAdapter} */
      {
        scrollTo: () => {},
        incrementScroll: () => {},
        getScrollPosition: () => {},
        getScrollContentWidth: () => {},
        getOffsetWidth: () => {},
        isRTL: () => {},
        setActiveTab: () => {},
        activateTabAtIndex: () => {},
        deactivateTabAtIndex: () => {},
        focusTabAtIndex: () => {},
        getTabIndicatorClientRectAtIndex: () => {},
        getTabDimensionsAtIndex: () => {},
        getPreviousActiveTabIndex: () => {},
        getFocusedTabIndex: () => {},
        getIndexOfTab: () => {},
        getTabListLength: () => {},
        notifyTabActivated: () => {}
      }
    );
  }
  /**
   * @param {!MDCTabBarAdapter} adapter
   * */


  constructor(adapter) {
    super(Object.assign(MDCTabBarFoundation.defaultAdapter, adapter));
    /** @private {boolean} */

    this.useAutomaticActivation_ = false;
  }
  /**
   * Switches between automatic and manual activation modes.
   * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
   * @param {boolean} useAutomaticActivation
   */


  setUseAutomaticActivation(useAutomaticActivation) {
    this.useAutomaticActivation_ = useAutomaticActivation;
  }
  /**
   * Activates the tab at the given index
   * @param {number} index
   */


  activateTab(index) {
    const previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();

    if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
      return;
    }

    this.adapter_.deactivateTabAtIndex(previousActiveIndex);
    this.adapter_.activateTabAtIndex(index, this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex));
    this.scrollIntoView(index);
    this.adapter_.notifyTabActivated(index);
  }
  /**
   * Handles the keydown event
   * @param {!Event} evt
   */


  handleKeyDown(evt) {
    // Get the key from the event
    const key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys

    if (key === undefined) {
      return;
    } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple


    if (!this.isActivationKey_(key)) {
      evt.preventDefault();
    }

    if (this.useAutomaticActivation_) {
      if (this.isActivationKey_(key)) {
        return;
      }

      const index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
      this.adapter_.setActiveTab(index);
      this.scrollIntoView(index);
    } else {
      const focusedTabIndex = this.adapter_.getFocusedTabIndex();

      if (this.isActivationKey_(key)) {
        this.adapter_.setActiveTab(focusedTabIndex);
      } else {
        const index = this.determineTargetFromKey_(focusedTabIndex, key);
        this.adapter_.focusTabAtIndex(index);
        this.scrollIntoView(index);
      }
    }
  }
  /**
   * Handles the MDCTab:interacted event
   * @param {!Event} evt
   */


  handleTabInteraction(evt) {
    this.adapter_.setActiveTab(this.adapter_.getIndexOfTab(evt.detail.tab));
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index The tab index to make visible
   */


  scrollIntoView(index) {
    // Early exit if the index is out of range
    if (!this.indexIsInRange_(index)) {
      return;
    } // Always scroll to 0 if scrolling to the 0th index


    if (index === 0) {
      return this.adapter_.scrollTo(0);
    } // Always scroll to the max value if scrolling to the Nth index
    // MDCTabScroller.scrollTo() will never scroll past the max possible value


    if (index === this.adapter_.getTabListLength() - 1) {
      return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
    }

    if (this.isRTL_()) {
      return this.scrollIntoViewRTL_(index);
    }

    this.scrollIntoView_(index);
  }
  /**
   * Private method for determining the index of the destination tab based on what key was pressed
   * @param {number} origin The original index from which to determine the destination
   * @param {string} key The name of the key
   * @return {number}
   * @private
   */


  determineTargetFromKey_(origin, key) {
    const isRTL = this.isRTL_();
    const maxIndex = this.adapter_.getTabListLength() - 1;
    const shouldGoToEnd = key === strings$3.END_KEY;
    const shouldDecrement = key === strings$3.ARROW_LEFT_KEY && !isRTL || key === strings$3.ARROW_RIGHT_KEY && isRTL;
    const shouldIncrement = key === strings$3.ARROW_RIGHT_KEY && !isRTL || key === strings$3.ARROW_LEFT_KEY && isRTL;
    let index = origin;

    if (shouldGoToEnd) {
      index = maxIndex;
    } else if (shouldDecrement) {
      index -= 1;
    } else if (shouldIncrement) {
      index += 1;
    } else {
      index = 0;
    }

    if (index < 0) {
      index = maxIndex;
    } else if (index > maxIndex) {
      index = 0;
    }

    return index;
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @return {number}
   * @private
   */


  calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
    const relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
    const leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;

    if (nextIndex < index) {
      return Math.min(leftIncrement, 0);
    }

    return Math.max(rightIncrement, 0);
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible in RTL
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @param {number} scrollContentWidth The width of the scroll content
   * @return {number}
   * @private
   */


  calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
    const relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
    const leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;

    if (nextIndex > index) {
      return Math.max(leftIncrement, 0);
    }

    return Math.min(rightIncrement, 0);
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth) {
    /**
     * Tabs are laid out in the Tab Scroller like this:
     *
     *    Scroll Position
     *    +---+
     *    |   |   Bar Width
     *    |   +-----------------------------------+
     *    |   |                                   |
     *    |   V                                   V
     *    |   +-----------------------------------+
     *    V   |             Tab Scroller          |
     *    +------------+--------------+-------------------+
     *    |    Tab     |      Tab     |        Tab        |
     *    +------------+--------------+-------------------+
     *        |                                   |
     *        +-----------------------------------+
     *
     * To determine the next adjacent index, we look at the Tab root left and
     * Tab root right, both relative to the scroll position. If the Tab root
     * left is less than 0, then we know it's out of view to the left. If the
     * Tab root right minus the bar width is greater than 0, we know the Tab is
     * out of view to the right. From there, we either increment or decrement
     * the index.
     */
    const relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
    const relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
    const relativeRootDelta = relativeRootLeft + relativeRootRight;
    const leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
    const rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;

    if (leftEdgeIsCloser) {
      return index - 1;
    }

    if (rightEdgeIsCloser) {
      return index + 1;
    }

    return -1;
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @param {number} scrollContentWidth The width of the scroller content
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
    const rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
    const rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
    const rootDelta = rootLeft + rootRight;
    const leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
    const rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;

    if (leftEdgeIsCloser) {
      return index + 1;
    }

    if (rightEdgeIsCloser) {
      return index - 1;
    }

    return -1;
  }
  /**
   * Returns the key associated with a keydown event
   * @param {!Event} evt The keydown event
   * @return {string}
   * @private
   */


  getKeyFromEvent_(evt) {
    if (ACCEPTABLE_KEYS.has(evt.key)) {
      return evt.key;
    }

    return KEYCODE_MAP.get(evt.keyCode);
  }

  isActivationKey_(key) {
    return key === strings$3.SPACE_KEY || key === strings$3.ENTER_KEY;
  }
  /**
   * Returns whether a given index is inclusively between the ends
   * @param {number} index The index to test
   * @private
   */


  indexIsInRange_(index) {
    return index >= 0 && index < this.adapter_.getTabListLength();
  }
  /**
   * Returns the view's RTL property
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.isRTL();
  }
  /**
   * Scrolls the tab at the given index into view for left-to-right useragents
   * @param {number} index The index of the tab to scroll into view
   * @private
   */


  scrollIntoView_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }
  /**
   * Scrolls the tab at the given index into view in RTL
   * @param {number} index The tab index to make visible
   * @private
   */


  scrollIntoViewRTL_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const scrollWidth = this.adapter_.getScrollContentWidth();
    const nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabBarFoundation>}
 * @final
 */

class MDCTabBar extends MDCComponent {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {!Array<!MDCTab>} */

    this.tabList_;
    /** @type {(function(!Element): !MDCTab)} */

    this.tabFactory_;
    /** @private {?MDCTabScroller} */

    this.tabScroller_;
    /** @type {(function(!Element): !MDCTabScroller)} */

    this.tabScrollerFactory_;
    /** @private {?function(?Event): undefined} */

    this.handleTabInteraction_;
    /** @private {?function(?Event): undefined} */

    this.handleKeyDown_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTabBar}
   */


  static attachTo(root) {
    return new MDCTabBar(root);
  }

  set useAutomaticActivation(useAutomaticActivation) {
    this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
  }
  /**
   * @param {(function(!Element): !MDCTab)=} tabFactory A function which creates a new MDCTab
   * @param {(function(!Element): !MDCTabScroller)=} tabScrollerFactory A function which creates a new MDCTabScroller
   */


  initialize(tabFactory = el => new MDCTab(el), tabScrollerFactory = el => new MDCTabScroller(el)) {
    this.tabFactory_ = tabFactory;
    this.tabScrollerFactory_ = tabScrollerFactory;
    this.tabList_ = this.getTabElements_().map(el => this.tabFactory_(el));
    const tabScrollerElement = this.root_.querySelector(MDCTabBarFoundation.strings.TAB_SCROLLER_SELECTOR);

    if (tabScrollerElement) {
      this.tabScroller_ = this.tabScrollerFactory_(tabScrollerElement);
    }
  }

  initialSyncWithDOM() {
    this.handleTabInteraction_ = evt => this.foundation_.handleTabInteraction(evt);

    this.handleKeyDown_ = evt => this.foundation_.handleKeyDown(evt);

    this.root_.addEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.addEventListener('keydown', this.handleKeyDown_);

    for (let i = 0; i < this.tabList_.length; i++) {
      if (this.tabList_[i].active) {
        this.scrollIntoView(i);
        break;
      }
    }
  }

  destroy() {
    super.destroy();
    this.root_.removeEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.removeEventListener('keydown', this.handleKeyDown_);
    this.tabList_.forEach(tab => tab.destroy());
    this.tabScroller_.destroy();
  }
  /**
   * @return {!MDCTabBarFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabBarFoundation(
    /** @type {!MDCTabBarAdapter} */
    {
      scrollTo: scrollX => this.tabScroller_.scrollTo(scrollX),
      incrementScroll: scrollXIncrement => this.tabScroller_.incrementScroll(scrollXIncrement),
      getScrollPosition: () => this.tabScroller_.getScrollPosition(),
      getScrollContentWidth: () => this.tabScroller_.getScrollContentWidth(),
      getOffsetWidth: () => this.root_.offsetWidth,
      isRTL: () => window.getComputedStyle(this.root_).getPropertyValue('direction') === 'rtl',
      setActiveTab: index => this.foundation_.activateTab(index),
      activateTabAtIndex: (index, clientRect) => this.tabList_[index].activate(clientRect),
      deactivateTabAtIndex: index => this.tabList_[index].deactivate(),
      focusTabAtIndex: index => this.tabList_[index].focus(),
      getTabIndicatorClientRectAtIndex: index => this.tabList_[index].computeIndicatorClientRect(),
      getTabDimensionsAtIndex: index => this.tabList_[index].computeDimensions(),
      getPreviousActiveTabIndex: () => {
        for (let i = 0; i < this.tabList_.length; i++) {
          if (this.tabList_[i].active) {
            return i;
          }
        }

        return -1;
      },
      getFocusedTabIndex: () => {
        const tabElements = this.getTabElements_();
        const activeElement = document.activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTab: tabToFind => this.tabList_.indexOf(tabToFind),
      getTabListLength: () => this.tabList_.length,
      notifyTabActivated: index => this.emit(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {
        index
      }, true)
    });
  }
  /**
   * Activates the tab at the given index
   * @param {number} index The index of the tab
   */


  activateTab(index) {
    this.foundation_.activateTab(index);
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index THe index of the tab
   */


  scrollIntoView(index) {
    this.foundation_.scrollIntoView(index);
  }

  getTabElements_() {
    return [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
  }

}

var tabBar = /*#__PURE__*/Object.freeze({
  MDCTabBar: MDCTabBar,
  MDCTabBarFoundation: MDCTabBarFoundation
});

var TabBar_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.TabBar = exports.Tab = exports.TabIcon = exports.TabLabel = void 0;

  var _get2 = _interopRequireDefault(require$$0);

  var _classCallCheck2 = _interopRequireDefault(require$$0$1);

  var _createClass2 = _interopRequireDefault(require$$1);

  var _possibleConstructorReturn2 = _interopRequireDefault(require$$2);

  var _getPrototypeOf2 = _interopRequireDefault(require$$3);

  var _inherits2 = _interopRequireDefault(require$$4);

  var _MaterialComponent5 = _interopRequireDefault(require$$5);

  var TabLabel =
  /*#__PURE__*/
  function (_MaterialComponent) {
    (0, _inherits2.default)(TabLabel, _MaterialComponent);

    function TabLabel() {
      var _this;

      (0, _classCallCheck2.default)(this, TabLabel);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabLabel).apply(this, arguments));
      _this.componentName = 'tab__text-label';
      _this.mdcProps = [];
      return _this;
    }

    (0, _createClass2.default)(TabLabel, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({}, props), props.children);
      }
    }]);
    return TabLabel;
  }(_MaterialComponent5.default);

  exports.TabLabel = TabLabel;

  var TabIcon =
  /*#__PURE__*/
  function (_MaterialComponent2) {
    (0, _inherits2.default)(TabIcon, _MaterialComponent2);

    function TabIcon() {
      var _this2;

      (0, _classCallCheck2.default)(this, TabIcon);
      _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabIcon).apply(this, arguments));
      _this2.componentName = 'tab__icon';
      _this2.mdcProps = [];
      return _this2;
    }

    (0, _createClass2.default)(TabIcon, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({
          className: "material-icons"
        }, props), props.children);
      }
    }]);
    return TabIcon;
  }(_MaterialComponent5.default);

  exports.TabIcon = TabIcon;

  var Tab =
  /*#__PURE__*/
  function (_MaterialComponent3) {
    (0, _inherits2.default)(Tab, _MaterialComponent3);

    function Tab() {
      var _this3;

      (0, _classCallCheck2.default)(this, Tab);
      _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Tab).apply(this, arguments));
      _this3.componentName = 'tab';
      _this3.mdcProps = ['active'];
      _this3.mdcNotifyProps = ['active'];
      return _this3;
    }

    (0, _createClass2.default)(Tab, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("button", Object.assign({
          class: "mdc-tab",
          role: "tab",
          "aria-selected": "true"
        }, props), (0, _preact.h)("span", {
          class: "mdc-tab__content"
        }, props.children), (0, _preact.h)("span", {
          class: "mdc-tab-indicator ".concat(props.active ? 'mdc-tab-indicator--active' : '')
        }, (0, _preact.h)("span", {
          class: "mdc-tab-indicator__content mdc-tab-indicator__content--underline"
        })), (0, _preact.h)("span", {
          class: "mdc-tab__ripple"
        }));
      }
    }]);
    return Tab;
  }(_MaterialComponent5.default);

  exports.Tab = Tab;

  var TabBar =
  /*#__PURE__*/
  function (_MaterialComponent4) {
    (0, _inherits2.default)(TabBar, _MaterialComponent4);

    function TabBar() {
      var _this4;

      (0, _classCallCheck2.default)(this, TabBar);
      _this4 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabBar).apply(this, arguments));
      _this4.componentName = 'tab-bar';
      _this4.mdcProps = [];
      _this4.mdcNotifyProps = ['activeTabIndex'];
      return _this4;
    }

    (0, _createClass2.default)(TabBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentDidMount", this).call(this);

        if (this.control) {
          this.MDComponent = new tabBar.MDCTabBar(this.control);
        }

        this.afterComponentDidMount();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentWillUnmount", this).call(this);

        if (this.MDComponent) {
          this.MDComponent.destroy();
        }
      }
    }, {
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("div", {
          class: "mdc-tab-bar",
          role: "tablist",
          ref: this.setControlRef
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-area"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-content"
        }, props.children))));
      }
    }]);
    return TabBar;
  }(_MaterialComponent5.default);

  exports.TabBar = TabBar;

  var default_1 =
  /*#__PURE__*/
  function (_TabBar) {
    (0, _inherits2.default)(default_1, _TabBar);

    function default_1() {
      (0, _classCallCheck2.default)(this, default_1);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(default_1).apply(this, arguments));
    }

    return default_1;
  }(TabBar);

  exports.default = default_1;
  default_1.Tab = Tab;
  default_1.TabLabel = TabLabel;
  default_1.TabIcon = TabIcon;
});
var TabBar = unwrapExports(TabBar_1);
var TabBar_2 = TabBar_1.TabBar;
var TabBar_3 = TabBar_1.Tab;
var TabBar_4 = TabBar_1.TabIcon;
var TabBar_5 = TabBar_1.TabLabel;

var css = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n.mdc-tab-bar {\n  width: 100%; }";
styleInject(css);

var css$1 = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n@-webkit-keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n@keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n.mdc-ripple-surface--test-edge-var-bug {\n  --mdc-ripple-surface-test-edge-var: 1px solid #000;\n  visibility: hidden; }\n  .mdc-ripple-surface--test-edge-var-bug::before {\n    border: var(--mdc-ripple-surface-test-edge-var); }\n\n.mdc-tab {\n  font-family: Roboto, sans-serif;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-size: 0.875rem;\n  line-height: 2.25rem;\n  font-weight: 500;\n  letter-spacing: 0.08929em;\n  text-decoration: none;\n  text-transform: uppercase;\n  color: rgba(0, 0, 0, 0.54);\n  /* @alternate */\n  color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n  --mdc-ripple-fg-size: 0;\n  --mdc-ripple-left: 0;\n  --mdc-ripple-top: 0;\n  --mdc-ripple-fg-scale: 1;\n  --mdc-ripple-fg-translate-end: 0;\n  --mdc-ripple-fg-translate-start: 0;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  will-change: transform, opacity;\n  display: table-cell;\n  position: relative;\n  box-sizing: border-box;\n  min-width: 160px;\n  min-height: 48px;\n  padding: 0 24px;\n  text-align: center;\n  text-decoration: none;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n  vertical-align: middle; }\n  .mdc-tab .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54)); }\n  .mdc-tab::before, .mdc-tab::after {\n    position: absolute;\n    border-radius: 50%;\n    opacity: 0;\n    pointer-events: none;\n    content: \"\"; }\n  .mdc-tab::before {\n    transition: opacity 15ms linear;\n    z-index: 1; }\n  .mdc-tab.mdc-ripple-upgraded::before {\n    -webkit-transform: scale(var(--mdc-ripple-fg-scale, 1));\n            transform: scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    top: 0;\n    /* @noflip */\n    left: 0;\n    -webkit-transform: scale(0);\n            transform: scale(0);\n    -webkit-transform-origin: center center;\n            transform-origin: center center; }\n  .mdc-tab.mdc-ripple-upgraded--unbounded::after {\n    top: var(--mdc-ripple-top, 0);\n    /* @noflip */\n    left: var(--mdc-ripple-left, 0); }\n  .mdc-tab.mdc-ripple-upgraded--foreground-activation::after {\n    -webkit-animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards;\n            animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards; }\n  .mdc-tab.mdc-ripple-upgraded--foreground-deactivation::after {\n    -webkit-animation: 150ms mdc-ripple-fg-opacity-out;\n            animation: 150ms mdc-ripple-fg-opacity-out;\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab::before, .mdc-tab::after {\n    background-color: black; }\n  .mdc-tab:hover::before {\n    opacity: 0.04; }\n  .mdc-tab:not(.mdc-ripple-upgraded):focus::before, .mdc-tab.mdc-ripple-upgraded--background-focused::before {\n    transition-duration: 75ms;\n    opacity: 0.12; }\n  .mdc-tab:not(.mdc-ripple-upgraded)::after {\n    transition: opacity 150ms linear; }\n  .mdc-tab:not(.mdc-ripple-upgraded):active::after {\n    transition-duration: 75ms;\n    opacity: 0.16; }\n  .mdc-tab.mdc-ripple-upgraded {\n    --mdc-ripple-fg-opacity: 0.16; }\n  .mdc-tab::before, .mdc-tab::after {\n    top: calc(50% - 100%);\n    /* @noflip */\n    left: calc(50% - 100%);\n    width: 200%;\n    height: 200%; }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    width: var(--mdc-ripple-fg-size, 100%);\n    height: var(--mdc-ripple-fg-size, 100%); }\n  .mdc-tab:hover {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab:hover .mdc-tab__icon {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab:focus {\n    outline: none; }\n  @media screen and (max-width: 600px) {\n    .mdc-tab {\n      min-width: 72px;\n      padding: 0 12px; } }\n  .mdc-tab__icon {\n    display: block;\n    margin: 0 auto;\n    width: 24px;\n    height: 24px; }\n    .mdc-tab-bar--icons-with-text .mdc-tab__icon {\n      margin-top: 4px; }\n  .mdc-tab__icon-text {\n    display: block;\n    margin: 0 auto; }\n  .mdc-tab__icon + .mdc-tab__icon-text {\n    padding-top: 6px; }\n\n.mdc-tab--active {\n  color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active::before {\n    bottom: 0; }\n\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 2px;\n  width: calc(100% - 4px); }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:hover .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:active .mdc-tab__indicator {\n  visibility: visible; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):hover .mdc-tab__indicator {\n  opacity: .38; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):active .mdc-tab__indicator {\n  opacity: .87; }\n\n.mdc-tab-bar__indicator,\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n\n.mdc-tab-bar {\n  display: table;\n  position: relative;\n  height: 48px;\n  margin: 0 auto;\n  text-transform: uppercase; }\n\n.mdc-tab-bar__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 0;\n  width: 100%;\n  -webkit-transform-origin: left top;\n          transform-origin: left top;\n  transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  will-change: transform; }\n\n.mdc-tab-bar--icons-with-text {\n  height: 72px; }\n\n.mdc-tab-bar-scroller {\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  background-color: inherit;\n  overflow: hidden; }\n  .mdc-tab-bar-scroller__scroll-frame {\n    display: flex;\n    position: relative;\n    flex: 1;\n    justify-content: flex-start;\n    overflow: hidden; }\n    .mdc-tab-bar-scroller__scroll-frame__tabs {\n      transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      will-change: transform; }\n  .mdc-tab-bar-scroller__indicator {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 48px;\n    cursor: pointer;\n    visibility: hidden; }\n    .mdc-tab-bar-scroller__indicator:hover {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab-bar-scroller__indicator__inner {\n      color: inherit;\n      text-decoration: inherit;\n      cursor: inherit; }\n      .mdc-tab-bar-scroller__indicator__inner:focus {\n        outline-color: inherit; }\n      .mdc-tab-bar-scroller[dir=\"rtl\"] .mdc-tab-bar-scroller__indicator__inner,\n      [dir=\"rtl\"] .mdc-tab-bar-scroller .mdc-tab-bar-scroller__indicator__inner {\n        -webkit-transform: rotate(180deg);\n                transform: rotate(180deg); }\n    .mdc-tab-bar-scroller__indicator__inner:hover {\n      color: inherit; }\n  .mdc-tab-bar-scroller__indicator--enabled {\n    visibility: visible; }";
styleInject(css$1);

var DateLinebreak = function DateLinebreak(_ref) {
  var datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex"
    }
  }, h("div", {
    style: {
      flex: "1"
    }
  }, h("hr", null)), h("div", null, new Date(datetime).toLocaleDateString()), h("div", {
    style: {
      flex: 1
    }
  }, h("hr", null)));
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MessageAligner = function MessageAligner(_ref) {
  var children = _ref.children,
      side = _ref.side,
      style = _ref.style;
  var alignment = side === "left" ? "flex-start" : "flex-end";
  return h("div", {
    style: _objectSpread({
      display: "flex",
      justifyContent: alignment
    }, style)
  }, children);
};

var MessageView = function MessageView(_ref) {
  var message = _ref.message,
      backgroundColor = _ref.backgroundColor,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      backgroundColor: backgroundColor,
      padding: 5,
      margin: 2,
      borderRadius: 15,
      borderColor: '#9E9E9E',
      borderStyle: 'solid',
      borderWidth: 2,
      maxWidth: '100%',
      wordWrap: 'break-word',
      wordBreak: 'break-all',
      minWidth: '30%'
    }
  }, h("div", null, message), h("div", {
    style: {
      fontSize: 10,
      paddingTop: 2,
      textAlign: 'end'
    }
  }, h("i", {
    style: {
      backgroundColor: '#efebe9'
    }
  }, new Date(datetime).toLocaleTimeString())));
};

var SubsequentMessage = function SubsequentMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center",
      marginLeft: 45
    }
  }, h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

var style = {
  height: 30,
  width: 40,
  padding: 3,
  borderRadius: 30,
  backgroundColor: 'darkSmoke',
  borderStyle: 'solid',
  borderWidth: 2,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: '#009688',
  borderColor: '#80cbc4'
};

var MessageAvatar = function MessageAvatar(_ref) {
  var _ref$letter = _ref.letter,
      letter = _ref$letter === void 0 ? 'U' : _ref$letter;
  return h("div", {
    style: style
  }, h("div", null, letter.toUpperCase()));
};

var FirstMessage = function FirstMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime,
      letter = _ref.letter,
      local = _ref.local;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, !local && h(MessageAvatar, {
    letter: letter
  }), h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

/* eslint-disable react/jsx-props-no-spreading */

var MessageObjectMappter = function MessageObjectMappter(props) {
  var order = props.order,
      dateSpace = props.dateSpace;
  return h("div", null, dateSpace && h(DateLinebreak, props), h(MessageAligner, props, order === 'F' ? h(FirstMessage, props) : h(SubsequentMessage, props)));
};

var useMessageSorter = function useMessageSorter(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      sortedMessages = _useState2[0],
      setSortedMessages = _useState2[1];

  p(function () {
    setSortedMessages(messages.sort(function (a, b) {
      return a.datetime - b.datetime;
    }));
  }, [messages]);
  return {
    sortedMessages: sortedMessages
  };
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useMessagesMapper = function useMessagesMapper(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      mappedMessages = _useState2[0],
      setMappedMessages = _useState2[1];

  var mapMessages = function mapMessages() {
    var localSide = "right";
    var remoteSide = "left";

    if (messages.length === 0) {
      return [];
    }

    var email = messages[0].from;
    var lastDatetime = messages[0].datetime;
    return messages.map(function (m, i) {
      if (i === 0 && m.local) {
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i === 0 && !m.local) {
        var letter = m.from[0] !== undefined ? m.from[0] : "";
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: letter
        });
      }

      if (i > 0 && email === m.from && m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "S",
            dateSpace: true
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "S",
          dateSpace: false
        });
      }

      if (i > 0 && email !== m.from && m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "F",
            dateSpace: false
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i > 0 && email === m.from && !m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          var _letter2 = m.from[0] !== undefined ? m.from[0] : "";

          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "S",
            dateSpace: true,
            letter: _letter2
          });
        }

        var _letter = m.from[0] !== undefined ? m.from[0] : "";

        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "S",
          dateSpace: false,
          letter: _letter
        });
      }

      if (i > 0 && email !== m.from && !m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          var _letter4 = m.from[0] !== undefined ? m.from[0] : "";

          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "F",
            dateSpace: false,
            letter: _letter4
          });
        }

        var _letter3 = m.from[0] !== undefined ? m.from[0] : "";

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: _letter3
        });
      }

      return null;
    });
  };

  p(function () {
    setMappedMessages(mapMessages());
  }, [messages]);
  return {
    mappedMessages: mappedMessages
  };
};

var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
});

var MessageCollectionView = function MessageCollectionView(_ref) {
  var messages = _ref.messages;

  if (messages.length > 0) {
    return messages.map(function (message, i) {
      return h(MessageObjectMappter, _extends_1({}, message, {
        key: i
      }));
    });
  }

  return null;
};

/* eslint-disable react/no-deprecated */

var MessageViewScroller = function MessageViewScroller(_ref) {
  var children = _ref.children;
  return h("div", {
    style: {
      transform: "rotate(180deg)",
      height: "85%",
      backgroundColor: "#edeff2",
      overflow: "scroll",
      width: "100%"
    }
  }, h("div", {
    style: {
      transform: "rotate(180deg)"
    }
  }, children));
};

var MessageEditorDisplayer = function MessageEditorDisplayer(_ref) {
  var onMessageChange = _ref.onMessageChange,
      message = _ref.message,
      sendMessage = _ref.sendMessage,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 0 : _ref$id,
      disabled = _ref.disabled;
  return h("div", {
    style: {
      display: 'flex'
    }
  }, h("input", {
    style: {
      flex: 1
    },
    "data-testid": "message".concat(id),
    onInput: onMessageChange,
    value: message,
    name: "message",
    type: "text",
    placeholder: "Enter message text"
  }), h("div", {
    style: {
      display: 'flex'
    }
  }, h("button", {
    "data-testid": "sendMessage".concat(id),
    disabled: message === '' || disabled,
    style: {
      marginLeft: 2,
      width: '100%'
    },
    onClick: sendMessage
  }, h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, h("path", {
    d: "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"
  }), h("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  })))));
};

/* eslint-disable no-shadow */

var MessagesDisplayer = function MessagesDisplayer(_ref) {
  var messages = _ref.messages,
      socket = _ref.socket,
      id = _ref.id,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage,
      handleMessageChange = _ref.handleMessageChange;

  var _useMessageSorter = useMessageSorter(messages),
      sortedMessages = _useMessageSorter.sortedMessages;

  var _useMessageMapper = useMessagesMapper(sortedMessages),
      mappedMessages = _useMessageMapper.mappedMessages;

  return [h(MessageViewScroller, null, h(MessageCollectionView, {
    messages: mappedMessages
  })), h(MessageEditorDisplayer, {
    disabled: socket === null,
    id: id,
    message: messageText,
    sendMessage: sendMessage,
    onMessageChange: handleMessageChange
  })];
};

var css$2 = ".chip{\n    background-color: darkgrey;\n    color: white;\n    width: 20px;\n    height: 20px;\n    border-radius: 10px;\n   line-height: 20px;\n}\n\n.media-height{\nheight: 100%;\n}\n\n\n.root{\n    padding: 3px;\n    margin-left: 5px;\n    margin-bottom: 5px;\n    box-shadow: 0 3px 3px -2px rgba(0,0,0,.2), 0 3px 4px 0 rgba(0,0,0,.14), 0 1px 8px 0 rgba(0,0,0,.12);\n}\n\n.tab-bar{\n    padding: 0;\n    width: 50%;\n    display: flex ;\n    justify-content: center;\n  \n    \n}";
styleInject(css$2);

var ChatUser = function ChatUser(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      socket = _ref.socket,
      errors = _ref.errors,
      messages = _ref.messages,
      handleMessageChange = _ref.handleMessageChange,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage;
  return h("div", {
    className: "root",
    style: {
      height: "97%",
      width: "50%"
    }
  }, h(MessagesDisplayer, {
    errors: errors,
    socket: socket,
    messages: messages,
    handleMessageChange: handleMessageChange,
    messageText: messageText,
    sendMessage: sendMessage
  }));
};

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

var useSocketMessaging = function useSocketMessaging(_ref) {
  var socket = _ref.socket,
      targetName = _ref.targetName;

  var _useState = v(''),
      _useState2 = _slicedToArray(_useState, 2),
      messageText = _useState2[0],
      setMessageText = _useState2[1];

  var _useState3 = v(null),
      _useState4 = _slicedToArray(_useState3, 2),
      messageRecieved = _useState4[0],
      setMessageRecieved = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      messageSent = _useState6[0],
      setMessageSent = _useState6[1];

  var _useState7 = v(false),
      _useState8 = _slicedToArray(_useState7, 2),
      connected = _useState8[0],
      setConnected = _useState8[1];

  var _useState9 = v([]),
      _useState10 = _slicedToArray(_useState9, 2),
      errors = _useState10[0],
      setError = _useState10[1];

  var sendMessage = function sendMessage() {
    var datetime = new Date().getTime();
    socket.emit("text_message", {
      reciever: targetName,
      message: messageText,
      datetime: datetime
    });
    setMessageSent({
      reciever: targetName,
      datetime: datetime,
      message: messageText
    });
    setMessageText('');
  };

  var handleMessageChange = function handleMessageChange(e) {
    setMessageText(e.target.value);
  };

  p(function () {
    if (socket !== null) {
      socket.on("text_message", function (data) {
        var sender = data.sender,
            message = data.message,
            datetime = data.datetime;
        setMessageRecieved({
          sender: sender,
          message: message,
          datetime: datetime
        });
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("disconnect", function () {
        setConnected(false);
      });
      socket.on('error', function (error) {
        setError([].concat(toConsumableArray(errors), [error]));
      });
    }
  });
  return {
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    handleMessageChange: handleMessageChange,
    errors: errors,
    connected: connected
  };
};

var useChatLog = function useChatLog(_ref) {
  var name = _ref.name,
      messageRecieved = _ref.messageRecieved,
      messageSent = _ref.messageSent;

  var _useState = v([]),
      _useState2 = _slicedToArray(_useState, 2),
      messages = _useState2[0],
      setMessages = _useState2[1];

  var saveToLocalStorage = function saveToLocalStorage(m, key) {
    var persistedMessages = JSON.parse(localStorage.getItem(key)) === null ? [m] : [].concat(toConsumableArray(JSON.parse(localStorage.getItem(key))), [m]);
    localStorage.setItem(key, JSON.stringify(persistedMessages));
    return persistedMessages;
  }; // componentDidMount


  p(function () {
    setMessages(JSON.parse(localStorage.getItem(name)) === null ? [] : toConsumableArray(JSON.parse(localStorage.getItem(name))));
  }, []); // saveRemoteMessage

  p(function () {
    if (messageRecieved !== null) {
      var datetime = messageRecieved.datetime,
          message = messageRecieved.message,
          sender = messageRecieved.sender;
      var local = false;
      setMessages(saveToLocalStorage({
        message: message,
        from: sender,
        local: local,
        datetime: datetime,
        to: name
      }, name));
    }
  }, [messageRecieved]); // saveLocalMessage

  p(function () {
    if (messageSent !== null) {
      var datetime = messageSent.datetime,
          message = messageSent.message,
          reciever = messageSent.reciever;
      var local = true;
      var from = name;
      setMessages(saveToLocalStorage({
        message: message,
        from: from,
        local: local,
        datetime: datetime,
        to: reciever
      }, name));
    }
  }, [messageSent]);
  return {
    messages: messages
  };
};

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

var parseuri = function parseuri(str) {
  var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');

  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }

  var m = re.exec(str || ''),
      uri = {},
      i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }

  return uri;
};

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h$1 = m * 60;
var d = h$1 * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h$1) {
    return plural(ms, msAbs, h$1, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set `diff` timestamp

      const curr = Number(new Date());
      const ms$$1 = curr - (prevTime || curr);
      self.diff = ms$$1;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    const index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      const instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

var common = setup;

var browser = createCommonjsModule(function (module, exports) {
  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log(...args) {
    // This hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return typeof console === 'object' && console.log && console.log(...args);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    let r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
});
var browser_1 = browser.log;
var browser_2 = browser.formatArgs;
var browser_3 = browser.save;
var browser_4 = browser.load;
var browser_5 = browser.useColors;
var browser_6 = browser.storage;
var browser_7 = browser.colors;

/**
 * Module dependencies.
 */

var debug = browser('socket.io-client:url');
/**
 * Module exports.
 */

var url_1 = url;
/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc) {
  var obj = uri; // default to window.location

  loc = loc || typeof location !== 'undefined' && location;
  if (null == uri) uri = loc.protocol + '//' + loc.host; // relative path support

  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);

      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    } // parse


    debug('parse %s', uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';
  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host; // define unique id

  obj.id = obj.protocol + '://' + host + ':' + obj.port; // define href

  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
  return obj;
}

/**
 * Helpers.
 */
var s$1 = 1000;
var m$1 = s$1 * 60;
var h$2 = m$1 * 60;
var d$1 = h$2 * 24;
var y$1 = d$1 * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse$1(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;

    case 'days':
    case 'day':
    case 'd':
      return n * d$1;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort$1(ms) {
  if (ms >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }

  if (ms >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }

  if (ms >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }

  if (ms >= s$1) {
    return Math.round(ms / s$1) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong$1(ms) {
  return plural$1(ms, d$1, 'day') || plural$1(ms, h$2, 'hour') || plural$1(ms, m$1, 'minute') || plural$1(ms, s$1, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = ms$1;
  /**
   * Active `debug` instances.
   */

  exports.instances = [];
  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};
  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0,
        i;

    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */


  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // disabled?
      if (!debug.enabled) return;
      var self = debug; // set `diff` timestamp

      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr; // turn the `arguments` into a proper Array

      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      } // apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];

        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // apply env-specific formatting (colors, etc.)

      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy; // env-specific initialization logic for debug instances

    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    exports.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = exports.instances.indexOf(this);

    if (index !== -1) {
      exports.instances.splice(index, 1);
      return true;
    } else {
      return false;
    }
  }
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */


  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < exports.instances.length; i++) {
      var instance = exports.instances[i];
      instance.enabled = exports.enabled(instance.namespace);
    }
  }
  /**
   * Disable debug output.
   *
   * @api public
   */


  function disable() {
    exports.enable('');
  }
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i, len;

    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */


  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
});
var debug_1 = debug$1.coerce;
var debug_2 = debug$1.disable;
var debug_3 = debug$1.enable;
var debug_4 = debug$1.enabled;
var debug_5 = debug$1.humanize;
var debug_6 = debug$1.instances;
var debug_7 = debug$1.names;
var debug_8 = debug$1.skips;
var debug_9 = debug$1.formatters;

var browser$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = debug$1;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */


  exports.formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors) return;
    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if ('%%' === match) return;
      index++;

      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    var r;

    try {
      r = exports.storage.debug;
    } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */


  exports.enable(load());
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});
var browser_1$1 = browser$1.log;
var browser_2$1 = browser$1.formatArgs;
var browser_3$1 = browser$1.save;
var browser_4$1 = browser$1.load;
var browser_5$1 = browser$1.useColors;
var browser_6$1 = browser$1.storage;
var browser_7$1 = browser$1.colors;

var componentEmitter = createCommonjsModule(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1),
        callbacks = this._callbacks['$' + event];

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
});

var toString = {}.toString;

var isarray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;
var isArray = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}
Buffer.isBuffer = isBuffer;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read$$1(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read$$1(arr, i + j) !== read$$1(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write$$1(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var isBuffer$1 = isBuf;
var withNativeBuffer = typeof Buffer === 'function' && typeof isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */


function isBuf(obj) {
  return withNativeBuffer && isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
}

/*global Blob,File*/

/**
 * Module requirements
 */

var toString$2 = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$2.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString$2.call(File) === '[object FileConstructor]';
/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

var deconstructPacket = function (packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuffer$1(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (isarray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};

    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }

    return newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */


var reconstructPacket = function (packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isarray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}
/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */


var removeBlobs = function (data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj; // convert any blob

    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
      pendingBlobs++; // async filereader

      var fileReader = new FileReader();

      fileReader.onload = function () {
        // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        } else {
          bloblessData = this.result;
        } // if nothing pending its callback time


        if (! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isarray(obj)) {
      // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuffer$1(obj)) {
      // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;

  _removeBlobs(bloblessData);

  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

var binary = {
  deconstructPacket: deconstructPacket,
  reconstructPacket: reconstructPacket,
  removeBlobs: removeBlobs
};

var socket_ioParser = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser$1('socket.io-parser');
  /**
   * Protocol version.
   *
   * @api public
   */

  exports.protocol = 4;
  /**
   * Packet types.
   *
   * @api public
   */

  exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
  /**
   * Packet type `connect`.
   *
   * @api public
   */

  exports.CONNECT = 0;
  /**
   * Packet type `disconnect`.
   *
   * @api public
   */

  exports.DISCONNECT = 1;
  /**
   * Packet type `event`.
   *
   * @api public
   */

  exports.EVENT = 2;
  /**
   * Packet type `ack`.
   *
   * @api public
   */

  exports.ACK = 3;
  /**
   * Packet type `error`.
   *
   * @api public
   */

  exports.ERROR = 4;
  /**
   * Packet type 'binary event'
   *
   * @api public
   */

  exports.BINARY_EVENT = 5;
  /**
   * Packet type `binary ack`. For acks with binary arguments.
   *
   * @api public
   */

  exports.BINARY_ACK = 6;
  /**
   * Encoder constructor.
   *
   * @api public
   */

  exports.Encoder = Encoder;
  /**
   * Decoder constructor.
   *
   * @api public
   */

  exports.Decoder = Decoder;
  /**
   * A socket.io Encoder instance
   *
   * @api public
   */

  function Encoder() {}

  var ERROR_PACKET = exports.ERROR + '"encode error"';
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   * @param {Function} callback - function to handle encodings (likely engine.write)
   * @return Calls callback with Array of encodings
   * @api public
   */

  Encoder.prototype.encode = function (obj, callback) {
    debug('encoding packet %j', obj);

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      encodeAsBinary(obj, callback);
    } else {
      var encoding = encodeAsString(obj);
      callback([encoding]);
    }
  };
  /**
   * Encode packet as string.
   *
   * @param {Object} packet
   * @return {String} encoded
   * @api private
   */


  function encodeAsString(obj) {
    // first is type
    var str = '' + obj.type; // attachments if we have them

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      str += obj.attachments + '-';
    } // if we have a namespace other than `/`
    // we append it followed by a comma `,`


    if (obj.nsp && '/' !== obj.nsp) {
      str += obj.nsp + ',';
    } // immediately followed by the id


    if (null != obj.id) {
      str += obj.id;
    } // json data


    if (null != obj.data) {
      var payload = tryStringify(obj.data);

      if (payload !== false) {
        str += payload;
      } else {
        return ERROR_PACKET;
      }
    }

    debug('encoded %j as %s', obj, str);
    return str;
  }

  function tryStringify(str) {
    try {
      return JSON.stringify(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   *
   * @param {Object} packet
   * @return {Buffer} encoded
   * @api private
   */


  function encodeAsBinary(obj, callback) {
    function writeEncoding(bloblessData) {
      var deconstruction = binary.deconstructPacket(bloblessData);
      var pack = encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      callback(buffers); // write all the buffers
    }

    binary.removeBlobs(obj, writeEncoding);
  }
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   * @api public
   */


  function Decoder() {
    this.reconstructor = null;
  }
  /**
   * Mix in `Emitter` with Decoder.
   */


  componentEmitter(Decoder.prototype);
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   * @return {Object} packet
   * @api public
   */

  Decoder.prototype.add = function (obj) {
    var packet;

    if (typeof obj === 'string') {
      packet = decodeString(obj);

      if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
        // binary packet's json
        this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

        if (this.reconstructor.reconPack.attachments === 0) {
          this.emit('decoded', packet);
        }
      } else {
        // non-binary full packet
        this.emit('decoded', packet);
      }
    } else if (isBuffer$1(obj) || obj.base64) {
      // raw binary data
      if (!this.reconstructor) {
        throw new Error('got binary data when not reconstructing a packet');
      } else {
        packet = this.reconstructor.takeBinaryData(obj);

        if (packet) {
          // received final buffer
          this.reconstructor = null;
          this.emit('decoded', packet);
        }
      }
    } else {
      throw new Error('Unknown type: ' + obj);
    }
  };
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   * @api private
   */


  function decodeString(str) {
    var i = 0; // look up type

    var p$$1 = {
      type: Number(str.charAt(0))
    };

    if (null == exports.types[p$$1.type]) {
      return error('unknown packet type ' + p$$1.type);
    } // look up attachments if type binary


    if (exports.BINARY_EVENT === p$$1.type || exports.BINARY_ACK === p$$1.type) {
      var buf = '';

      while (str.charAt(++i) !== '-') {
        buf += str.charAt(i);
        if (i == str.length) break;
      }

      if (buf != Number(buf) || str.charAt(i) !== '-') {
        throw new Error('Illegal attachments');
      }

      p$$1.attachments = Number(buf);
    } // look up namespace (if any)


    if ('/' === str.charAt(i + 1)) {
      p$$1.nsp = '';

      while (++i) {
        var c = str.charAt(i);
        if (',' === c) break;
        p$$1.nsp += c;
        if (i === str.length) break;
      }
    } else {
      p$$1.nsp = '/';
    } // look up id


    var next = str.charAt(i + 1);

    if ('' !== next && Number(next) == next) {
      p$$1.id = '';

      while (++i) {
        var c = str.charAt(i);

        if (null == c || Number(c) != c) {
          --i;
          break;
        }

        p$$1.id += str.charAt(i);
        if (i === str.length) break;
      }

      p$$1.id = Number(p$$1.id);
    } // look up json data


    if (str.charAt(++i)) {
      var payload = tryParse(str.substr(i));
      var isPayloadValid = payload !== false && (p$$1.type === exports.ERROR || isarray(payload));

      if (isPayloadValid) {
        p$$1.data = payload;
      } else {
        return error('invalid payload');
      }
    }

    debug('decoded %s as %j', str, p$$1);
    return p$$1;
  }

  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Deallocates a parser's resources
   *
   * @api public
   */


  Decoder.prototype.destroy = function () {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  };
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   * @api private
   */


  function BinaryReconstructor(packet) {
    this.reconPack = packet;
    this.buffers = [];
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   * @api private
   */


  BinaryReconstructor.prototype.takeBinaryData = function (binData) {
    this.buffers.push(binData);

    if (this.buffers.length === this.reconPack.attachments) {
      // done with buffer list
      var packet = binary.reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }

    return null;
  };
  /**
   * Cleans up binary packet reconstruction variables.
   *
   * @api private
   */


  BinaryReconstructor.prototype.finishedReconstruction = function () {
    this.reconPack = null;
    this.buffers = [];
  };

  function error(msg) {
    return {
      type: exports.ERROR,
      data: 'parser error: ' + msg
    };
  }
});
var socket_ioParser_1 = socket_ioParser.protocol;
var socket_ioParser_2 = socket_ioParser.types;
var socket_ioParser_3 = socket_ioParser.CONNECT;
var socket_ioParser_4 = socket_ioParser.DISCONNECT;
var socket_ioParser_5 = socket_ioParser.EVENT;
var socket_ioParser_6 = socket_ioParser.ACK;
var socket_ioParser_7 = socket_ioParser.ERROR;
var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
var socket_ioParser_10 = socket_ioParser.Encoder;
var socket_ioParser_11 = socket_ioParser.Decoder;

var hasCors = createCommonjsModule(function (module) {
  /**
   * Module exports.
   *
   * Logic borrowed from Modernizr:
   *
   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
   */
  try {
    module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
    module.exports = false;
  }
});

var xmlhttprequest = function (opts) {
  var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

  var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217

  var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE

  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
      return new XMLHttpRequest();
    }
  } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example


  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) {}
  }
};

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */
var keys = Object.keys || function keys(obj) {
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }

  return arr;
};

var toString$3 = {}.toString;

var isarray$1 = Array.isArray || function (arr) {
  return toString$3.call(arr) == '[object Array]';
};

/* global Blob File */

/*
 * Module requirements.
 */

var toString$4 = Object.prototype.toString;
var withNativeBlob$1 = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$4.call(Blob) === '[object BlobConstructor]';
var withNativeFile$1 = typeof File === 'function' || typeof File !== 'undefined' && toString$4.call(File) === '[object FileConstructor]';
/**
 * Module exports.
 */

var hasBinary2 = hasBinary;
/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isarray$1(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (typeof Buffer === 'function' && isBuffer && isBuffer(obj) || typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
    return true;
  } // see: https://github.com/Automattic/has-binary/pull/4


  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */
var arraybuffer_slice = function (arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) {
    return arraybuffer.slice(start, end);
  }

  if (start < 0) {
    start += bytes;
  }

  if (end < 0) {
    end += bytes;
  }

  if (end > bytes) {
    end = bytes;
  }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);

  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }

  return result.buffer;
};

var after_1 = after;

function after(count, callback, err_cb) {
  var bail = false;
  err_cb = err_cb || noop;
  proxy.count = count;
  return count === 0 ? callback() : proxy;

  function proxy(err, result) {
    if (proxy.count <= 0) {
      throw new Error('after called too many times');
    }

    --proxy.count; // after first error, rest are passed to err_cb

    if (err) {
      bail = true;
      callback(err); // future error callbacks will go to error handler

      callback = err_cb;
    } else if (proxy.count === 0 && !bail) {
      callback(null, result);
    }
  }
}

function noop() {}

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode

function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  var value;
  var extra;

  while (counter < length) {
    value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
} // Taken from https://mths.be/punycode


function ucs2encode(array) {
  var length = array.length;
  var index = -1;
  var value;
  var output = '';

  while (++index < length) {
    value = array[index];

    if (value > 0xFFFF) {
      value -= 0x10000;
      output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      value = 0xDC00 | value & 0x3FF;
    }

    output += stringFromCharCode(value);
  }

  return output;
}

function checkScalarValue(codePoint, strict) {
  if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    if (strict) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }

    return false;
  }

  return true;
}
/*--------------------------------------------------------------------------*/


function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
}

function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 0xFFFFFF80) == 0) {
    // 1-byte sequence
    return stringFromCharCode(codePoint);
  }

  var symbol = '';

  if ((codePoint & 0xFFFFF800) == 0) {
    // 2-byte sequence
    symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
  } else if ((codePoint & 0xFFFF0000) == 0) {
    // 3-byte sequence
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 0xFFFD;
    }

    symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 0xFFE00000) == 0) {
    // 4-byte sequence
    symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }

  symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
  return symbol;
}

function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length = codePoints.length;
  var index = -1;
  var codePoint;
  var byteString = '';

  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint, strict);
  }

  return byteString;
}
/*--------------------------------------------------------------------------*/


function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error('Invalid byte index');
  }

  var continuationByte = byteArray[byteIndex] & 0xFF;
  byteIndex++;

  if ((continuationByte & 0xC0) == 0x80) {
    return continuationByte & 0x3F;
  } // If we end up here, its not a continuation byte


  throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;

  if (byteIndex > byteCount) {
    throw Error('Invalid byte index');
  }

  if (byteIndex == byteCount) {
    return false;
  } // Read first byte


  byte1 = byteArray[byteIndex] & 0xFF;
  byteIndex++; // 1-byte sequence (no continuation bytes)

  if ((byte1 & 0x80) == 0) {
    return byte1;
  } // 2-byte sequence


  if ((byte1 & 0xE0) == 0xC0) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 0x1F) << 6 | byte2;

    if (codePoint >= 0x80) {
      return codePoint;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 3-byte sequence (may include unpaired surrogates)


  if ((byte1 & 0xF0) == 0xE0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;

    if (codePoint >= 0x0800) {
      return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 4-byte sequence


  if ((byte1 & 0xF8) == 0xF0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;

    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      return codePoint;
    }
  }

  throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;

function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;

  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }

  return ucs2encode(codePoints);
}

var utf8 = {
  version: '2.1.2',
  encode: utf8encode,
  decode: utf8decode
};

var base64Arraybuffer = createCommonjsModule(function (module, exports) {
  /*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
  (function () {

    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index.

    var lookup = new Uint8Array(256);

    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }

    exports.encode = function (arraybuffer) {
      var bytes = new Uint8Array(arraybuffer),
          i,
          len = bytes.length,
          base64 = "";

      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }

      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }

      return base64;
    };

    exports.decode = function (base64) {
      var bufferLength = base64.length * 0.75,
          len = base64.length,
          i,
          p$$1 = 0,
          encoded1,
          encoded2,
          encoded3,
          encoded4;

      if (base64[base64.length - 1] === "=") {
        bufferLength--;

        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }

      var arraybuffer = new ArrayBuffer(bufferLength),
          bytes = new Uint8Array(arraybuffer);

      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p$$1++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p$$1++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p$$1++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }

      return arraybuffer;
    };
  })();
});
var base64Arraybuffer_1 = base64Arraybuffer.encode;
var base64Arraybuffer_2 = base64Arraybuffer.decode;

/**
 * Create a blob builder even when vendor prefixes exist
 */
var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : false;
/**
 * Check if Blob constructor is supported
 */

var blobSupported = function () {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */


var blobSupportsArrayBufferView = blobSupported && function () {
  try {
    var b = new Blob([new Uint8Array([1, 2])]);
    return b.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if BlobBuilder is supported
 */


var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function (chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer; // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer

      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};
  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function (part) {
    bb.append(part);
  });
  return options.type ? bb.getBlob(options.type) : bb.getBlob();
}

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
}

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

var blob = function () {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
}();

var browser$2 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var base64encoder;

  if (typeof ArrayBuffer !== 'undefined') {
    base64encoder = base64Arraybuffer;
  }
  /**
   * Check if we are running an android browser. That requires us to use
   * ArrayBuffer with polling transports...
   *
   * http://ghinda.net/jpeg-blob-ajax-android/
   */


  var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
  /**
   * Check if we are running in PhantomJS.
   * Uploading a Blob with PhantomJS does not work correctly, as reported here:
   * https://github.com/ariya/phantomjs/issues/11395
   * @type boolean
   */

  var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
  /**
   * When true, avoids using Blobs to encode payloads.
   * @type boolean
   */

  var dontSendBlobs = isAndroid || isPhantomJS;
  /**
   * Current protocol version.
   */

  exports.protocol = 3;
  /**
   * Packet types.
   */

  var packets = exports.packets = {
    open: 0 // non-ws
    ,
    close: 1 // non-ws
    ,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = keys(packets);
  /**
   * Premade error packet.
   */

  var err = {
    type: 'error',
    data: 'parser error'
  };
  /**
   * Create a blob api even for blob builder when vendor prefixes exist
   */

  /**
   * Encodes a packet.
   *
   *     <packet type id> [ <data> ]
   *
   * Example:
   *
   *     5hello world
   *     3
   *     4
   *
   * Binary is encoded in an identical principle
   *
   * @api private
   */

  exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = false;
    }

    if (typeof utf8encode === 'function') {
      callback = utf8encode;
      utf8encode = null;
    }

    var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

    if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
      return encodeArrayBuffer(packet, supportsBinary, callback);
    } else if (typeof blob !== 'undefined' && data instanceof blob) {
      return encodeBlob(packet, supportsBinary, callback);
    } // might be an object with { base64: true, data: dataAsBase64String }


    if (data && data.base64) {
      return encodeBase64Object(packet, callback);
    } // Sending data as a utf-8 string


    var encoded = packets[packet.type]; // data fragment is optional

    if (undefined !== packet.data) {
      encoded += utf8encode ? utf8.encode(String(packet.data), {
        strict: false
      }) : String(packet.data);
    }

    return callback('' + encoded);
  };

  function encodeBase64Object(packet, callback) {
    // packet data is an object { base64: true, data: dataAsBase64String }
    var message = 'b' + exports.packets[packet.type] + packet.data.data;
    return callback(message);
  }
  /**
   * Encode packet helpers for binary types
   */


  function encodeArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var data = packet.data;
    var contentArray = new Uint8Array(data);
    var resultBuffer = new Uint8Array(1 + data.byteLength);
    resultBuffer[0] = packets[packet.type];

    for (var i = 0; i < contentArray.length; i++) {
      resultBuffer[i + 1] = contentArray[i];
    }

    return callback(resultBuffer.buffer);
  }

  function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var fr = new FileReader();

    fr.onload = function () {
      exports.encodePacket({
        type: packet.type,
        data: fr.result
      }, supportsBinary, true, callback);
    };

    return fr.readAsArrayBuffer(packet.data);
  }

  function encodeBlob(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    if (dontSendBlobs) {
      return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
    }

    var length = new Uint8Array(1);
    length[0] = packets[packet.type];
    var blob$$1 = new blob([length.buffer, packet.data]);
    return callback(blob$$1);
  }
  /**
   * Encodes a packet with binary data in a base64 string
   *
   * @param {Object} packet, has `type` and `data`
   * @return {String} base64 encoded message
   */


  exports.encodeBase64Packet = function (packet, callback) {
    var message = 'b' + exports.packets[packet.type];

    if (typeof blob !== 'undefined' && packet.data instanceof blob) {
      var fr = new FileReader();

      fr.onload = function () {
        var b64 = fr.result.split(',')[1];
        callback(message + b64);
      };

      return fr.readAsDataURL(packet.data);
    }

    var b64data;

    try {
      b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
    } catch (e) {
      // iPhone Safari doesn't let you apply with typed arrays
      var typed = new Uint8Array(packet.data);
      var basic = new Array(typed.length);

      for (var i = 0; i < typed.length; i++) {
        basic[i] = typed[i];
      }

      b64data = String.fromCharCode.apply(null, basic);
    }

    message += btoa(b64data);
    return callback(message);
  };
  /**
   * Decodes a packet. Changes format to Blob if requested.
   *
   * @return {Object} with `type` and `data` (if any)
   * @api private
   */


  exports.decodePacket = function (data, binaryType, utf8decode) {
    if (data === undefined) {
      return err;
    } // String data


    if (typeof data === 'string') {
      if (data.charAt(0) === 'b') {
        return exports.decodeBase64Packet(data.substr(1), binaryType);
      }

      if (utf8decode) {
        data = tryDecode(data);

        if (data === false) {
          return err;
        }
      }

      var type = data.charAt(0);

      if (Number(type) != type || !packetslist[type]) {
        return err;
      }

      if (data.length > 1) {
        return {
          type: packetslist[type],
          data: data.substring(1)
        };
      } else {
        return {
          type: packetslist[type]
        };
      }
    }

    var asArray = new Uint8Array(data);
    var type = asArray[0];
    var rest = arraybuffer_slice(data, 1);

    if (blob && binaryType === 'blob') {
      rest = new blob([rest]);
    }

    return {
      type: packetslist[type],
      data: rest
    };
  };

  function tryDecode(data) {
    try {
      data = utf8.decode(data, {
        strict: false
      });
    } catch (e) {
      return false;
    }

    return data;
  }
  /**
   * Decodes a packet encoded in a base64 string
   *
   * @param {String} base64 encoded message
   * @return {Object} with `type` and `data` (if any)
   */


  exports.decodeBase64Packet = function (msg, binaryType) {
    var type = packetslist[msg.charAt(0)];

    if (!base64encoder) {
      return {
        type: type,
        data: {
          base64: true,
          data: msg.substr(1)
        }
      };
    }

    var data = base64encoder.decode(msg.substr(1));

    if (binaryType === 'blob' && blob) {
      data = new blob([data]);
    }

    return {
      type: type,
      data: data
    };
  };
  /**
   * Encodes multiple messages (payload).
   *
   *     <length>:data
   *
   * Example:
   *
   *     11:hello world2:hi
   *
   * If any contents are binary, they will be encoded as base64 strings. Base64
   * encoded strings are marked with a b before the length specifier
   *
   * @param {Array} packets
   * @api private
   */


  exports.encodePayload = function (packets, supportsBinary, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = null;
    }

    var isBinary = hasBinary2(packets);

    if (supportsBinary && isBinary) {
      if (blob && !dontSendBlobs) {
        return exports.encodePayloadAsBlob(packets, callback);
      }

      return exports.encodePayloadAsArrayBuffer(packets, callback);
    }

    if (!packets.length) {
      return callback('0:');
    }

    function setLengthHeader(message) {
      return message.length + ':' + message;
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
        doneCallback(null, setLengthHeader(message));
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(results.join(''));
    });
  };
  /**
   * Async array map using after
   */


  function map(ary, each, done) {
    var result = new Array(ary.length);
    var next = after_1(ary.length, done);

    var eachWithIndex = function (i, el, cb) {
      each(el, function (error, msg) {
        result[i] = msg;
        cb(error, result);
      });
    };

    for (var i = 0; i < ary.length; i++) {
      eachWithIndex(i, ary[i], next);
    }
  }
  /*
   * Decodes data when a payload is maybe expected. Possible binary contents are
   * decoded from their base64 representation
   *
   * @param {String} data, callback method
   * @api public
   */


  exports.decodePayload = function (data, binaryType, callback) {
    if (typeof data !== 'string') {
      return exports.decodePayloadAsBinary(data, binaryType, callback);
    }

    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var packet;

    if (data === '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    var length = '',
        n,
        msg;

    for (var i = 0, l = data.length; i < l; i++) {
      var chr = data.charAt(i);

      if (chr !== ':') {
        length += chr;
        continue;
      }

      if (length === '' || length != (n = Number(length))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, false);

        if (err.type === packet.type && err.data === packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      } // advance cursor


      i += n;
      length = '';
    }

    if (length !== '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }
  };
  /**
   * Encodes multiple messages (payload) as binary.
   *
   * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
   * 255><data>
   *
   * Example:
   * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
   *
   * @param {Array} packets
   * @return {ArrayBuffer} encoded payload
   * @api private
   */


  exports.encodePayloadAsArrayBuffer = function (packets, callback) {
    if (!packets.length) {
      return callback(new ArrayBuffer(0));
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (data) {
        return doneCallback(null, data);
      });
    }

    map(packets, encodeOne, function (err, encodedPackets) {
      var totalLength = encodedPackets.reduce(function (acc, p$$1) {
        var len;

        if (typeof p$$1 === 'string') {
          len = p$$1.length;
        } else {
          len = p$$1.byteLength;
        }

        return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
      }, 0);
      var resultArray = new Uint8Array(totalLength);
      var bufferIndex = 0;
      encodedPackets.forEach(function (p$$1) {
        var isString = typeof p$$1 === 'string';
        var ab = p$$1;

        if (isString) {
          var view = new Uint8Array(p$$1.length);

          for (var i = 0; i < p$$1.length; i++) {
            view[i] = p$$1.charCodeAt(i);
          }

          ab = view.buffer;
        }

        if (isString) {
          // not true binary
          resultArray[bufferIndex++] = 0;
        } else {
          // true binary
          resultArray[bufferIndex++] = 1;
        }

        var lenStr = ab.byteLength.toString();

        for (var i = 0; i < lenStr.length; i++) {
          resultArray[bufferIndex++] = parseInt(lenStr[i]);
        }

        resultArray[bufferIndex++] = 255;
        var view = new Uint8Array(ab);

        for (var i = 0; i < view.length; i++) {
          resultArray[bufferIndex++] = view[i];
        }
      });
      return callback(resultArray.buffer);
    });
  };
  /**
   * Encode as Blob
   */


  exports.encodePayloadAsBlob = function (packets, callback) {
    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (encoded) {
        var binaryIdentifier = new Uint8Array(1);
        binaryIdentifier[0] = 1;

        if (typeof encoded === 'string') {
          var view = new Uint8Array(encoded.length);

          for (var i = 0; i < encoded.length; i++) {
            view[i] = encoded.charCodeAt(i);
          }

          encoded = view.buffer;
          binaryIdentifier[0] = 0;
        }

        var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
        var lenStr = len.toString();
        var lengthAry = new Uint8Array(lenStr.length + 1);

        for (var i = 0; i < lenStr.length; i++) {
          lengthAry[i] = parseInt(lenStr[i]);
        }

        lengthAry[lenStr.length] = 255;

        if (blob) {
          var blob$$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
          doneCallback(null, blob$$1);
        }
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(new blob(results));
    });
  };
  /*
   * Decodes data when a payload is maybe expected. Strings are decoded by
   * interpreting each byte as a key code for entries marked to start with 0. See
   * description of encodePayloadAsBinary
   *
   * @param {ArrayBuffer} data, callback method
   * @api public
   */


  exports.decodePayloadAsBinary = function (data, binaryType, callback) {
    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var bufferTail = data;
    var buffers = [];

    while (bufferTail.byteLength > 0) {
      var tailArray = new Uint8Array(bufferTail);
      var isString = tailArray[0] === 0;
      var msgLength = '';

      for (var i = 1;; i++) {
        if (tailArray[i] === 255) break; // 310 = char length of Number.MAX_VALUE

        if (msgLength.length > 310) {
          return callback(err, 0, 1);
        }

        msgLength += tailArray[i];
      }

      bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
      msgLength = parseInt(msgLength);
      var msg = arraybuffer_slice(bufferTail, 0, msgLength);

      if (isString) {
        try {
          msg = String.fromCharCode.apply(null, new Uint8Array(msg));
        } catch (e) {
          // iPhone Safari doesn't let you apply to typed arrays
          var typed = new Uint8Array(msg);
          msg = '';

          for (var i = 0; i < typed.length; i++) {
            msg += String.fromCharCode(typed[i]);
          }
        }
      }

      buffers.push(msg);
      bufferTail = arraybuffer_slice(bufferTail, msgLength);
    }

    var total = buffers.length;
    buffers.forEach(function (buffer, i) {
      callback(exports.decodePacket(buffer, binaryType, true), i, total);
    });
  };
});
var browser_1$2 = browser$2.protocol;
var browser_2$2 = browser$2.packets;
var browser_3$2 = browser$2.encodePacket;
var browser_4$2 = browser$2.encodeBase64Packet;
var browser_5$2 = browser$2.decodePacket;
var browser_6$2 = browser$2.decodeBase64Packet;
var browser_7$2 = browser$2.encodePayload;
var browser_8 = browser$2.decodePayload;
var browser_9 = browser$2.encodePayloadAsArrayBuffer;
var browser_10 = browser$2.encodePayloadAsBlob;
var browser_11 = browser$2.decodePayloadAsBinary;

/**
 * Module dependencies.
 */

/**
 * Module exports.
 */

var transport = Transport;
/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport(opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode; // results of ReactNative environment detection

  this.isReactNative = opts.isReactNative; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Transport.prototype);
/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};
/**
 * Opens the transport.
 *
 * @api public
 */


Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};
/**
 * Closes the transport.
 *
 * @api private
 */


Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};
/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */


Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};
/**
 * Called upon open
 *
 * @api private
 */


Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};
/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */


Transport.prototype.onData = function (data) {
  var packet = browser$2.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};
/**
 * Called with a decoded packet.
 */


Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon close.
 *
 * @api private
 */


Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
var encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */


var decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');

  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }

  return qry;
};

var parseqs = {
  encode: encode,
  decode: decode
};

var componentInherit = function (a, b) {
  var fn = function () {};

  fn.prototype = b.prototype;
  a.prototype = new fn();
  a.prototype.constructor = a;
};

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */

function encode$1(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */


function decode$1(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */


function yeast() {
  var now = encode$1(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode$1(seed++);
} //
// Map each character to its index.
//


for (; i < length; i++) map[alphabet[i]] = i; //
// Expose the `yeast`, `encode` and `decode` functions.
//


yeast.encode = encode$1;
yeast.decode = decode$1;
var yeast_1 = yeast;

/**
 * Module dependencies.
 */

var debug$2 = browser('engine.io-client:polling');
/**
 * Module exports.
 */

var polling = Polling;
/**
 * Is XHR2 supported?
 */

var hasXHR2 = function () {
  var XMLHttpRequest = xmlhttprequest;
  var xhr = new XMLHttpRequest({
    xdomain: false
  });
  return null != xhr.responseType;
}();
/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */


function Polling(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(Polling, transport);
/**
 * Transport name.
 */

Polling.prototype.name = 'polling';
/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};
/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */


Polling.prototype.pause = function (onPause) {
  var self = this;
  this.readyState = 'pausing';

  function pause() {
    debug$2('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug$2('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug$2('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug$2('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug$2('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};
/**
 * Starts polling cycle.
 *
 * @api public
 */


Polling.prototype.poll = function () {
  debug$2('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};
/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */


Polling.prototype.onData = function (data) {
  var self = this;
  debug$2('polling got data %s', data);

  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    } // if its a close packet, we close the ongoing requests


    if ('close' === packet.type) {
      self.onClose();
      return false;
    } // otherwise bypass onData and handle the message


    self.onPacket(packet);
  }; // decode payload


  browser$2.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing

  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug$2('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};
/**
 * For polling, send a close packet.
 *
 * @api private
 */


Polling.prototype.doClose = function () {
  var self = this;

  function close() {
    debug$2('writing close packet');
    self.write([{
      type: 'close'
    }]);
  }

  if ('open' === this.readyState) {
    debug$2('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug$2('transport not open - deferring close');
    this.once('open', close);
  }
};
/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */


Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  browser$2.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = ''; // cache busting is forced

  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // avoid port if default for schema

  if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // prepend ? to query


  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/* global attachEvent */

/**
 * Module requirements.
 */

var debug$3 = browser('engine.io-client:polling-xhr');
/**
 * Module exports.
 */

var pollingXhr = XHR;
var Request_1 = Request;
/**
 * Empty function
 */

function empty() {}
/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */


function XHR(opts) {
  polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = typeof location !== 'undefined' && opts.hostname !== location.hostname || port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(XHR, polling);
/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;
/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout; // other options for Node.js client

  opts.extraHeaders = this.extraHeaders;
  return new Request(opts);
};
/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */


XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({
    method: 'POST',
    data: data,
    isBinary: isBinary
  });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


XHR.prototype.doPoll = function () {
  debug$3('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};
/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */


function Request(opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.create();
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Request.prototype);
/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = {
    agent: this.agent,
    xdomain: this.xd,
    xscheme: this.xs,
    enablesXDR: this.enablesXDR
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  var xhr = this.xhr = new xmlhttprequest(opts);
  var self = this;

  try {
    debug$3('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);

    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {} // ie6 check


    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };

      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');

            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }

        if (4 !== xhr.readyState) return;

        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug$3('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};
/**
 * Called upon successful response.
 *
 * @api private
 */


Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};
/**
 * Called if we have data.
 *
 * @api private
 */


Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};
/**
 * Called upon error.
 *
 * @api private
 */


Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};
/**
 * Cleans up house.
 *
 * @api private
 */


Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  } // xmlhttprequest


  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};
/**
 * Called upon load.
 *
 * @api private
 */


Request.prototype.onLoad = function () {
  var data;

  try {
    var contentType;

    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}

    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }

  if (null != data) {
    this.onData(data);
  }
};
/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */


Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};
/**
 * Aborts the request.
 *
 * @api public
 */


Request.prototype.abort = function () {
  this.cleanup();
};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */


Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
pollingXhr.Request = Request_1;

/**
 * Module requirements.
 */

/**
 * Module exports.
 */

var pollingJsonp = JSONPPolling;
/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
/**
 * Global JSONP callbacks.
 */

var callbacks;
/**
 * Noop.
 */

function empty$1() {}
/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */


function glob() {
  return typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : {};
}
/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */


function JSONPPolling(opts) {
  polling.call(this, opts);
  this.query = this.query || {}; // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution

  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = global.___eio || [];
  } // callback identifier


  this.index = callbacks.length; // add callback to jsonp global

  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  }); // append to query string

  this.query.j = this.index; // prevent spurious errors from being emitted when the window is unloaded

  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty$1;
    }, false);
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(JSONPPolling, polling);
/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;
/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  polling.prototype.doClose.call(this);
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();

  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];

  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }

  this.script = script;
  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};
/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */


JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;
    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);
    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete() {
    initIframe();
    fn();
  }

  function initIframe() {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;
    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side

  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

var require$$1$1 = {};

/**
 * Module dependencies.
 */

var debug$4 = browser('engine.io-client:websocket');
var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require$$1$1;
  } catch (e) {}
}
/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */


var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
/**
 * Module exports.
 */

var websocket = WS;
/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (forceBase64) {
    this.supportsBinary = false;
  }

  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;

  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(WS, transport);
/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';
/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;
/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};
/**
 * Adds event listeners to the socket
 *
 * @api private
 */


WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };

  this.ws.onclose = function () {
    self.onClose();
  };

  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };

  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};
/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */


WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false; // encodePacket efficient as it uses WS framing
  // no need for encodePayload

  var total = packets.length;

  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      browser$2.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};

          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;

            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        } // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error


        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug$4('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done() {
    self.emit('flush'); // fake drain
    // defer to next tick to allow Socket to clear writeBuffer

    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};
/**
 * Called upon close
 *
 * @api private
 */


WS.prototype.onClose = function () {
  transport.prototype.onClose.call(this);
};
/**
 * Closes socket.
 *
 * @api private
 */


WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = ''; // avoid port if default for schema

  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // append timestamp to URI


  if (this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  } // communicate binary support capabilities


  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // prepend ? to query

  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};
/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */


WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/**
 * Module dependencies
 */

/**
 * Export transports.
 */

var polling_1 = polling$1;
var websocket_1 = websocket;
/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling$1(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new xmlhttprequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new pollingXhr(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new pollingJsonp(opts);
  }
}

var transports = {
  polling: polling_1,
  websocket: websocket_1
};

var indexOf = [].indexOf;

var indexof = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/**
 * Module dependencies.
 */

var debug$5 = browser('engine.io-client:socket');
/**
 * Module exports.
 */

var socket = Socket;
/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);
  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure : typeof location !== 'undefined' && 'https:' === location.protocol;

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port ? location.port : this.secure ? 443 : 80);
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
  if (true === this.perMessageDeflate) this.perMessageDeflate = {};

  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  } // SSL options for Node.js client


  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode; // detect ReactNative environment

  this.isReactNative = typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative'; // other options for Node.js or ReactNative client

  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  } // set on handshake


  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null; // set on heartbeat

  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;
  this.open();
}

Socket.priorWebsocketSuccess = false;
/**
 * Mix in `Emitter`.
 */

componentEmitter(Socket.prototype);
/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = browser$2.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = transport;
Socket.transports = transports;
Socket.parser = browser$2;
/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug$5('creating transport "%s"', name);
  var query = clone(this.query); // append engine.io protocol identifier

  query.EIO = browser$2.protocol; // transport name

  query.transport = name; // per-transport options

  var options = this.transportOptions[name] || {}; // session id if we already have one

  if (this.id) query.sid = this.id;
  var transport$$1 = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void 0,
    isReactNative: this.isReactNative
  });
  return transport$$1;
};

function clone(obj) {
  var o = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }

  return o;
}
/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */


Socket.prototype.open = function () {
  var transport$$1;

  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport$$1 = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport$$1 = this.transports[0];
  }

  this.readyState = 'opening'; // Retry with the next transport if the transport is disabled (jsonp: false)

  try {
    transport$$1 = this.createTransport(transport$$1);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport$$1.open();
  this.setTransport(transport$$1);
};
/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */


Socket.prototype.setTransport = function (transport$$1) {
  debug$5('setting transport %s', transport$$1.name);
  var self = this;

  if (this.transport) {
    debug$5('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  } // set up transport


  this.transport = transport$$1; // set up transport listeners

  transport$$1.on('drain', function () {
    self.onDrain();
  }).on('packet', function (packet) {
    self.onPacket(packet);
  }).on('error', function (e) {
    self.onError(e);
  }).on('close', function () {
    self.onClose('transport close');
  });
};
/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */


Socket.prototype.probe = function (name) {
  debug$5('probing transport "%s"', name);
  var transport$$1 = this.createTransport(name, {
    probe: 1
  });
  var failed = false;
  var self = this;
  Socket.priorWebsocketSuccess = false;

  function onTransportOpen() {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }

    if (failed) return;
    debug$5('probe transport "%s" opened', name);
    transport$$1.send([{
      type: 'ping',
      data: 'probe'
    }]);
    transport$$1.once('packet', function (msg) {
      if (failed) return;

      if ('pong' === msg.type && 'probe' === msg.data) {
        debug$5('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport$$1);
        if (!transport$$1) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport$$1.name;
        debug$5('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug$5('changing transport and sending upgrade packet');
          cleanup();
          self.setTransport(transport$$1);
          transport$$1.send([{
            type: 'upgrade'
          }]);
          self.emit('upgrade', transport$$1);
          transport$$1 = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug$5('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport$$1.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return; // Any callback called by transport should be ignored since now

    failed = true;
    cleanup();
    transport$$1.close();
    transport$$1 = null;
  } // Handle any error that happens while probing


  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport$$1.name;
    freezeTransport();
    debug$5('probe transport "%s" failed because of error: %s', name, err);
    self.emit('upgradeError', error);
  }

  function onTransportClose() {
    onerror('transport closed');
  } // When the socket is closed while we're probing


  function onclose() {
    onerror('socket closed');
  } // When the socket is upgraded while we're probing


  function onupgrade(to) {
    if (transport$$1 && to.name !== transport$$1.name) {
      debug$5('"%s" works - aborting "%s"', to.name, transport$$1.name);
      freezeTransport();
    }
  } // Remove all listeners on the transport and on self


  function cleanup() {
    transport$$1.removeListener('open', onTransportOpen);
    transport$$1.removeListener('error', onerror);
    transport$$1.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport$$1.once('open', onTransportOpen);
  transport$$1.once('error', onerror);
  transport$$1.once('close', onTransportClose);
  this.once('close', onclose);
  this.once('upgrading', onupgrade);
  transport$$1.open();
};
/**
 * Called when connection is deemed open.
 *
 * @api public
 */


Socket.prototype.onOpen = function () {
  debug$5('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush(); // we check for `readyState` in case an `open`
  // listener already closed the socket

  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug$5('starting upgrade probes');

    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};
/**
 * Handles a packet.
 *
 * @api private
 */


Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);
    this.emit('packet', packet); // Socket is live - any packet counts

    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug$5('packet received with socket readyState "%s"', this.readyState);
  }
};
/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */


Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen(); // In case open handler closes socket

  if ('closed' === this.readyState) return;
  this.setPing(); // Prolong liveness of socket on heartbeat

  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};
/**
 * Resets ping timeout.
 *
 * @api private
 */


Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || self.pingInterval + self.pingTimeout);
};
/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */


Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug$5('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};
/**
* Sends a ping packet.
*
* @api private
*/


Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};
/**
 * Called on `drain` event
 *
 * @api private
 */


Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`

  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};
/**
 * Flush write buffers.
 *
 * @api private
 */


Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
    debug$5('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`

    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};
/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */


Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};
/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */


Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;
  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};
/**
 * Closes the connection.
 *
 * @api private
 */


Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';
    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug$5('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};
/**
 * Called upon transport error
 *
 * @api private
 */


Socket.prototype.onError = function (err) {
  debug$5('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};
/**
 * Called upon transport close.
 *
 * @api private
 */


Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket close with reason: "%s"', reason);
    var self = this; // clear timers

    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport

    this.transport.removeAllListeners('close'); // ensure transport won't stay open

    this.transport.close(); // ignore further transport communication

    this.transport.removeAllListeners(); // set ready state

    this.readyState = 'closed'; // clear session id

    this.id = null; // emit close event

    this.emit('close', reason, desc); // clean buffers after, so users can still
    // grab the buffers on `close` event

    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};
/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */


Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];

  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~indexof(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }

  return filteredUpgrades;
};

var lib = socket;
/**
 * Exports parser
 *
 * @api public
 *
 */

var parser = browser$2;
lib.parser = parser;

var toArray_1 = toArray;

function toArray(list, index) {
  var array = [];
  index = index || 0;

  for (var i = index || 0; i < list.length; i++) {
    array[i - index] = list[i];
  }

  return array;
}

/**
 * Module exports.
 */
var on_1 = on;
/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

/**
 * Slice reference.
 */
var slice = [].slice;
/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

var componentBind = function (obj, fn) {
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function () {
    return fn.apply(obj, args.concat(slice.call(arguments)));
  };
};

var socket$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client:socket');
  /**
   * Module exports.
   */

  module.exports = exports = Socket;
  /**
   * Internal events (blacklisted).
   * These events can't be emitted by the user.
   *
   * @api private
   */

  var events = {
    connect: 1,
    connect_error: 1,
    connect_timeout: 1,
    connecting: 1,
    disconnect: 1,
    error: 1,
    reconnect: 1,
    reconnect_attempt: 1,
    reconnect_failed: 1,
    reconnect_error: 1,
    reconnecting: 1,
    ping: 1,
    pong: 1
  };
  /**
   * Shortcut to `Emitter#emit`.
   */

  var emit = componentEmitter.prototype.emit;
  /**
   * `Socket` constructor.
   *
   * @api public
   */

  function Socket(io, nsp, opts) {
    this.io = io;
    this.nsp = nsp;
    this.json = this; // compat

    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    this.flags = {};

    if (opts && opts.query) {
      this.query = opts.query;
    }

    if (this.io.autoConnect) this.open();
  }
  /**
   * Mix in `Emitter`.
   */


  componentEmitter(Socket.prototype);
  /**
   * Subscribe to open, close and packet events
   *
   * @api private
   */

  Socket.prototype.subEvents = function () {
    if (this.subs) return;
    var io = this.io;
    this.subs = [on_1(io, 'open', componentBind(this, 'onopen')), on_1(io, 'packet', componentBind(this, 'onpacket')), on_1(io, 'close', componentBind(this, 'onclose'))];
  };
  /**
   * "Opens" the socket.
   *
   * @api public
   */


  Socket.prototype.open = Socket.prototype.connect = function () {
    if (this.connected) return this;
    this.subEvents();
    this.io.open(); // ensure open

    if ('open' === this.io.readyState) this.onopen();
    this.emit('connecting');
    return this;
  };
  /**
   * Sends a `message` event.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.send = function () {
    var args = toArray_1(arguments);
    args.unshift('message');
    this.emit.apply(this, args);
    return this;
  };
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @param {String} event name
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.emit = function (ev) {
    if (events.hasOwnProperty(ev)) {
      emit.apply(this, arguments);
      return this;
    }

    var args = toArray_1(arguments);
    var packet = {
      type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback

    if ('function' === typeof args[args.length - 1]) {
      debug('emitting packet with ack id %d', this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }

    if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }

    this.flags = {};
    return this;
  };
  /**
   * Sends a packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.packet = function (packet) {
    packet.nsp = this.nsp;
    this.io.packet(packet);
  };
  /**
   * Called upon engine `open`.
   *
   * @api private
   */


  Socket.prototype.onopen = function () {
    debug('transport is open - connecting'); // write connect packet if necessary

    if ('/' !== this.nsp) {
      if (this.query) {
        var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
        debug('sending connect packet with query %s', query);
        this.packet({
          type: socket_ioParser.CONNECT,
          query: query
        });
      } else {
        this.packet({
          type: socket_ioParser.CONNECT
        });
      }
    }
  };
  /**
   * Called upon engine `close`.
   *
   * @param {String} reason
   * @api private
   */


  Socket.prototype.onclose = function (reason) {
    debug('close (%s)', reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emit('disconnect', reason);
  };
  /**
   * Called with socket packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onpacket = function (packet) {
    var sameNamespace = packet.nsp === this.nsp;
    var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === '/';
    if (!sameNamespace && !rootNamespaceError) return;

    switch (packet.type) {
      case socket_ioParser.CONNECT:
        this.onconnect();
        break;

      case socket_ioParser.EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.BINARY_EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.ACK:
        this.onack(packet);
        break;

      case socket_ioParser.BINARY_ACK:
        this.onack(packet);
        break;

      case socket_ioParser.DISCONNECT:
        this.ondisconnect();
        break;

      case socket_ioParser.ERROR:
        this.emit('error', packet.data);
        break;
    }
  };
  /**
   * Called upon a server event.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onevent = function (packet) {
    var args = packet.data || [];
    debug('emitting event %j', args);

    if (null != packet.id) {
      debug('attaching ack callback to event');
      args.push(this.ack(packet.id));
    }

    if (this.connected) {
      emit.apply(this, args);
    } else {
      this.receiveBuffer.push(args);
    }
  };
  /**
   * Produces an ack callback to emit with an event.
   *
   * @api private
   */


  Socket.prototype.ack = function (id) {
    var self = this;
    var sent = false;
    return function () {
      // prevent double callbacks
      if (sent) return;
      sent = true;
      var args = toArray_1(arguments);
      debug('sending ack %j', args);
      self.packet({
        type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
        id: id,
        data: args
      });
    };
  };
  /**
   * Called upon a server acknowlegement.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onack = function (packet) {
    var ack = this.acks[packet.id];

    if ('function' === typeof ack) {
      debug('calling ack %s with %j', packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug('bad ack %s', packet.id);
    }
  };
  /**
   * Called upon server connect.
   *
   * @api private
   */


  Socket.prototype.onconnect = function () {
    this.connected = true;
    this.disconnected = false;
    this.emit('connect');
    this.emitBuffered();
  };
  /**
   * Emit buffered events (received and emitted).
   *
   * @api private
   */


  Socket.prototype.emitBuffered = function () {
    var i;

    for (i = 0; i < this.receiveBuffer.length; i++) {
      emit.apply(this, this.receiveBuffer[i]);
    }

    this.receiveBuffer = [];

    for (i = 0; i < this.sendBuffer.length; i++) {
      this.packet(this.sendBuffer[i]);
    }

    this.sendBuffer = [];
  };
  /**
   * Called upon server disconnect.
   *
   * @api private
   */


  Socket.prototype.ondisconnect = function () {
    debug('server disconnect (%s)', this.nsp);
    this.destroy();
    this.onclose('io server disconnect');
  };
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @api private.
   */


  Socket.prototype.destroy = function () {
    if (this.subs) {
      // clean subscriptions to avoid reconnections
      for (var i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }

      this.subs = null;
    }

    this.io.destroy(this);
  };
  /**
   * Disconnects the socket manually.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.close = Socket.prototype.disconnect = function () {
    if (this.connected) {
      debug('performing disconnect (%s)', this.nsp);
      this.packet({
        type: socket_ioParser.DISCONNECT
      });
    } // remove socket from pool


    this.destroy();

    if (this.connected) {
      // fire events
      this.onclose('io client disconnect');
    }

    return this;
  };
  /**
   * Sets the compress flag.
   *
   * @param {Boolean} if `true`, compresses the sending data
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.compress = function (compress) {
    this.flags.compress = compress;
    return this;
  };
  /**
   * Sets the binary flag
   *
   * @param {Boolean} whether the emitted data contains binary
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.binary = function (binary) {
    this.flags.binary = binary;
    return this;
  };
});

/**
 * Expose `Backoff`.
 */
var backo2 = Backoff;
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */


Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);

  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }

  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */


Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */


Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */


Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */


Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/**
 * Module dependencies.
 */

var debug$6 = browser('socket.io-client:manager');
/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;
/**
 * Module exports
 */

var manager = Manager;
/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new backo2({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];

  var _parser = opts.parser || socket_ioParser;

  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}
/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */


Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);

  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};
/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */


Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};
/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */


Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
};
/**
 * Mix in `Emitter`.
 */


componentEmitter(Manager.prototype);
/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v$$1) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v$$1;
  return this;
};
/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionAttempts = function (v$$1) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v$$1;
  return this;
};
/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelay = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v$$1;
  this.backoff && this.backoff.setMin(v$$1);
  return this;
};

Manager.prototype.randomizationFactor = function (v$$1) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v$$1;
  this.backoff && this.backoff.setJitter(v$$1);
  return this;
};
/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelayMax = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v$$1;
  this.backoff && this.backoff.setMax(v$$1);
  return this;
};
/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.timeout = function (v$$1) {
  if (!arguments.length) return this._timeout;
  this._timeout = v$$1;
  return this;
};
/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */


Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};
/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */


Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
  debug$6('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;
  debug$6('opening %s', this.uri);
  this.engine = lib(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false; // emit `open`

  var openSub = on_1(socket, 'open', function () {
    self.onopen();
    fn && fn();
  }); // emit `connect_error`

  var errorSub = on_1(socket, 'error', function (data) {
    debug$6('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);

    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  }); // emit `connect_timeout`

  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug$6('connect attempt will timeout after %d', timeout); // set timer

    var timer = setTimeout(function () {
      debug$6('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);
  return this;
};
/**
 * Called upon transport open.
 *
 * @api private
 */


Manager.prototype.onopen = function () {
  debug$6('open'); // clear old subs

  this.cleanup(); // mark as open

  this.readyState = 'open';
  this.emit('open'); // add new subs

  var socket = this.engine;
  this.subs.push(on_1(socket, 'data', componentBind(this, 'ondata')));
  this.subs.push(on_1(socket, 'ping', componentBind(this, 'onping')));
  this.subs.push(on_1(socket, 'pong', componentBind(this, 'onpong')));
  this.subs.push(on_1(socket, 'error', componentBind(this, 'onerror')));
  this.subs.push(on_1(socket, 'close', componentBind(this, 'onclose')));
  this.subs.push(on_1(this.decoder, 'decoded', componentBind(this, 'ondecoded')));
};
/**
 * Called upon a ping.
 *
 * @api private
 */


Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};
/**
 * Called upon a packet.
 *
 * @api private
 */


Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};
/**
 * Called with data.
 *
 * @api private
 */


Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};
/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */


Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon socket error.
 *
 * @api private
 */


Manager.prototype.onerror = function (err) {
  debug$6('error', err);
  this.emitAll('error', err);
};
/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */


Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];

  if (!socket) {
    socket = new socket$1(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexof(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};
/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */


Manager.prototype.destroy = function (socket) {
  var index = indexof(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;
  this.close();
};
/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */


Manager.prototype.packet = function (packet) {
  debug$6('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }

      self.encoding = false;
      self.processPacketQueue();
    });
  } else {
    // add packet to the queue
    self.packetBuffer.push(packet);
  }
};
/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */


Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};
/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */


Manager.prototype.cleanup = function () {
  debug$6('cleanup');
  var subsLength = this.subs.length;

  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;
  this.decoder.destroy();
};
/**
 * Close the current socket.
 *
 * @api private
 */


Manager.prototype.close = Manager.prototype.disconnect = function () {
  debug$6('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;

  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }

  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};
/**
 * Called upon engine close.
 *
 * @api private
 */


Manager.prototype.onclose = function (reason) {
  debug$6('onclose');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};
/**
 * Attempt a reconnection.
 *
 * @api private
 */


Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;
  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug$6('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug$6('will wait %dms before reconnect attempt', delay);
    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;
      debug$6('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events

      if (self.skipReconnect) return;
      self.open(function (err) {
        if (err) {
          debug$6('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug$6('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};
/**
 * Called upon successful reconnect.
 *
 * @api private
 */


Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

var lib$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client');
  /**
   * Module exports.
   */

  module.exports = exports = lookup;
  /**
   * Managers cache.
   */

  var cache = exports.managers = {};
  /**
   * Looks up an existing `Manager` for multiplexing.
   * If the user summons:
   *
   *   `io('http://localhost/a');`
   *   `io('http://localhost/b');`
   *
   * We reuse the existing instance based on same scheme/port/host,
   * and we initialize sockets for each namespace.
   *
   * @api public
   */

  function lookup(uri, opts) {
    if (typeof uri === 'object') {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    var parsed = url_1(uri);
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] && path in cache[id].nsps;
    var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
    var io;

    if (newConnection) {
      debug('ignoring socket cache for %s', source);
      io = manager(source, opts);
    } else {
      if (!cache[id]) {
        debug('new io instance for %s', source);
        cache[id] = manager(source, opts);
      }

      io = cache[id];
    }

    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }

    return io.socket(parsed.path, opts);
  }
  /**
   * Protocol version.
   *
   * @api public
   */


  exports.protocol = socket_ioParser.protocol;
  /**
   * `connect`.
   *
   * @param {String} uri
   * @api public
   */

  exports.connect = lookup;
  /**
   * Expose constructors for standalone build.
   *
   * @api public
   */

  exports.Manager = manager;
  exports.Socket = socket$1;
});
var lib_1 = lib$1.managers;
var lib_2 = lib$1.protocol;
var lib_3 = lib$1.connect;
var lib_4 = lib$1.Manager;
var lib_5 = lib$1.Socket;

var useSocket = function useSocket(_ref) {
  var username = _ref.username,
      _ref$route = _ref.route,
      route = _ref$route === void 0 ? '/anonymous' : _ref$route,
      serverUrl = _ref.serverUrl;

  var _useState = v(null),
      _useState2 = _slicedToArray(_useState, 2),
      socket = _useState2[0],
      setSocket = _useState2[1];

  var _useState3 = v(false),
      _useState4 = _slicedToArray(_useState3, 2),
      connected = _useState4[0],
      setConnected = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      socketError = _useState6[0],
      setSocketError = _useState6[1];

  p(function () {
    function fetchToken() {
      var response, data;
      return _regeneratorRuntime.async(function fetchToken$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return _regeneratorRuntime.awrap(fetch(route, {
                method: "POST",
                body: JSON.stringify({
                  username: username
                }),
                headers: {
                  "Content-Type": "application/json"
                }
              }));

            case 3:
              response = _context.sent;
              _context.next = 6;
              return _regeneratorRuntime.awrap(response.json());

            case 6:
              data = _context.sent;
              setSocket(lib$1(serverUrl, {
                query: "token=".concat(data.token)
              }));
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](0);
              setSocketError(_context.t0);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[0, 10]]);
    }

    fetchToken();
  }, []);
  p(function () {
    if (socket !== null) {
      socket.on("error", function (error) {
        setSocketError(error);
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("message", function () {});
    }
  }, [socket]);
  return {
    socket: socket,
    connected: connected,
    socketError: socketError
  };
};

var useSocketClient = function useSocketClient(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      route = _ref.route,
      serverUrl = _ref.serverUrl;

  var _useSocket = useSocket({
    username: name,
    route: route,
    serverUrl: serverUrl
  }),
      socket = _useSocket.socket,
      connected = _useSocket.connected,
      socketError = _useSocket.socketError;

  var _useSocketMessaging = useSocketMessaging({
    socket: socket,
    targetName: targetName
  }),
      errors = _useSocketMessaging.errors,
      handleMessageChange = _useSocketMessaging.handleMessageChange,
      messageRecieved = _useSocketMessaging.messageRecieved,
      messageSent = _useSocketMessaging.messageSent,
      messageText = _useSocketMessaging.messageText,
      sendMessage = _useSocketMessaging.sendMessage;

  var _useChatLog = useChatLog({
    name: name,
    messageRecieved: messageRecieved,
    messageSent: messageSent
  }),
      messages = _useChatLog.messages;

  return {
    messages: messages,
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    errors: errors,
    connected: connected,
    handleMessageChange: handleMessageChange
  };
};

var ChatRoom = function ChatRoom() {
  var _useState = v(0),
      _useState2 = _slicedToArray(_useState, 2),
      msgForMario = _useState2[0],
      setMsgForMario = _useState2[1];

  var _useState3 = v(0),
      _useState4 = _slicedToArray(_useState3, 2),
      msgForDragos = _useState4[0],
      setMsgForDragos = _useState4[1];

  var _useState5 = v(0),
      _useState6 = _slicedToArray(_useState5, 2),
      selectedItem = _useState6[0],
      setSelectedItem = _useState6[1];

  var _useSocketClient = useSocketClient({
    name: "mario",
    targetName: "dragos",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgMario = _useSocketClient.messages,
      msgRecMario = _useSocketClient.messageRecieved,
      msgSntMario = _useSocketClient.messageSent,
      msgTxtMario = _useSocketClient.messageText,
      sendMsgMario = _useSocketClient.sendMessage,
      errMario = _useSocketClient.errors,
      cntMario = _useSocketClient.connected,
      hdleMessageChageMario = _useSocketClient.handleMessageChange,
      marioSocket = _useSocketClient.socket;

  var _useSocketClient2 = useSocketClient({
    name: "dragos",
    targetName: "mario",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgDragos = _useSocketClient2.messages,
      msgRecDragos = _useSocketClient2.messageRecieved,
      msgSntDragos = _useSocketClient2.messageSent,
      msgTxtDragos = _useSocketClient2.messageText,
      sendMsgDragos = _useSocketClient2.sendMessage,
      errDragos = _useSocketClient2.errors,
      cntDragos = _useSocketClient2.connected,
      hdleMessageChageDragos = _useSocketClient2.handleMessageChange,
      dragosSocket = _useSocketClient2.socket;

  p(function () {
    if (msgForDragos !== null) setMsgForDragos(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecDragos]);
  p(function () {
    if (msgForMario !== null) setMsgForMario(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecMario]);
  p(function () {
    if (selectedItem === 0) {
      setMsgForMario(0);
    } else {
      setMsgForDragos(0);
    }
  }, [selectedItem]);
  return h("div", {
    style: {
      width: "100%",
      height: "100%"
    }
  }, h("div", {
    className: "tab-bar"
  }, h("div", null, h(TabBar, null, h(TabBar.Tab, {
    active: true,
    onClick: function onClick() {
      return setSelectedItem(0);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntMario ? "green" : "orange"
    }
  }, "mario"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForMario > 0 ? "green" : "darkgrey"
    }
  }, msgForMario)))), h(TabBar.Tab, {
    onClick: function onClick() {
      return setSelectedItem(1);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntDragos ? "green" : "orange"
    }
  }, "dragos"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForDragos > 0 ? "green" : "darkgrey"
    }
  }, msgForDragos))))))), selectedItem === 0 && h(ChatUser, {
    handleMessageChange: hdleMessageChageMario,
    connected: cntMario,
    errors: errMario,
    messageSent: msgSntMario,
    messageText: msgTxtMario,
    messages: msgMario,
    sendMessage: sendMsgMario,
    messageRecieved: msgRecMario,
    socket: dragosSocket,
    name: "mario",
    targetName: "dragos"
  }), selectedItem === 1 && h(ChatUser, {
    handleMessageChange: hdleMessageChageDragos,
    connected: cntDragos,
    errors: errDragos,
    messageSent: msgSntDragos,
    messageText: msgTxtDragos,
    messages: msgDragos,
    sendMessage: sendMsgDragos,
    messageRecieved: msgRecDragos,
    socket: dragosSocket,
    name: "dragos",
    targetName: "mario"
  }));
};

var SocketIOMessaging = function SocketIOMessaging() {
  return h(ChatRoom, null);
};

var WebRTCMessaging = function WebRTCMessaging() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTC Messaging");
};

var WebRTCVideoChat = function WebRTCVideoChat() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTCVideoChat");
};

export { SocketIOMessaging as a, WebRTCMessaging as b, WebRTCVideoChat as c };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmstODlhZDE2ZmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9hZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL3NsaWRpbmctZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9mYWRpbmctZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL2FkYXB0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9hZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLXNjcm9sbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLWRlZmF1bHQtc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ydGwtbmVnYXRpdmUtc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ydGwtcmV2ZXJzZS1zY3JvbGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvYWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcmVhY3QtbWF0ZXJpYWwtY29tcG9uZW50cy9UYWJCYXIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2Utb2JqZWN0LW1hcHBlci9kYXRlLWxpbmVicmVhay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1hbGlnbmVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS12aWV3LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvc3Vic2VxdWVudC1tZXNzYWdlLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1hdmF0YXIuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2Utb2JqZWN0LW1hcHBlci9maXJzdC1tZXNzYWdlLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1vYmplY3QtbWFwcGVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi91c2VNZXNzYWdlU29ydGVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi91c2VNZXNzYWdlTWFwcGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1jb2xsZWN0aW9uLXZpZXcuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2VzLXZpZXctc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlLWVkaXRvci1kaXNwbGF5ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2VzLWRpc3BsYXllci5qcyIsIi4uL21vZHVsZXMvc29ja2V0LWlvLW1lc3NhZ2luZy9DaGF0VXNlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLWhvb2tzL3NvY2tldC1pby1tZXNzYWdpbmcvdXNlU29ja2V0TWVzc2FnaW5nLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtaG9va3MvdXNlQ2hhdExvZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2Jhc2U2NC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2llZWU3NTQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9pc0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcmVzb2x2ZS9zcmMvZW1wdHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS1ob29rcy9zb2NrZXQtaW8tbWVzc2FnaW5nL3VzZVNvY2tldC5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLWhvb2tzL3NvY2tldC1pby1tZXNzYWdpbmcvdXNlU29ja2V0Q2xpZW50LmpzIiwiLi4vbW9kdWxlcy9zb2NrZXQtaW8tbWVzc2FnaW5nL0NoYXRSb29tLmpzIiwiLi4vbW9kdWxlcy9zb2NrZXQtaW8tbWVzc2FnaW5nL2luZGV4LmpzIiwiLi4vbW9kdWxlcy93ZWJydGMtbWVzc2FnaW5nL2luZGV4LmpzIiwiLi4vbW9kdWxlcy93ZWJydGMtdmlkZW8tY2hhdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYiBJbmRpY2F0b3IuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGFiIEluZGljYXRvciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGFiSW5kaWNhdG9yQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzc05hbWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCByZWN0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBjb250ZW50IGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldENvbnRlbnRTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiSW5kaWNhdG9yQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy10YWItaW5kaWNhdG9yLS1hY3RpdmUnLFxuICBGQURFOiAnbWRjLXRhYi1pbmRpY2F0b3ItLWZhZGUnLFxuICBOT19UUkFOU0lUSU9OOiAnbWRjLXRhYi1pbmRpY2F0b3ItLW5vLXRyYW5zaXRpb24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWItaW5kaWNhdG9yX19jb250ZW50Jyxcbn07XG5cbmV4cG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RhYkluZGljYXRvckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiSW5kaWNhdG9yQWRhcHRlcj59XG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiSW5kaWNhdG9yQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJJbmRpY2F0b3JBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdDogKCkgPT4ge30sXG4gICAgICBzZXRDb250ZW50U3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGluZGljYXRvclxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqIEBhYnN0cmFjdCAqL1xuICBkZWFjdGl2YXRlKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGV4dGVuZHMgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiB7XG4gIC8qKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0ICovXG4gIGFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgbm8gaW5kaWNhdG9yIGlzIHByZXNlbnQgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIGFuIGluZGljYXRvclxuICAgIC8vIG1heSBiZSBhY3RpdmF0ZWQgd2l0aG91dCBhIHByaW9yIGluZGljYXRvciBzdGF0ZVxuICAgIGlmICghcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgYW5pbWF0aW9uIHVzZXMgdGhlIEZMSVAgYXBwcm9hY2guIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGl0IGF0IHRoZSBsaW5rIGJlbG93OlxuICAgIC8vIGh0dHBzOi8vYWVyb3R3aXN0LmNvbS9ibG9nL2ZsaXAteW91ci1hbmltYXRpb25zL1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcmV2aW91cyBpbmRpY2F0b3JcbiAgICBjb25zdCBjdXJyZW50Q2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgd2lkdGhEZWx0YSA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC53aWR0aCAvIGN1cnJlbnRDbGllbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IHhQb3NpdGlvbiA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC5sZWZ0IC0gY3VycmVudENsaWVudFJlY3QubGVmdDtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5OT19UUkFOU0lUSU9OKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgke3hQb3NpdGlvbn1weCkgc2NhbGVYKCR7d2lkdGhEZWx0YX0pYCk7XG5cbiAgICAvLyBGb3JjZSByZXBhaW50IGJlZm9yZSB1cGRhdGluZyBjbGFzc2VzIGFuZCB0cmFuc2Zvcm0gdG8gZW5zdXJlIHRoZSB0cmFuc2Zvcm0gcHJvcGVybHkgdGFrZXMgZWZmZWN0XG4gICAgdGhpcy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLk5PX1RSQU5TSVRJT04pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJycpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYkluZGljYXRvckZvdW5kYXRpb259XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24ge1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuaW1wb3J0IE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vc2xpZGluZy1mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGYWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZmFkaW5nLWZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYkluZGljYXRvciBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENUYWJJbmRpY2F0b3J9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiSW5kaWNhdG9yKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAdHlwZSB7P0VsZW1lbnR9ICovXG4gICAgdGhpcy5jb250ZW50XztcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5jb250ZW50XyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLnN0cmluZ3MuQ09OVEVOVF9TRUxFQ1RPUik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQ29udGVudENsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkluZGljYXRvckZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gLyoqIEB0eXBlIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gKi8gKE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB0aGlzLmNvbnRlbnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgc2V0Q29udGVudFN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT4gdGhpcy5jb250ZW50Xy5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSksXG4gICAgfSkpO1xuXG4gICAgaWYgKHRoaXMucm9vdF8uY2xhc3NMaXN0LmNvbnRhaW5zKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GQURFKSkge1xuICAgICAgcmV0dXJuIG5ldyBNRENGYWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uKGFkYXB0ZXIpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gdGhlIHNsaWRpbmcgaW5kaWNhdG9yXG4gICAgcmV0dXJuIG5ldyBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7TURDVGFiSW5kaWNhdG9yLCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLCBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiwgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogTURDVGFiRGltZW5zaW9ucyBwcm92aWRlcyBkZXRhaWxzIGFib3V0IHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlcyBvZiB0aGUgVGFiXG4gKiByb290IGVsZW1lbnQgYW5kIHRoZSBUYWIgY29udGVudCBlbGVtZW50LiBUaGVzZSB2YWx1ZXMgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBUYWIgd2l0aCByZXNwZWN0IGl0J3MgcGFyZW50IGNvbnRhaW5lci5cbiAqIEB0eXBlZGVmIHt7cm9vdExlZnQ6IG51bWJlciwgcm9vdFJpZ2h0OiBudW1iZXIsIGNvbnRlbnRMZWZ0OiBudW1iZXIsIGNvbnRlbnRSaWdodDogbnVtYmVyfX1cbiAqL1xubGV0IE1EQ1RhYkRpbWVuc2lvbnM7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYi5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gYWRkXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzTmFtZSBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb290IGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0ck5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBzbyBnaXZlIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgaW5kaWNhdG9yIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QgVGhlIGNsaWVudCByZWN0IG9mIHRoZSBwcmV2aW91c2x5IGFjdGl2YXRlZCBpbmRpY2F0b3JcbiAgICovXG4gIGFjdGl2YXRlSW5kaWNhdG9yKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge31cblxuICAvKiogRGVhY3RpdmF0ZXMgdGhlIGluZGljYXRvci4gKi9cbiAgZGVhY3RpdmF0ZUluZGljYXRvcigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBNRENUYWI6aW50ZXJhY3RlZCBldmVudCBmb3IgdXNlIGJ5IHBhcmVudCBjb21wb25lbnRzXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGVkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0TGVmdCB2YWx1ZSBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggdmFsdWUgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXRMZWZ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbnRlbnRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggb2YgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q29udGVudE9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogQXBwbGllcyBmb2N1cyB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAqL1xuICBmb2N1cygpIHt9XG59XG5cbmV4cG9ydCB7TURDVGFiRGltZW5zaW9ucywgTURDVGFiQWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBQ1RJVkU6ICdtZGMtdGFiLS1hY3RpdmUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX1NFTEVDVEVEOiAnYXJpYS1zZWxlY3RlZCcsXG4gIFJJUFBMRV9TRUxFQ1RPUjogJy5tZGMtdGFiX19yaXBwbGUnLFxuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWJfX2NvbnRlbnQnLFxuICBUQUJfSU5ESUNBVE9SX1NFTEVDVE9SOiAnLm1kYy10YWItaW5kaWNhdG9yJyxcbiAgVEFCSU5ERVg6ICd0YWJJbmRleCcsXG4gIElOVEVSQUNURURfRVZFTlQ6ICdNRENUYWI6aW50ZXJhY3RlZCcsXG59O1xuXG5leHBvcnQge1xuICBjc3NDbGFzc2VzLFxuICBzdHJpbmdzLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiQWRhcHRlciwgTURDVGFiRGltZW5zaW9uc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuaW1wb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICBhY3RpdmF0ZUluZGljYXRvcjogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5kaWNhdG9yOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUludGVyYWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRDb250ZW50T2Zmc2V0TGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZm9jdXM6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYkFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVDbGlja18gPSAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgXCJjbGlja1wiIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGFjdGl2ZSBUYWIgYW5kXG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IGFjdGl2YXRlIGEgVGFiIHRoYXQncyBhbHJlYWR5IGFjdGl2ZS5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUludGVyYWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUYWIncyBhY3RpdmUgc3RhdGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRhYlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX1NFTEVDVEVELCAndHJ1ZScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLlRBQklOREVYLCAnMCcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVJbmRpY2F0b3IocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIFRhYlxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICAvLyBFYXJseSBleGl0XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX1NFTEVDVEVELCAnZmFsc2UnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5UQUJJTkRFWCwgJy0xJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5kaWNhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgVGFiXG4gICAqIEByZXR1cm4geyFNRENUYWJEaW1lbnNpb25zfVxuICAgKi9cbiAgY29tcHV0ZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qgcm9vdFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRMZWZ0KCk7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCBjb250ZW50TGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29udGVudE9mZnNldExlZnQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICByb290TGVmdCxcbiAgICAgIHJvb3RSaWdodDogcm9vdExlZnQgKyByb290V2lkdGgsXG4gICAgICBjb250ZW50TGVmdDogcm9vdExlZnQgKyBjb250ZW50TGVmdCxcbiAgICAgIGNvbnRlbnRSaWdodDogcm9vdExlZnQgKyBjb250ZW50TGVmdCArIGNvbnRlbnRXaWR0aCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENSaXBwbGUsIE1EQ1JpcHBsZUZvdW5kYXRpb24sIFJpcHBsZUNhcGFibGVTdXJmYWNlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4JztcbmltcG9ydCB7TURDVGFiSW5kaWNhdG9yLCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvdGFiLWluZGljYXRvci9pbmRleCc7XG5pbXBvcnQge01EQ1RhYkFkYXB0ZXIsIE1EQ1RhYkRpbWVuc2lvbnN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCBNRENUYWJGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDVGFiRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAcHJpdmF0ZSB7P01EQ1JpcHBsZX0gKi9cbiAgICB0aGlzLnJpcHBsZV87XG4gICAgLyoqIEBwcml2YXRlIHs/TURDVGFiSW5kaWNhdG9yfSAqL1xuICAgIHRoaXMudGFiSW5kaWNhdG9yXztcbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuY29udGVudF87XG5cbiAgICAvKiogQHByaXZhdGUgez9GdW5jdGlvbn0gKi9cbiAgICB0aGlzLmhhbmRsZUNsaWNrXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENUYWJ9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiKHJvb3QpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShcbiAgICByaXBwbGVGYWN0b3J5ID0gKGVsLCBmb3VuZGF0aW9uKSA9PiBuZXcgTURDUmlwcGxlKGVsLCBmb3VuZGF0aW9uKSxcbiAgICB0YWJJbmRpY2F0b3JGYWN0b3J5ID0gKGVsKSA9PiBuZXcgTURDVGFiSW5kaWNhdG9yKGVsKSkge1xuICAgIGNvbnN0IHJpcHBsZVN1cmZhY2UgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlJJUFBMRV9TRUxFQ1RPUik7XG4gICAgY29uc3QgcmlwcGxlQWRhcHRlciA9IE9iamVjdC5hc3NpZ24oTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIoLyoqIEB0eXBlIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9ICovICh0aGlzKSksIHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiByaXBwbGVTdXJmYWNlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiByaXBwbGVTdXJmYWNlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IHJpcHBsZVN1cmZhY2Uuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IHJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihyaXBwbGVBZGFwdGVyKTtcbiAgICB0aGlzLnJpcHBsZV8gPSByaXBwbGVGYWN0b3J5KHRoaXMucm9vdF8sIHJpcHBsZUZvdW5kYXRpb24pO1xuXG4gICAgY29uc3QgdGFiSW5kaWNhdG9yRWxlbWVudCA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX0lORElDQVRPUl9TRUxFQ1RPUik7XG4gICAgdGhpcy50YWJJbmRpY2F0b3JfID0gdGFiSW5kaWNhdG9yRmFjdG9yeSh0YWJJbmRpY2F0b3JFbGVtZW50KTtcblxuICAgIHRoaXMuY29udGVudF8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMuaGFuZGxlQ2xpY2tfID0gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVDbGljay5iaW5kKHRoaXMuZm91bmRhdGlvbl8pO1xuICAgIHRoaXMubGlzdGVuKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bmxpc3RlbignY2xpY2snLCAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKHRoaXMuaGFuZGxlQ2xpY2tfKSk7XG4gICAgdGhpcy5yaXBwbGVfLmRlc3Ryb3koKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYkZvdW5kYXRpb24oXG4gICAgICAvKiogQHR5cGUgeyFNRENUYWJBZGFwdGVyfSAqLyAoe1xuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHRoaXMucm9vdF8uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcbiAgICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgICBhY3RpdmF0ZUluZGljYXRvcjogKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkgPT4gdGhpcy50YWJJbmRpY2F0b3JfLmFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCksXG4gICAgICAgIGRlYWN0aXZhdGVJbmRpY2F0b3I6ICgpID0+IHRoaXMudGFiSW5kaWNhdG9yXy5kZWFjdGl2YXRlKCksXG4gICAgICAgIG5vdGlmeUludGVyYWN0ZWQ6ICgpID0+IHRoaXMuZW1pdChNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RFRF9FVkVOVCwge3RhYjogdGhpc30sIHRydWUgLyogYnViYmxlICovKSxcbiAgICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRMZWZ0LFxuICAgICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRXaWR0aCxcbiAgICAgICAgZ2V0Q29udGVudE9mZnNldExlZnQ6ICgpID0+IHRoaXMuY29udGVudF8ub2Zmc2V0TGVmdCxcbiAgICAgICAgZ2V0Q29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLmNvbnRlbnRfLm9mZnNldFdpZHRoLFxuICAgICAgICBmb2N1czogKCkgPT4gdGhpcy5yb290Xy5mb2N1cygpLFxuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgdGFiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmlzQWN0aXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWJcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdD19IGNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGUoY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSB0YWJcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kaWNhdG9yJ3MgY2xpZW50IHJlY3RcbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJJbmRpY2F0b3JfLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJEaW1lbnNpb25zfVxuICAgKi9cbiAgY29tcHV0ZURpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uY29tcHV0ZURpbWVuc2lvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSB0YWJcbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMucm9vdF8uZm9jdXMoKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYiwgTURDVGFiRm91bmRhdGlvbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogTURDVGFiU2Nyb2xsZXJBbmltYXRpb24gY29udGFpbnMgdGhlIHZhbHVlcyByZXF1aXJlZCBmb3IgYW5pbWF0aW5nIGZyb20gdGhlXG4gKiBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvbi4gVGhlIFwiZmluYWxTY3JvbGxQb3NpdGlvblwiXG4gKiB2YWx1ZSByZXByZXNlbnRzIHRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uIHdoaWxlIHRoZSBcInNjcm9sbERlbHRhXCIgdmFsdWUgaXMgdGhlXG4gKiBjb3JyZXNwb25kaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgc2Nyb2xsIGNvbnRlbnQuIFRvZ2V0aGVyLFxuICogdGhleSBjcmVhdGUgdGhlIGFuaW1hdGlvbiBieSBmaXJzdCB1cGRhdGluZyB0aGUgc2Nyb2xsIHZhbHVlIHRoZW4gYXBwbHlpbmdcbiAqIHRoZSB0cmFuc2Zvcm1hdGlvbiBhbmQgYW5pbWF0aW5nIHRoZSB0cmFuc2l0aW9uLiBCb3RoIHBpZWNlcyBhcmUgbmVjZXNzYXJ5XG4gKiBmb3IgdGhlIHNjcm9sbCBhbmltYXRpb24gdG8gd29yay4gVGhlIHZhbHVlcyBhcmUgdXNlZCBhcy1pcyBieSB0aGUgdGFiXG4gKiBzY3JvbGxlciBhbmltYXRpb24gbWV0aG9kLCBlbnN1cmluZyB0aGF0IGFsbCBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgc2Nyb2xsXG4gKiBwb3NpdGlvbiBvciB0cmFuc2Zvcm1hdGlvbiBpcyBhYnN0cmFjdGVkIGF3YXkgZnJvbSB0aGUgYW5pbWF0aW9uIG1ldGhvZC5cbiAqIEB0eXBlZGVmIHt7ZmluYWxTY3JvbGxQb3NpdGlvbjogbnVtYmVyLCBzY3JvbGxEZWx0YTogbnVtYmVyfX1cbiAqL1xubGV0IE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uO1xuXG4vKipcbiAqIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzIHJlcHJlc2VudHMgdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzIG9mIHRoZVxuICogc2Nyb2xsIGNvbnRlbnQuIFRoZXNlIHZhbHVlcyB2YXJ5IGRlcGVuZGluZyBvbiBob3cgc2Nyb2xsaW5nIGluIFJUTCBpc1xuICogaW1wbGVtZW50ZWQgYnkgdGhlIGJyb3dzZXIuIE9uZSB2YWx1ZSBpcyBhbHdheXMgMCBhbmQgb25lIHZhbHVlIGlzIGFsd2F5c1xuICogdGhlIG1heCBzY3JvbGxhYmxlIHZhbHVlIGFzIGVpdGhlciBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIuXG4gKiBAdHlwZWRlZiB7e2xlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcztcblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGFiIFNjcm9sbGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRhYiAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzc05hbWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkU2Nyb2xsQXJlYUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyBnaXZlbiBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2dFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yKGV2dFRhcmdldCwgc2VsZWN0b3IpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgYXJlYSBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBUaGUgc3R5bGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHkocHJvcE5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Nyb2xsIGNvbnRlbnQgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlIG9mIHRoZSBnaXZlbiBjc3MgcHJvcGVydHkgYHByb3BlcnR5TmFtZWAuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGdldENvbXB1dGVkU3R5bGUoLi4uKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKHByb3BlcnR5TmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2Nyb2xsTGVmdCB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsTGVmdCBUaGUgbmV3IHNjcm9sbExlZnQgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KHNjcm9sbExlZnQpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpdGR0aCBvZiB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBicm93c2VyJ3MgaG9yaXpvbnRhbCBzY3JvbGxiYXJzIChpbiBweCkuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0KCkge31cbn1cblxuZXhwb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXMsIE1EQ1RhYlNjcm9sbGVyQWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBTklNQVRJTkc6ICdtZGMtdGFiLXNjcm9sbGVyLS1hbmltYXRpbmcnLFxuICBTQ1JPTExfVEVTVDogJ21kYy10YWItc2Nyb2xsZXJfX3Rlc3QnLFxuICBTQ1JPTExfQVJFQV9TQ1JPTEw6ICdtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYS0tc2Nyb2xsJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJFQV9TRUxFQ1RPUjogJy5tZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYScsXG4gIENPTlRFTlRfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnQnLFxufTtcblxuZXhwb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQWRhcHRlciwgTURDVGFiU2Nyb2xsZXJBbmltYXRpb259IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIGN1cnJlbnQgc2Nyb2xsWCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNsYXRlWCBUaGUgY3VycmVudCB0cmFuc2xhdGVYIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVEwgZnJvbSAnLi9ydGwtc2Nyb2xsZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYlNjcm9sbGVyUlRMfVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IHtyaWdodH0gPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIC8vIFNjcm9sbCB2YWx1ZXMgb24gbW9zdCBicm93c2VycyBhcmUgaW50cyBpbnN0ZWFkIG9mIGZsb2F0cyBzbyB3ZSByb3VuZFxuICAgIHJldHVybiBNYXRoLnJvdW5kKHJpZ2h0IC0gY3VycmVudFNjcm9sbExlZnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGVkZ2VzLnJpZ2h0IC0gc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCkge1xuICAgIHJldHVybiBzY3JvbGxYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBjb250ZW50V2lkdGggLSByb290V2lkdGgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMubGVmdCwgc2Nyb2xsWCksIGVkZ2VzLnJpZ2h0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJTY3JvbGxlclJUTH1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlIGV4dGVuZHMgTURDVGFiU2Nyb2xsZXJSVEwge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvblJUTCh0cmFuc2xhdGVYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodHJhbnNsYXRlWCAtIGN1cnJlbnRTY3JvbGxMZWZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKC1zY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjbGFtcGVkU2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIGluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGN1cnJlbnRTY3JvbGxMZWZ0IC0gc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNsYXRlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7XG4gICAgcmV0dXJuIHNjcm9sbFggLSB0cmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogcm9vdFdpZHRoIC0gY29udGVudFdpZHRoLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZWRnZXMucmlnaHQsIHNjcm9sbFgpLCBlZGdlcy5sZWZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDVGFiU2Nyb2xsZXJSVEx9XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIGV4dGVuZHMgTURDVGFiU2Nyb2xsZXJSVEwge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIC8vIFNjcm9sbCB2YWx1ZXMgb24gbW9zdCBicm93c2VycyBhcmUgaW50cyBpbnN0ZWFkIG9mIGZsb2F0cyBzbyB3ZSByb3VuZFxuICAgIHJldHVybiBNYXRoLnJvdW5kKGN1cnJlbnRTY3JvbGxMZWZ0IC0gdHJhbnNsYXRlWCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgc2Nyb2xsVG9SVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjdXJyZW50U2Nyb2xsTGVmdCAtIGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIGluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGN1cnJlbnRTY3JvbGxMZWZ0ICsgc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY3VycmVudFNjcm9sbExlZnQgLSBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7XG4gICAgcmV0dXJuIHNjcm9sbFggKyB0cmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogY29udGVudFdpZHRoIC0gcm9vdFdpZHRoLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMucmlnaHQsIHNjcm9sbFgpLCBlZGdlcy5sZWZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTFJldmVyc2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcywgTURDVGFiU2Nyb2xsZXJBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQgZnJvbSAnLi9ydGwtZGVmYXVsdC1zY3JvbGxlcic7XG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZSBmcm9tICcuL3J0bC1uZWdhdGl2ZS1zY3JvbGxlcic7XG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIGZyb20gJy4vcnRsLXJldmVyc2Utc2Nyb2xsZXInO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJTY3JvbGxlckFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiU2Nyb2xsZXJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yOiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGFkZFNjcm9sbEFyZWFDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxBcmVhU3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdDogKCkgPT4ge30sXG4gICAgICBjb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3Q6ICgpID0+IHt9LFxuICAgICAgY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYm9vbGVhbiBjb250cm9scyB3aGV0aGVyIHdlIHNob3VsZCBoYW5kbGUgdGhlIHRyYW5zaXRpb25lbmQgYW5kIGludGVyYWN0aW9uIGV2ZW50cyBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQW5pbWF0aW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIE1EQ1RhYlNjcm9sbGVyUlRMIGluc3RhbmNlIHZhcmllcyBwZXIgYnJvd3NlciBhbmQgYWxsb3dzIHVzIHRvIGVuY2Fwc3VsYXRlIHRoZSBwZWN1bGlhciBicm93c2VyIGJlaGF2aW9yXG4gICAgICogb2YgUlRMIHNjcm9sbGluZyBpbiBpdCdzIG93biBjbGFzcy5cbiAgICAgKiBAcHJpdmF0ZSB7P01EQ1RhYlNjcm9sbGVyUlRMfVxuICAgICAqL1xuICAgIHRoaXMucnRsU2Nyb2xsZXJJbnN0YW5jZV87XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIENvbXB1dGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGVpZ2h0IG9uIHNjcm9sbGVyIHdpdGggb3ZlcmZsb3cgaW5pdGlhbGx5IGhpZGRlbiwgdGhlbiB1cGRhdGUgb3ZlcmZsb3cgdG8gc2Nyb2xsXG4gICAgLy8gYW5kIGltbWVkaWF0ZWx5IGFkanVzdCBib3R0b20gbWFyZ2luIHRvIGF2b2lkIHRoZSBzY3JvbGxiYXIgaW5pdGlhbGx5IGFwcGVhcmluZyBiZWZvcmUgSlMgcnVucy5cbiAgICBjb25zdCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nLCAtaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCArICdweCcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkU2Nyb2xsQXJlYUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlNDUk9MTF9BUkVBX1NDUk9MTCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGN1cnJlbnQgdmlzdWFsIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUN1cnJlbnRTY3JvbGxQb3NpdGlvblJUTF8oKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VHJhbnNsYXRlWCA9IHRoaXMuY2FsY3VsYXRlQ3VycmVudFRyYW5zbGF0ZVhfKCk7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICByZXR1cm4gc2Nyb2xsTGVmdCAtIGN1cnJlbnRUcmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW50ZXJhY3Rpb24gZXZlbnRzIHRoYXQgb2NjdXIgZHVyaW5nIHRyYW5zaXRpb25cbiAgICovXG4gIGhhbmRsZUludGVyYWN0aW9uKCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgd2UgYXJlbid0IGFuaW1hdGluZ1xuICAgIGlmICghdGhpcy5pc0FuaW1hdGluZ18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IG90aGVyIGV2ZW50IGxpc3RlbmVycyBmcm9tIGhhbmRsaW5nIHRoaXMgZXZlbnRcbiAgICB0aGlzLnN0b3BTY3JvbGxBbmltYXRpb25fKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgd2UgYXJlbid0IGFuaW1hdGluZyBvciB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBhIGRpZmZlcmVudCBlbGVtZW50LlxuICAgIGlmICghdGhpcy5pc0FuaW1hdGluZ19cbiAgICAgIHx8ICF0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yKGV2dC50YXJnZXQsIE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBzY3JvbGwgdmFsdWUgYnkgdGhlIHNjcm9sbFhJbmNyZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhJbmNyZW1lbnQgVGhlIHZhbHVlIGJ5IHdoaWNoIHRvIGluY3JlbWVudCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCkge1xuICAgIC8vIEVhcmx5IGV4aXQgZm9yIG5vbi1vcGVyYXRpb25hbCBpbmNyZW1lbnQgdmFsdWVzXG4gICAgaWYgKHNjcm9sbFhJbmNyZW1lbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50U2Nyb2xsUlRMXyhzY3JvbGxYSW5jcmVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmluY3JlbWVudFNjcm9sbF8oc2Nyb2xsWEluY3JlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gc2Nyb2xsWCB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsWCkge1xuICAgIGlmICh0aGlzLmlzUlRMXygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxUb1JUTF8oc2Nyb2xsWCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxUb18oc2Nyb2xsWCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiB0aGUgTURDVGFiU2Nyb2xsZXJSVExcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyUlRMfVxuICAgKi9cbiAgZ2V0UlRMU2Nyb2xsZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfKSB7XG4gICAgICB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfID0gdGhpcy5ydGxTY3JvbGxlckZhY3RvcnlfKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucnRsU2Nyb2xsZXJJbnN0YW5jZV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRlWCB2YWx1ZSBmcm9tIGEgQ1NTIG1hdHJpeCB0cmFuc2Zvcm0gZnVuY3Rpb24gc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWUoJ3RyYW5zZm9ybScpO1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgbm8gdHJhbnNmb3JtIGlzIHByZXNlbnRcbiAgICBpZiAodHJhbnNmb3JtVmFsdWUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRyYW5zZm9ybSB2YWx1ZSBjb21lcyBiYWNrIGFzIGEgbWF0cml4IHRyYW5zZm9ybWF0aW9uIGluIHRoZSBmb3JtXG4gICAgLy8gb2YgYG1hdHJpeChhLCBiLCBjLCBkLCB0eCwgdHkpYC4gV2Ugb25seSBjYXJlIGFib3V0IHR4ICh0cmFuc2xhdGVYKSBzb1xuICAgIC8vIHdlJ3JlIGdvaW5nIHRvIGdyYWIgYWxsIHRoZSBwYXJlbnRoZXNpemVkIHZhbHVlcywgc3RyaXAgb3V0IHR4LCBhbmRcbiAgICAvLyBwYXJzZSBpdC5cbiAgICBjb25zdCByZXN1bHRzID0gL1xcKCguKylcXCkvLmV4ZWModHJhbnNmb3JtVmFsdWUpWzFdO1xuICAgIGNvbnN0IHBhcnRzID0gcmVzdWx0cy5zcGxpdCgnLCcpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnRzWzRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGEgc2FmZSBzY3JvbGwgdmFsdWUgdGhhdCBpcyA+IDAgYW5kIDwgdGhlIG1heCBzY3JvbGwgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIGRpc3RhbmNlIHRvIHNjcm9sbFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChlZGdlcy5sZWZ0LCBzY3JvbGxYKSwgZWRnZXMucmlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVDdXJyZW50U2Nyb2xsUG9zaXRpb25SVExfKCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIHJldHVybiB0aGlzLmdldFJUTFNjcm9sbGVyKCkuZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCkge1xuICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3Qgcm9vdFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGgoKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9ICovICh7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGNvbnRlbnRXaWR0aCAtIHJvb3RXaWR0aCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBzY3JvbGwgbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxUb18oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxYID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IHNhZmVTY3JvbGxYID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKTtcbiAgICBjb25zdCBzY3JvbGxEZWx0YSA9IHNhZmVTY3JvbGxYIC0gY3VycmVudFNjcm9sbFg7XG4gICAgdGhpcy5hbmltYXRlXygvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IHNhZmVTY3JvbGxYLFxuICAgICAgc2Nyb2xsRGVsdGE6IHNjcm9sbERlbHRhLFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSVEwgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsVG9SVExfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmdldFJUTFNjcm9sbGVyKCkuc2Nyb2xsVG9SVEwoc2Nyb2xsWCk7XG4gICAgdGhpcy5hbmltYXRlXyhhbmltYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGluY3JlbWVudCBzY3JvbGwgbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uIGluY3JlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbFggPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsWCA9IHNjcm9sbFggKyBjdXJyZW50U2Nyb2xsWDtcbiAgICBjb25zdCBzYWZlU2Nyb2xsWCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8odGFyZ2V0U2Nyb2xsWCk7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBzYWZlU2Nyb2xsWCAtIGN1cnJlbnRTY3JvbGxYO1xuICAgIHRoaXMuYW5pbWF0ZV8oLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBzYWZlU2Nyb2xsWCxcbiAgICAgIHNjcm9sbERlbHRhOiBzY3JvbGxEZWx0YSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgaW5jcmVtZW5ldCBzY3JvbGwgUlRMIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvbiBSVEwgaW5jcmVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVExfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmdldFJUTFNjcm9sbGVyKCkuaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpO1xuICAgIHRoaXMuYW5pbWF0ZV8oYW5pbWF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlcyB0aGUgdGFiIHNjcm9sbGluZ1xuICAgKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gdG8gYXBwbHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVfKGFuaW1hdGlvbikge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgdHJhbnNsYXRlWCBpcyAwLCB3aGljaCBtZWFucyB0aGVyZSdzIG5vIGFuaW1hdGlvbiB0byBwZXJmb3JtXG4gICAgaWYgKGFuaW1hdGlvbi5zY3JvbGxEZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcFNjcm9sbEFuaW1hdGlvbl8oKTtcbiAgICAvLyBUaGlzIGFuaW1hdGlvbiB1c2VzIHRoZSBGTElQIGFwcHJvYWNoLlxuICAgIC8vIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL2Flcm90d2lzdC5jb20vYmxvZy9mbGlwLXlvdXItYW5pbWF0aW9ucy9cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KGFuaW1hdGlvbi5maW5hbFNjcm9sbFBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgke2FuaW1hdGlvbi5zY3JvbGxEZWx0YX1weClgKTtcbiAgICAvLyBGb3JjZSByZXBhaW50XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3QoKTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCAnbm9uZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHNjcm9sbCBhbmltYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0b3BTY3JvbGxBbmltYXRpb25fKCkge1xuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gZmFsc2U7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVgoMHB4KScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoY3VycmVudFNjcm9sbFBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uXygpIHtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNsYXRlWCA9IHRoaXMuY2FsY3VsYXRlQ3VycmVudFRyYW5zbGF0ZVhfKCk7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UlRMU2Nyb2xsZXIoKS5nZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxMZWZ0LCBjdXJyZW50VHJhbnNsYXRlWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbExlZnQgLSBjdXJyZW50VHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBSVEwgU2Nyb2xsZXIgdG8gdXNlXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlclJUTH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ0bFNjcm9sbGVyRmFjdG9yeV8oKSB7XG4gICAgLy8gQnJvd3NlcnMgaGF2ZSB0aHJlZSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIG9mIHNjcm9sbExlZnQgaW4gUlRMIG1vZGUsXG4gICAgLy8gZGVwZW5kZW50IG9uIHRoZSBicm93c2VyLiBUaGUgYmVoYXZpb3IgaXMgYmFzZWQgb2ZmIHRoZSBtYXggTFRSXG4gICAgLy8gc2Nyb2xsbGVmdCB2YWx1ZSBhbmQgMC5cbiAgICAvL1xuICAgIC8vICogRGVmYXVsdCBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogMFxuICAgIC8vICAgIC0gUmlnaHQtbW9zdCB2YWx1ZTogTWF4IExUUiBzY3JvbGxMZWZ0IHZhbHVlXG4gICAgLy9cbiAgICAvLyAqIE5lZ2F0aXZlIHNjcm9sbGluZyBpbiBSVEwgKlxuICAgIC8vICAgIC0gTGVmdC1tb3N0IHZhbHVlOiBOZWdhdGVkIG1heCBMVFIgc2Nyb2xsTGVmdCB2YWx1ZVxuICAgIC8vICAgIC0gUmlnaHQtbW9zdCB2YWx1ZTogMFxuICAgIC8vXG4gICAgLy8gKiBSZXZlcnNlIHNjcm9sbGluZyBpbiBSVEwgKlxuICAgIC8vICAgIC0gTGVmdC1tb3N0IHZhbHVlOiBNYXggTFRSIHNjcm9sbExlZnQgdmFsdWVcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IDBcbiAgICAvL1xuICAgIC8vIFdlIHVzZSB0aG9zZSBwcmluY2lwbGVzIGJlbG93IHRvIGRldGVybWluZSB3aGljaCBSVEwgc2Nyb2xsTGVmdFxuICAgIC8vIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gICAgY29uc3QgaW5pdGlhbFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCAtIDEpO1xuICAgIGNvbnN0IG5ld1Njcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG5cbiAgICAvLyBJZiB0aGUgbmV3U2Nyb2xsTGVmdCB2YWx1ZSBpcyBuZWdhdGl2ZSx0aGVuIHdlIGtub3cgdGhhdCB0aGUgYnJvd3NlciBoYXNcbiAgICAvLyBpbXBsZW1lbnRlZCBuZWdhdGl2ZSBSVEwgc2Nyb2xsaW5nLCBzaW5jZSBhbGwgb3RoZXIgaW1wbGVtZW50YXRpb25zIGhhdmVcbiAgICAvLyBvbmx5IHBvc2l0aXZlIHZhbHVlcy5cbiAgICBpZiAobmV3U2Nyb2xsTGVmdCA8IDApIHtcbiAgICAgIC8vIFVuZG8gdGhlIHNjcm9sbExlZnQgdGVzdCBjaGVja1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCk7XG4gICAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMTmVnYXRpdmUodGhpcy5hZGFwdGVyXyk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdENsaWVudFJlY3QgPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvbnRlbnRDbGllbnRSZWN0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3QoKTtcbiAgICBjb25zdCByaWdodEVkZ2VEZWx0YSA9IE1hdGgucm91bmQoY29udGVudENsaWVudFJlY3QucmlnaHQgLSByb290Q2xpZW50UmVjdC5yaWdodCk7XG4gICAgLy8gVW5kbyB0aGUgc2Nyb2xsTGVmdCB0ZXN0IGNoZWNrXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCk7XG5cbiAgICAvLyBCeSBjYWxjdWxhdGluZyB0aGUgY2xpZW50UmVjdCBvZiB0aGUgcm9vdCBlbGVtZW50IGFuZCB0aGUgY2xpZW50UmVjdCBvZlxuICAgIC8vIHRoZSBjb250ZW50IGVsZW1lbnQsIHdlIGNhbiBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIHNjcm9sbCB2YWx1ZSBjaGFuZ2VkXG4gICAgLy8gd2hlbiB3ZSBwZXJmb3JtZWQgdGhlIHNjcm9sbExlZnQgc3VidHJhY3Rpb24gYWJvdmUuXG4gICAgaWYgKHJpZ2h0RWRnZURlbHRhID09PSBuZXdTY3JvbGxMZWZ0KSB7XG4gICAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSh0aGlzLmFkYXB0ZXJfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCh0aGlzLmFkYXB0ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNSVExfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZy5cbiAqIEBwcml2YXRlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5sZXQgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF87XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhlaWdodCBvZiBicm93c2VyLXJlbmRlcmVkIGhvcml6b250YWwgc2Nyb2xsYmFycyB1c2luZyBhIHNlbGYtY3JlYXRlZCB0ZXN0IGVsZW1lbnQuXG4gKiBNYXkgcmV0dXJuIDAgKGUuZy4gb24gT1MgWCBicm93c2VycyB1bmRlciBkZWZhdWx0IGNvbmZpZ3VyYXRpb24pLlxuICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRDYWNoZVJlc3VsdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodChkb2N1bWVudE9iaiwgc2hvdWxkQ2FjaGVSZXN1bHQgPSB0cnVlKSB7XG4gIGlmIChzaG91bGRDYWNoZVJlc3VsdCAmJiB0eXBlb2YgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfO1xuICB9XG5cbiAgY29uc3QgZWwgPSBkb2N1bWVudE9iai5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNDUk9MTF9URVNUKTtcbiAgZG9jdW1lbnRPYmouYm9keS5hcHBlbmRDaGlsZChlbCk7XG5cbiAgY29uc3QgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgZG9jdW1lbnRPYmouYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cbiAgaWYgKHNob3VsZENhY2hlUmVzdWx0KSB7XG4gICAgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF8gPSBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0O1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gSFRNTEVsZW1lbnRQcm90b3R5cGVcbiAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnRQcm90b3R5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuZXhwb3J0IHtjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCwgZ2V0TWF0Y2hlc1Byb3BlcnR5fTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXIgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJ9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiU2Nyb2xsZXIocm9vdCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuY29udGVudF87XG5cbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuYXJlYV87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXztcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5hcmVhXyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uc3RyaW5ncy5BUkVBX1NFTEVDVE9SKTtcbiAgICB0aGlzLmNvbnRlbnRfID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fID0gKCkgPT4gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8gPSAoZXZ0KSA9PiB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KTtcblxuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuY29udGVudF8uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmNvbnRlbnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yOiAoZXZ0VGFyZ2V0LCBzZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGV2dFRhcmdldFtNQVRDSEVTXShzZWxlY3Rvcik7XG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgYWRkU2Nyb2xsQXJlYUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLmFyZWFfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5OiAocHJvcCwgdmFsdWUpID0+IHRoaXMuYXJlYV8uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsdWUpLFxuICAgICAgc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT4gdGhpcy5jb250ZW50Xy5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSksXG4gICAgICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZTogKHByb3BOYW1lKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNvbnRlbnRfKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKSxcbiAgICAgIHNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0OiAoc2Nyb2xsWCkgPT4gdGhpcy5hcmVhXy5zY3JvbGxMZWZ0ID0gc2Nyb2xsWCxcbiAgICAgIGdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0OiAoKSA9PiB0aGlzLmFyZWFfLnNjcm9sbExlZnQsXG4gICAgICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuY29udGVudF8ub2Zmc2V0V2lkdGgsXG4gICAgICBnZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuYXJlYV8ub2Zmc2V0V2lkdGgsXG4gICAgICBjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3Q6ICgpID0+IHRoaXMuYXJlYV8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3Q6ICgpID0+IHRoaXMuY29udGVudF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDogKCkgPT4gdXRpbC5jb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodChkb2N1bWVudCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZpc3VhbCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsQ29udGVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRfLm9mZnNldFdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIHNjcm9sbCB2YWx1ZSBieSB0aGUgZ2l2ZW4gYW1vdW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYSW5jcmVtZW50IFRoZSBwaXhlbCB2YWx1ZSBieSB3aGljaCB0byBpbmNyZW1lbnQgdGhlIHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgcGl4ZWwgdmFsdWUgdG8gc2Nyb2xsIHRvXG4gICAqL1xuICBzY3JvbGxUbyhzY3JvbGxYKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zY3JvbGxUbyhzY3JvbGxYKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYlNjcm9sbGVyLCBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24sIHV0aWx9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJEaW1lbnNpb25zfSBmcm9tICdAbWF0ZXJpYWwvdGFiL2FkYXB0ZXInO1xuaW1wb3J0IHtNRENUYWJ9IGZyb20gJ0BtYXRlcmlhbC90YWIvaW5kZXgnO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUYWIgQmFyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRhYiBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RhYkJhckFkYXB0ZXIge1xuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIHBvc2l0aW9uIHRvIHNjcm9sbCB0b1xuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsWCkge31cblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gYnkgdGhlIGdpdmVuIGFtb3VudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWEluY3JlbWVudCBUaGUgYW1vdW50IHRvIGluY3JlbWVudCBzY3JvbGxcbiAgICovXG4gIGluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGwgY29udGVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IGVsZW1lbnQncyBvZmZzZXRXaWR0aFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIFRhYiBCYXIgbGFuZ3VhZ2UgZGlyZWN0aW9uIGlzIFJUTFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gYWN0aXZhdGVcbiAgICovXG4gIHNldEFjdGl2ZVRhYihpbmRleCkge31cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggdGhlIGdpdmVuIGNsaWVudCByZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBhY3RpdmF0ZVxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0fSBjbGllbnRSZWN0IFRoZSBjbGllbnQgcmVjdCBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmUgVGFiIEluZGljYXRvclxuICAgKi9cbiAgYWN0aXZhdGVUYWJBdEluZGV4KGluZGV4LCBjbGllbnRSZWN0KSB7fVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gZGVhY3RpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZVRhYkF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIGZvY3VzXG4gICAqL1xuICBmb2N1c1RhYkF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCByZWN0IG9mIHRoZSB0YWIncyBpbmRpY2F0b3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYiBkaW1lbnNpb25zIG9mIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcmV0dXJuIHshTURDVGFiRGltZW5zaW9uc31cbiAgICovXG4gIGdldFRhYkRpbWVuc2lvbnNBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHRhYiBsaXN0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFRhYkxpc3RMZW5ndGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmUgdGFiXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm9jdXNlZCB0YWJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Rm9jdXNlZFRhYkluZGV4KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJ9IHRhYiBUaGUgdGFiIHdob3NlIGluZGV4IHRvIGRldGVybWluXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEluZGV4T2ZUYWIodGFiKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgTURDVGFiQmFyOmFjdGl2YXRlZCBldmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBhY3RpdmF0ZWQgdGFiXG4gICAqL1xuICBub3RpZnlUYWJBY3RpdmF0ZWQoaW5kZXgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkJhckFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBUQUJfQUNUSVZBVEVEX0VWRU5UOiAnTURDVGFiQmFyOmFjdGl2YXRlZCcsXG4gIFRBQl9TQ1JPTExFUl9TRUxFQ1RPUjogJy5tZGMtdGFiLXNjcm9sbGVyJyxcbiAgVEFCX1NFTEVDVE9SOiAnLm1kYy10YWInLFxuICBBUlJPV19MRUZUX0tFWTogJ0Fycm93TGVmdCcsXG4gIEFSUk9XX1JJR0hUX0tFWTogJ0Fycm93UmlnaHQnLFxuICBFTkRfS0VZOiAnRW5kJyxcbiAgSE9NRV9LRVk6ICdIb21lJyxcbiAgRU5URVJfS0VZOiAnRW50ZXInLFxuICBTUEFDRV9LRVk6ICdTcGFjZScsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEVYVFJBX1NDUk9MTF9BTU9VTlQ6IDIwLFxuICBBUlJPV19MRUZUX0tFWUNPREU6IDM3LFxuICBBUlJPV19SSUdIVF9LRVlDT0RFOiAzOSxcbiAgRU5EX0tFWUNPREU6IDM1LFxuICBIT01FX0tFWUNPREU6IDM2LFxuICBFTlRFUl9LRVlDT0RFOiAxMyxcbiAgU1BBQ0VfS0VZQ09ERTogMzIsXG59O1xuXG5leHBvcnQge1xuICBudW1iZXJzLFxuICBzdHJpbmdzLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuaW1wb3J0IHtzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgTURDVGFiQmFyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJEaW1lbnNpb25zfSBmcm9tICdAbWF0ZXJpYWwvdGFiL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuY29uc3QgQUNDRVBUQUJMRV9LRVlTID0gbmV3IFNldCgpO1xuLy8gSUUxMSBoYXMgbm8gc3VwcG9ydCBmb3IgbmV3IFNldCB3aXRoIGl0ZXJhYmxlIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGlzIGJ5IGhhbmRcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5BUlJPV19MRUZUX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuQVJST1dfUklHSFRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5FTkRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5IT01FX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuRU5URVJfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8bnVtYmVyLCBzdHJpbmc+fVxuICovXG5jb25zdCBLRVlDT0RFX01BUCA9IG5ldyBNYXAoKTtcbi8vIElFMTEgaGFzIG5vIHN1cHBvcnQgZm9yIG5ldyBNYXAgd2l0aCBpdGVyYWJsZSBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgdGhpcyBieSBoYW5kXG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5BUlJPV19MRUZUX0tFWUNPREUsIHN0cmluZ3MuQVJST1dfTEVGVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuQVJST1dfUklHSFRfS0VZQ09ERSwgc3RyaW5ncy5BUlJPV19SSUdIVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5EX0tFWUNPREUsIHN0cmluZ3MuRU5EX0tFWSk7XG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5IT01FX0tFWUNPREUsIHN0cmluZ3MuSE9NRV9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5URVJfS0VZQ09ERSwgc3RyaW5ncy5FTlRFUl9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuU1BBQ0VfS0VZQ09ERSwgc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJCYXJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJCYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJCYXJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkJhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgc2Nyb2xsVG86ICgpID0+IHt9LFxuICAgICAgaW5jcmVtZW50U2Nyb2xsOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbENvbnRlbnRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBpc1JUTDogKCkgPT4ge30sXG4gICAgICBzZXRBY3RpdmVUYWI6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGZvY3VzVGFiQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRUYWJJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleE9mVGFiOiAoKSA9PiB7fSxcbiAgICAgIGdldFRhYkxpc3RMZW5ndGg6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5VGFiQWN0aXZhdGVkOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUYWJCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkJhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBhdXRvbWF0aWMgYW5kIG1hbnVhbCBhY3RpdmF0aW9uIG1vZGVzLlxuICAgKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy8jdGFicGFuZWwgZm9yIGV4YW1wbGVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUF1dG9tYXRpY0FjdGl2YXRpb25cbiAgICovXG4gIHNldFVzZUF1dG9tYXRpY0FjdGl2YXRpb24odXNlQXV0b21hdGljQWN0aXZhdGlvbikge1xuICAgIHRoaXMudXNlQXV0b21hdGljQWN0aXZhdGlvbl8gPSB1c2VBdXRvbWF0aWNBY3RpdmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGFjdGl2YXRlVGFiKGluZGV4KSB7XG4gICAgY29uc3QgcHJldmlvdXNBY3RpdmVJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCgpO1xuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8oaW5kZXgpIHx8IGluZGV4ID09PSBwcmV2aW91c0FjdGl2ZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlVGFiQXRJbmRleChwcmV2aW91c0FjdGl2ZUluZGV4KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlVGFiQXRJbmRleChpbmRleCwgdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleChwcmV2aW91c0FjdGl2ZUluZGV4KSk7XG4gICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVRhYkFjdGl2YXRlZChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUga2V5ZG93biBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVLZXlEb3duKGV2dCkge1xuICAgIC8vIEdldCB0aGUga2V5IGZyb20gdGhlIGV2ZW50XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXlGcm9tRXZlbnRfKGV2dCk7XG5cbiAgICAvLyBFYXJseSBleGl0IGlmIHRoZSBldmVudCBrZXkgaXNuJ3Qgb25lIG9mIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uIGtleXNcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IgZm9yIG1vdmVtZW50IGtleXMsIGJ1dCBub3QgZm9yIGFjdGl2YXRpb24ga2V5cywgc2luY2UgOmFjdGl2ZSBpcyB1c2VkIHRvIGFwcGx5IHJpcHBsZVxuICAgIGlmICghdGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8odGhpcy5hZGFwdGVyXy5nZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4KCksIGtleSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGl2ZVRhYihpbmRleCk7XG4gICAgICB0aGlzLnNjcm9sbEludG9WaWV3KGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm9jdXNlZFRhYkluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2VkVGFiSW5kZXgoKTtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZhdGlvbktleV8oa2V5KSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGl2ZVRhYihmb2N1c2VkVGFiSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRldGVybWluZVRhcmdldEZyb21LZXlfKGZvY3VzZWRUYWJJbmRleCwga2V5KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c1RhYkF0SW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3KGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgTURDVGFiOmludGVyYWN0ZWQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVGFiSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIodGhpcy5hZGFwdGVyXy5nZXRJbmRleE9mVGFiKGV2dC5kZXRhaWwudGFiKSk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0YWIgaW5kZXggdG8gbWFrZSB2aXNpYmxlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlldyhpbmRleCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZVxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8oaW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHNjcm9sbCB0byAwIGlmIHNjcm9sbGluZyB0byB0aGUgMHRoIGluZGV4XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5zY3JvbGxUbygwKTtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgc2Nyb2xsIHRvIHRoZSBtYXggdmFsdWUgaWYgc2Nyb2xsaW5nIHRvIHRoZSBOdGggaW5kZXhcbiAgICAvLyBNRENUYWJTY3JvbGxlci5zY3JvbGxUbygpIHdpbGwgbmV2ZXIgc2Nyb2xsIHBhc3QgdGhlIG1heCBwb3NzaWJsZSB2YWx1ZVxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5zY3JvbGxUbyh0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSW50b1ZpZXdSVExfKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbEludG9WaWV3XyhpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGRldGVybWluaW5nIHRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gdGFiIGJhc2VkIG9uIHdoYXQga2V5IHdhcyBwcmVzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW4gVGhlIG9yaWdpbmFsIGluZGV4IGZyb20gd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBrZXlcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8ob3JpZ2luLCBrZXkpIHtcbiAgICBjb25zdCBpc1JUTCA9IHRoaXMuaXNSVExfKCk7XG4gICAgY29uc3QgbWF4SW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkxpc3RMZW5ndGgoKSAtIDE7XG4gICAgY29uc3Qgc2hvdWxkR29Ub0VuZCA9IGtleSA9PT0gc3RyaW5ncy5FTkRfS0VZO1xuICAgIGNvbnN0IHNob3VsZERlY3JlbWVudCA9IGtleSA9PT0gc3RyaW5ncy5BUlJPV19MRUZUX0tFWSAmJiAhaXNSVEwgfHwga2V5ID09PSBzdHJpbmdzLkFSUk9XX1JJR0hUX0tFWSAmJiBpc1JUTDtcbiAgICBjb25zdCBzaG91bGRJbmNyZW1lbnQgPSBrZXkgPT09IHN0cmluZ3MuQVJST1dfUklHSFRfS0VZICYmICFpc1JUTCB8fCBrZXkgPT09IHN0cmluZ3MuQVJST1dfTEVGVF9LRVkgJiYgaXNSVEw7XG4gICAgbGV0IGluZGV4ID0gb3JpZ2luO1xuXG4gICAgaWYgKHNob3VsZEdvVG9FbmQpIHtcbiAgICAgIGluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSBlbHNlIGlmIChzaG91bGREZWNyZW1lbnQpIHtcbiAgICAgIGluZGV4IC09IDE7XG4gICAgfSBlbHNlIGlmIChzaG91bGRJbmNyZW1lbnQpIHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPiBtYXhJbmRleCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgaW5jcmVtZW50IHRoYXQgd2lsbCBtYWtlIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHZpc2libGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBuZXh0IHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIFRhYiBCYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50XyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpIHtcbiAgICBjb25zdCBuZXh0VGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgobmV4dEluZGV4KTtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRMZWZ0ID0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudExlZnQgLSBzY3JvbGxQb3NpdGlvbiAtIGJhcldpZHRoO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudFJpZ2h0ID0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb247XG4gICAgY29uc3QgbGVmdEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudFJpZ2h0IC0gbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuICAgIGNvbnN0IHJpZ2h0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50TGVmdCArIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcblxuICAgIGlmIChuZXh0SW5kZXggPCBpbmRleCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGxlZnRJbmNyZW1lbnQsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChyaWdodEluY3JlbWVudCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIGluY3JlbWVudCB0aGF0IHdpbGwgbWFrZSB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB2aXNpYmxlIGluIFJUTFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5leHRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG5leHQgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhcldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgVGFiIEJhclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsQ29udGVudFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbENvbnRlbnRXaWR0aCkge1xuICAgIGNvbnN0IG5leHRUYWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChuZXh0SW5kZXgpO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudExlZnQgPSBzY3JvbGxDb250ZW50V2lkdGggLSBuZXh0VGFiRGltZW5zaW9ucy5jb250ZW50TGVmdCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudFJpZ2h0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCBsZWZ0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50UmlnaHQgKyBudW1iZXJzLkVYVFJBX1NDUk9MTF9BTU9VTlQ7XG4gICAgY29uc3QgcmlnaHRJbmNyZW1lbnQgPSByZWxhdGl2ZUNvbnRlbnRMZWZ0IC0gbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuXG4gICAgaWYgKG5leHRJbmRleCA+IGluZGV4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobGVmdEluY3JlbWVudCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWluKHJpZ2h0SW5jcmVtZW50LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbmRleCBvZiB0aGUgYWRqYWNlbnQgdGFiIGNsb3Nlc3QgdG8gZWl0aGVyIGVkZ2Ugb2YgdGhlIFRhYiBCYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7IU1EQ1RhYkRpbWVuc2lvbnN9IHRhYkRpbWVuc2lvbnMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHRhYiBiYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlXyhpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKSB7XG4gICAgLyoqXG4gICAgICogVGFicyBhcmUgbGFpZCBvdXQgaW4gdGhlIFRhYiBTY3JvbGxlciBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAgICBTY3JvbGwgUG9zaXRpb25cbiAgICAgKiAgICArLS0tK1xuICAgICAqICAgIHwgICB8ICAgQmFyIFdpZHRoXG4gICAgICogICAgfCAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICB8ICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgIHwgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogICAgfCAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICBWICAgfCAgICAgICAgICAgICBUYWIgU2Nyb2xsZXIgICAgICAgICAgfFxuICAgICAqICAgICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICB8ICAgIFRhYiAgICAgfCAgICAgIFRhYiAgICAgfCAgICAgICAgVGFiICAgICAgICB8XG4gICAgICogICAgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKlxuICAgICAqIFRvIGRldGVybWluZSB0aGUgbmV4dCBhZGphY2VudCBpbmRleCwgd2UgbG9vayBhdCB0aGUgVGFiIHJvb3QgbGVmdCBhbmRcbiAgICAgKiBUYWIgcm9vdCByaWdodCwgYm90aCByZWxhdGl2ZSB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBJZiB0aGUgVGFiIHJvb3RcbiAgICAgKiBsZWZ0IGlzIGxlc3MgdGhhbiAwLCB0aGVuIHdlIGtub3cgaXQncyBvdXQgb2YgdmlldyB0byB0aGUgbGVmdC4gSWYgdGhlXG4gICAgICogVGFiIHJvb3QgcmlnaHQgbWludXMgdGhlIGJhciB3aWR0aCBpcyBncmVhdGVyIHRoYW4gMCwgd2Uga25vdyB0aGUgVGFiIGlzXG4gICAgICogb3V0IG9mIHZpZXcgdG8gdGhlIHJpZ2h0LiBGcm9tIHRoZXJlLCB3ZSBlaXRoZXIgaW5jcmVtZW50IG9yIGRlY3JlbWVudFxuICAgICAqIHRoZSBpbmRleC5cbiAgICAgKi9cbiAgICBjb25zdCByZWxhdGl2ZVJvb3RMZWZ0ID0gdGFiRGltZW5zaW9ucy5yb290TGVmdCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlbGF0aXZlUm9vdFJpZ2h0ID0gdGFiRGltZW5zaW9ucy5yb290UmlnaHQgLSBzY3JvbGxQb3NpdGlvbiAtIGJhcldpZHRoO1xuICAgIGNvbnN0IHJlbGF0aXZlUm9vdERlbHRhID0gcmVsYXRpdmVSb290TGVmdCArIHJlbGF0aXZlUm9vdFJpZ2h0O1xuICAgIGNvbnN0IGxlZnRFZGdlSXNDbG9zZXIgPSByZWxhdGl2ZVJvb3RMZWZ0IDwgMCB8fCByZWxhdGl2ZVJvb3REZWx0YSA8IDA7XG4gICAgY29uc3QgcmlnaHRFZGdlSXNDbG9zZXIgPSByZWxhdGl2ZVJvb3RSaWdodCA+IDAgfHwgcmVsYXRpdmVSb290RGVsdGEgPiAwO1xuXG4gICAgaWYgKGxlZnRFZGdlSXNDbG9zZXIpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIDE7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbmRleCBvZiB0aGUgYWRqYWNlbnQgdGFiIGNsb3Nlc3QgdG8gZWl0aGVyIGVkZ2Ugb2YgdGhlIFRhYiBCYXIgaW4gUlRMXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJEaW1lbnNpb25zfSB0YWJEaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSB0YWIgYmFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxDb250ZW50V2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxlciBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZVJUTF8oaW5kZXgsIHRhYkRpbWVuc2lvbnMsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCwgc2Nyb2xsQ29udGVudFdpZHRoKSB7XG4gICAgY29uc3Qgcm9vdExlZnQgPSBzY3JvbGxDb250ZW50V2lkdGggLSB0YWJEaW1lbnNpb25zLnJvb3RMZWZ0IC0gYmFyV2lkdGggLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByb290UmlnaHQgPSBzY3JvbGxDb250ZW50V2lkdGggLSB0YWJEaW1lbnNpb25zLnJvb3RSaWdodCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJvb3REZWx0YSA9IHJvb3RMZWZ0ICsgcm9vdFJpZ2h0O1xuICAgIGNvbnN0IGxlZnRFZGdlSXNDbG9zZXIgPSByb290TGVmdCA+IDAgfHwgcm9vdERlbHRhID4gMDtcbiAgICBjb25zdCByaWdodEVkZ2VJc0Nsb3NlciA9IHJvb3RSaWdodCA8IDAgfHwgcm9vdERlbHRhIDwgMDtcblxuICAgIGlmIChsZWZ0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cblxuICAgIGlmIChyaWdodEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCBhIGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dCBUaGUga2V5ZG93biBldmVudFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRLZXlGcm9tRXZlbnRfKGV2dCkge1xuICAgIGlmIChBQ0NFUFRBQkxFX0tFWVMuaGFzKGV2dC5rZXkpKSB7XG4gICAgICByZXR1cm4gZXZ0LmtleTtcbiAgICB9XG5cbiAgICByZXR1cm4gS0VZQ09ERV9NQVAuZ2V0KGV2dC5rZXlDb2RlKTtcbiAgfVxuXG4gIGlzQWN0aXZhdGlvbktleV8oa2V5KSB7XG4gICAgcmV0dXJuIGtleSA9PT0gc3RyaW5ncy5TUEFDRV9LRVkgfHwga2V5ID09PSBzdHJpbmdzLkVOVEVSX0tFWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBpcyBpbmNsdXNpdmVseSBiZXR3ZWVuIHRoZSBlbmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gdGVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5kZXhJc0luUmFuZ2VfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldFRhYkxpc3RMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2aWV3J3MgUlRMIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1JUTF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNSVEwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlldyBmb3IgbGVmdC10by1yaWdodCB1c2VyYWdlbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBzY3JvbGwgaW50byB2aWV3XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlld18oaW5kZXgpIHtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCB0YWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChpbmRleCk7XG4gICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5maW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VfKGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpO1xuXG4gICAgaWYgKCF0aGlzLmluZGV4SXNJblJhbmdlXyhuZXh0SW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsSW5jcmVtZW50ID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxJbmNyZW1lbnRfKGluZGV4LCBuZXh0SW5kZXgsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsSW5jcmVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlldyBpbiBSVExcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0YWIgaW5kZXggdG8gbWFrZSB2aXNpYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlld1JUTF8oaW5kZXgpIHtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCB0YWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChpbmRleCk7XG4gICAgY29uc3Qgc2Nyb2xsV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlUlRMXyhcbiAgICAgIGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbFdpZHRoKTtcblxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8obmV4dEluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbEluY3JlbWVudCA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbFdpZHRoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmluY3JlbWVudFNjcm9sbChzY3JvbGxJbmNyZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkJhckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQge01EQ1RhYiwgTURDVGFiRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL3RhYi9pbmRleCc7XG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyfSBmcm9tICdAbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2luZGV4JztcblxuaW1wb3J0IE1EQ1RhYkJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJCYXJGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDVGFiQmFyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiQmFyIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8IU1EQ1RhYj59ICovXG4gICAgdGhpcy50YWJMaXN0XztcblxuICAgIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYil9ICovXG4gICAgdGhpcy50YWJGYWN0b3J5XztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P01EQ1RhYlNjcm9sbGVyfSAqL1xuICAgIHRoaXMudGFiU2Nyb2xsZXJfO1xuXG4gICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oIUVsZW1lbnQpOiAhTURDVGFiU2Nyb2xsZXIpfSAqL1xuICAgIHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5XztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P2Z1bmN0aW9uKD9FdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhhbmRsZVRhYkludGVyYWN0aW9uXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P2Z1bmN0aW9uKD9FdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhhbmRsZUtleURvd25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ1RhYkJhcn1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENUYWJCYXIocm9vdCk7XG4gIH1cblxuICBzZXQgdXNlQXV0b21hdGljQWN0aXZhdGlvbih1c2VBdXRvbWF0aWNBY3RpdmF0aW9uKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRVc2VBdXRvbWF0aWNBY3RpdmF0aW9uKHVzZUF1dG9tYXRpY0FjdGl2YXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYik9fSB0YWJGYWN0b3J5IEEgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBNRENUYWJcbiAgICogQHBhcmFtIHsoZnVuY3Rpb24oIUVsZW1lbnQpOiAhTURDVGFiU2Nyb2xsZXIpPX0gdGFiU2Nyb2xsZXJGYWN0b3J5IEEgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBNRENUYWJTY3JvbGxlclxuICAgKi9cbiAgaW5pdGlhbGl6ZShcbiAgICB0YWJGYWN0b3J5ID0gKGVsKSA9PiBuZXcgTURDVGFiKGVsKSxcbiAgICB0YWJTY3JvbGxlckZhY3RvcnkgPSAoZWwpID0+IG5ldyBNRENUYWJTY3JvbGxlcihlbCksXG4gICkge1xuICAgIHRoaXMudGFiRmFjdG9yeV8gPSB0YWJGYWN0b3J5O1xuICAgIHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5XyA9IHRhYlNjcm9sbGVyRmFjdG9yeTtcblxuICAgIHRoaXMudGFiTGlzdF8gPSB0aGlzLmdldFRhYkVsZW1lbnRzXygpLm1hcCgoZWwpID0+IHRoaXMudGFiRmFjdG9yeV8oZWwpKTtcblxuICAgIGNvbnN0IHRhYlNjcm9sbGVyRWxlbWVudCA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX1NDUk9MTEVSX1NFTEVDVE9SKTtcbiAgICBpZiAodGFiU2Nyb2xsZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLnRhYlNjcm9sbGVyXyA9IHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5Xyh0YWJTY3JvbGxlckVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLmhhbmRsZVRhYkludGVyYWN0aW9uXyA9IChldnQpID0+IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlVGFiSW50ZXJhY3Rpb24oZXZ0KTtcbiAgICB0aGlzLmhhbmRsZUtleURvd25fID0gKGV2dCkgPT4gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVLZXlEb3duKGV2dCk7XG5cbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNURURfRVZFTlQsIHRoaXMuaGFuZGxlVGFiSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25fKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWJMaXN0Xy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMudGFiTGlzdF9baV0uYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RFRF9FVkVOVCwgdGhpcy5oYW5kbGVUYWJJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bl8pO1xuICAgIHRoaXMudGFiTGlzdF8uZm9yRWFjaCgodGFiKSA9PiB0YWIuZGVzdHJveSgpKTtcbiAgICB0aGlzLnRhYlNjcm9sbGVyXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkJhckZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYkJhckZvdW5kYXRpb24oXG4gICAgICAvKiogQHR5cGUgeyFNRENUYWJCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgICBzY3JvbGxUbzogKHNjcm9sbFgpID0+IHRoaXMudGFiU2Nyb2xsZXJfLnNjcm9sbFRvKHNjcm9sbFgpLFxuICAgICAgICBpbmNyZW1lbnRTY3JvbGw6IChzY3JvbGxYSW5jcmVtZW50KSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCksXG4gICAgICAgIGdldFNjcm9sbFBvc2l0aW9uOiAoKSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5nZXRTY3JvbGxQb3NpdGlvbigpLFxuICAgICAgICBnZXRTY3JvbGxDb250ZW50V2lkdGg6ICgpID0+IHRoaXMudGFiU2Nyb2xsZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpLFxuICAgICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRXaWR0aCxcbiAgICAgICAgaXNSVEw6ICgpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdF8pLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgICAgc2V0QWN0aXZlVGFiOiAoaW5kZXgpID0+IHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGVUYWIoaW5kZXgpLFxuICAgICAgICBhY3RpdmF0ZVRhYkF0SW5kZXg6IChpbmRleCwgY2xpZW50UmVjdCkgPT4gdGhpcy50YWJMaXN0X1tpbmRleF0uYWN0aXZhdGUoY2xpZW50UmVjdCksXG4gICAgICAgIGRlYWN0aXZhdGVUYWJBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmRlYWN0aXZhdGUoKSxcbiAgICAgICAgZm9jdXNUYWJBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmZvY3VzKCksXG4gICAgICAgIGdldFRhYkluZGljYXRvckNsaWVudFJlY3RBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0KCksXG4gICAgICAgIGdldFRhYkRpbWVuc2lvbnNBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmNvbXB1dGVEaW1lbnNpb25zKCksXG4gICAgICAgIGdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXg6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFiTGlzdF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYkxpc3RfW2ldLmFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGb2N1c2VkVGFiSW5kZXg6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0YWJFbGVtZW50cyA9IHRoaXMuZ2V0VGFiRWxlbWVudHNfKCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHRhYkVsZW1lbnRzLmluZGV4T2YoYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEluZGV4T2ZUYWI6ICh0YWJUb0ZpbmQpID0+IHRoaXMudGFiTGlzdF8uaW5kZXhPZih0YWJUb0ZpbmQpLFxuICAgICAgICBnZXRUYWJMaXN0TGVuZ3RoOiAoKSA9PiB0aGlzLnRhYkxpc3RfLmxlbmd0aCxcbiAgICAgICAgbm90aWZ5VGFiQWN0aXZhdGVkOiAoaW5kZXgpID0+IHRoaXMuZW1pdChNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX0FDVElWQVRFRF9FVkVOVCwge2luZGV4fSwgdHJ1ZSksXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKi9cbiAgYWN0aXZhdGVUYWIoaW5kZXgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlVGFiKGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlld1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVEhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICovXG4gIHNjcm9sbEludG9WaWV3KGluZGV4KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gIH1cblxuICBnZXRUYWJFbGVtZW50c18oKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKE1EQ1RhYkJhckZvdW5kYXRpb24uc3RyaW5ncy5UQUJfU0VMRUNUT1IpKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYkJhciwgTURDVGFiQmFyRm91bmRhdGlvbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlRhYkJhciA9IGV4cG9ydHMuVGFiID0gZXhwb3J0cy5UYWJJY29uID0gZXhwb3J0cy5UYWJMYWJlbCA9IHZvaWQgMDtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF90YWJCYXIgPSByZXF1aXJlKFwiQG1hdGVyaWFsL3RhYi1iYXJcIik7XG5cbnZhciBfcHJlYWN0ID0gcmVxdWlyZShcInByZWFjdFwiKTtcblxudmFyIF9NYXRlcmlhbENvbXBvbmVudDUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9CYXNlL01hdGVyaWFsQ29tcG9uZW50XCIpKTtcblxudmFyIFRhYkxhYmVsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWF0ZXJpYWxDb21wb25lbnQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiTGFiZWwsIF9NYXRlcmlhbENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGFiTGFiZWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiTGFiZWwpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJMYWJlbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMuY29tcG9uZW50TmFtZSA9ICd0YWJfX3RleHQtbGFiZWwnO1xuICAgIF90aGlzLm1kY1Byb3BzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGFiTGFiZWwsIFt7XG4gICAga2V5OiBcIm1hdGVyaWFsRG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGVyaWFsRG9tKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9wcmVhY3QuaCkoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiTGFiZWw7XG59KF9NYXRlcmlhbENvbXBvbmVudDUuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVGFiTGFiZWwgPSBUYWJMYWJlbDtcblxudmFyIFRhYkljb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXRlcmlhbENvbXBvbmVudDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiSWNvbiwgX01hdGVyaWFsQ29tcG9uZW50Mik7XG5cbiAgZnVuY3Rpb24gVGFiSWNvbigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiSWNvbik7XG4gICAgX3RoaXMyID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJJY29uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBfdGhpczIuY29tcG9uZW50TmFtZSA9ICd0YWJfX2ljb24nO1xuICAgIF90aGlzMi5tZGNQcm9wcyA9IFtdO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWJJY29uLCBbe1xuICAgIGtleTogXCJtYXRlcmlhbERvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRlcmlhbERvbShwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1hdGVyaWFsLWljb25zXCJcbiAgICAgIH0sIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiSWNvbjtcbn0oX01hdGVyaWFsQ29tcG9uZW50NS5kZWZhdWx0KTtcblxuZXhwb3J0cy5UYWJJY29uID0gVGFiSWNvbjtcblxudmFyIFRhYiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hdGVyaWFsQ29tcG9uZW50Mykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUYWIsIF9NYXRlcmlhbENvbXBvbmVudDMpO1xuXG4gIGZ1bmN0aW9uIFRhYigpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiKTtcbiAgICBfdGhpczMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMzLmNvbXBvbmVudE5hbWUgPSAndGFiJztcbiAgICBfdGhpczMubWRjUHJvcHMgPSBbJ2FjdGl2ZSddO1xuICAgIF90aGlzMy5tZGNOb3RpZnlQcm9wcyA9IFsnYWN0aXZlJ107XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRhYiwgW3tcbiAgICBrZXk6IFwibWF0ZXJpYWxEb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0ZXJpYWxEb20ocHJvcHMpIHtcbiAgICAgIHJldHVybiAoMCwgX3ByZWFjdC5oKShcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYlwiLFxuICAgICAgICByb2xlOiBcInRhYlwiLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCJcbiAgICAgIH0sIHByb3BzKSwgKDAsIF9wcmVhY3QuaCkoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYl9fY29udGVudFwiXG4gICAgICB9LCBwcm9wcy5jaGlsZHJlbiksICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItaW5kaWNhdG9yIFwiLmNvbmNhdChwcm9wcy5hY3RpdmUgPyAnbWRjLXRhYi1pbmRpY2F0b3ItLWFjdGl2ZScgOiAnJylcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItaW5kaWNhdG9yX19jb250ZW50IG1kYy10YWItaW5kaWNhdG9yX19jb250ZW50LS11bmRlcmxpbmVcIlxuICAgICAgfSkpLCAoMCwgX3ByZWFjdC5oKShcInNwYW5cIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiX19yaXBwbGVcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiO1xufShfTWF0ZXJpYWxDb21wb25lbnQ1LmRlZmF1bHQpO1xuXG5leHBvcnRzLlRhYiA9IFRhYjtcblxudmFyIFRhYkJhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hdGVyaWFsQ29tcG9uZW50NCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUYWJCYXIsIF9NYXRlcmlhbENvbXBvbmVudDQpO1xuXG4gIGZ1bmN0aW9uIFRhYkJhcigpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiQmFyKTtcbiAgICBfdGhpczQgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYkJhcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXM0LmNvbXBvbmVudE5hbWUgPSAndGFiLWJhcic7XG4gICAgX3RoaXM0Lm1kY1Byb3BzID0gW107XG4gICAgX3RoaXM0Lm1kY05vdGlmeVByb3BzID0gWydhY3RpdmVUYWJJbmRleCddO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWJCYXIsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYkJhci5wcm90b3R5cGUpLCBcImNvbXBvbmVudERpZE1vdW50XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5NRENvbXBvbmVudCA9IG5ldyBfdGFiQmFyLk1EQ1RhYkJhcih0aGlzLmNvbnRyb2wpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFmdGVyQ29tcG9uZW50RGlkTW91bnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVGFiQmFyLnByb3RvdHlwZSksIFwiY29tcG9uZW50V2lsbFVubW91bnRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXMuTURDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5NRENvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGVyaWFsRG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGVyaWFsRG9tKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9wcmVhY3QuaCkoXCJkaXZcIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiLWJhclwiLFxuICAgICAgICByb2xlOiBcInRhYmxpc3RcIixcbiAgICAgICAgcmVmOiB0aGlzLnNldENvbnRyb2xSZWZcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYi1zY3JvbGxlclwiXG4gICAgICB9LCAoMCwgX3ByZWFjdC5oKShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1hcmVhXCJcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnRcIlxuICAgICAgfSwgcHJvcHMuY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiQmFyO1xufShfTWF0ZXJpYWxDb21wb25lbnQ1LmRlZmF1bHQpO1xuXG5leHBvcnRzLlRhYkJhciA9IFRhYkJhcjtcblxudmFyIGRlZmF1bHRfMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1RhYkJhcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShkZWZhdWx0XzEsIF9UYWJCYXIpO1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBkZWZhdWx0XzEpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKGRlZmF1bHRfMSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdF8xO1xufShUYWJCYXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5kZWZhdWx0XzEuVGFiID0gVGFiO1xuZGVmYXVsdF8xLlRhYkxhYmVsID0gVGFiTGFiZWw7XG5kZWZhdWx0XzEuVGFiSWNvbiA9IFRhYkljb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcblxuaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXG5cbmNvbnN0IERhdGVMaW5lYnJlYWsgPSh7ZGF0ZXRpbWV9KT0+e1xuICAgIHJldHVybiAoXG48ZGl2IHN0eWxlPXt7ZGlzcGxheTpcImZsZXhcIn19PlxuPGRpdiBzdHlsZT17e2ZsZXg6XCIxXCJ9fT48aHIgLz48L2Rpdj5cbjxkaXY+e25ldyBEYXRlKGRhdGV0aW1lKS50b0xvY2FsZURhdGVTdHJpbmcoKX08L2Rpdj5cbjxkaXYgc3R5bGU9e3tmbGV4OjF9fT48aHIgLz48L2Rpdj5cbjwvZGl2PlxuKVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRlTGluZWJyZWFrIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuXG5jb25zdCBNZXNzYWdlQWxpZ25lciA9ICh7IGNoaWxkcmVuLCBzaWRlLCBzdHlsZSB9KSA9PiB7XG4gICAgY29uc3QgYWxpZ25tZW50ID0gc2lkZSA9PT0gXCJsZWZ0XCIgPyBcImZsZXgtc3RhcnRcIiA6IFwiZmxleC1lbmRcIlxuICAgIHJldHVybiA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBqdXN0aWZ5Q29udGVudDogYWxpZ25tZW50LCAuLi5zdHlsZSB9fT57Y2hpbGRyZW59PC9kaXY+XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUFsaWduZXIiLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcblxuXG5jb25zdCBNZXNzYWdlVmlldyA9ICh7IG1lc3NhZ2UsIGJhY2tncm91bmRDb2xvciwgZGF0ZXRpbWUgfSkgPT4gKFxuPGRpdiBzdHlsZT17e1xuICBiYWNrZ3JvdW5kQ29sb3IsXG4gIHBhZGRpbmc6IDUsXG4gIG1hcmdpbjogMixcbiAgYm9yZGVyUmFkaXVzOiAxNSxcbiAgYm9yZGVyQ29sb3I6ICcjOUU5RTlFJyxcbiAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBtYXhXaWR0aDogJzEwMCUnLFxuICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxuICB3b3JkQnJlYWs6ICdicmVhay1hbGwnLFxuICBtaW5XaWR0aDogJzMwJScsXG59fVxuPlxuICAgIDxkaXY+e21lc3NhZ2V9PC9kaXY+XG4gICAgPGRpdiBzdHlsZT17e1xuICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgcGFkZGluZ1RvcDogMixcbiAgICAgIHRleHRBbGlnbjogJ2VuZCcsXG4gICAgfX1cbiAgICA+XG48aSBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6ICcjZWZlYmU5JyB9fT57bmV3IERhdGUoZGF0ZXRpbWUpLnRvTG9jYWxlVGltZVN0cmluZygpfTwvaT5cblxuICAgIDwvZGl2PlxuPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlVmlldztcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9tZXNzYWdlLXZpZXcnXG5cbmNvbnN0IFN1YnNlcXVlbnRNZXNzYWdlID0gKHsgbWVzc2FnZSwgZGF0ZXRpbWUgfSkgPT4ge1xuXG4gICAgICAgIHJldHVybiAoXG5cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBtYXJnaW5MZWZ0OjQ1IH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPE1lc3NhZ2UgbWVzc2FnZT17bWVzc2FnZX0gZGF0ZXRpbWU9e2RhdGV0aW1lfSBiYWNrZ3JvdW5kQ29sb3I9XCIjRkZFQ0IzXCIgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnNlcXVlbnRNZXNzYWdlIiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IHN0eWxlID0ge1xuICBoZWlnaHQ6IDMwLFxuICB3aWR0aDogNDAsXG4gIHBhZGRpbmc6IDMsXG4gIGJvcmRlclJhZGl1czogMzAsXG4gIGJhY2tncm91bmRDb2xvcjogJ2RhcmtTbW9rZScsXG4gIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICBib3JkZXJXaWR0aDogMixcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBjb2xvcjogJyMwMDk2ODgnLFxuICBib3JkZXJDb2xvcjogJyM4MGNiYzQnLFxufTtcblxuXG5jb25zdCBNZXNzYWdlQXZhdGFyID0gKHsgbGV0dGVyID0gJ1UnIH0pID0+ICg8ZGl2IHN0eWxlPXtzdHlsZX0+PGRpdj57bGV0dGVyLnRvVXBwZXJDYXNlKCl9PC9kaXY+PC9kaXY+KTtcblxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUF2YXRhcjtcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9tZXNzYWdlLXZpZXcnXG5pbXBvcnQgTWVzc2FnZUF2YXRhciBmcm9tICcuL21lc3NhZ2UtYXZhdGFyJ1xuXG5jb25zdCBGaXJzdE1lc3NhZ2UgPSAoeyBtZXNzYWdlLCBkYXRldGltZSxsZXR0ZXIsbG9jYWwgfSkgPT4ge1xuXG4gICAgcmV0dXJuIChcblxuICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH19PlxuICAgICAgICAgICAgeyFsb2NhbCAmJjxNZXNzYWdlQXZhdGFyIGxldHRlcj17bGV0dGVyfSAvPn1cbiAgICAgICAgICAgIDxNZXNzYWdlIG1lc3NhZ2U9e21lc3NhZ2V9IGRhdGV0aW1lPXtkYXRldGltZX0gYmFja2dyb3VuZENvbG9yPVwiI0ZGRUNCM1wiIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaXJzdE1lc3NhZ2UiLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nICovXG5pbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCBNZXNzYWdlQWxpZ25lciBmcm9tICcuL21lc3NhZ2UtYWxpZ25lcic7XG5pbXBvcnQgRmlyc3RNZXNzYWdlIGZyb20gJy4vZmlyc3QtbWVzc2FnZSc7XG5pbXBvcnQgU3Vic2VxdWVudE1lc3NhZ2UgZnJvbSAnLi9zdWJzZXF1ZW50LW1lc3NhZ2UnO1xuaW1wb3J0IERhdGVMaW5lYnJlYWsgZnJvbSAnLi9kYXRlLWxpbmVicmVhayc7XG5cbmNvbnN0IE1lc3NhZ2VPYmplY3RNYXBwdGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBvcmRlciwgZGF0ZVNwYWNlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge2RhdGVTcGFjZSAmJiA8RGF0ZUxpbmVicmVhayB7Li4ucHJvcHN9IC8+fVxuICAgICAgICAgICAgPE1lc3NhZ2VBbGlnbmVyIHsuLi5wcm9wc30+XG4gICAgICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID09PSAnRicgPyA8Rmlyc3RNZXNzYWdlIHsuLi5wcm9wc30gLz4gOiA8U3Vic2VxdWVudE1lc3NhZ2Ugey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgPC9NZXNzYWdlQWxpZ25lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VPYmplY3RNYXBwdGVyO1xuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXG5pbXBvcnQge3VzZUVmZmVjdCx1c2VTdGF0ZX0gZnJvbSAncHJlYWN0L2hvb2tzJ1xuXG5jb25zdCB1c2VNZXNzYWdlU29ydGVyID0obWVzc2FnZXMpPT57XG5jb25zdCBbc29ydGVkTWVzc2FnZXMsc2V0U29ydGVkTWVzc2FnZXNdPXVzZVN0YXRlKG1lc3NhZ2VzKVxudXNlRWZmZWN0KCgpPT57XG5cbiAgICBzZXRTb3J0ZWRNZXNzYWdlcyhtZXNzYWdlcy5zb3J0KChhLCBiKT0+IGEuZGF0ZXRpbWUgLSBiLmRhdGV0aW1lKSlcbn0sW21lc3NhZ2VzXSlcblxucmV0dXJue3NvcnRlZE1lc3NhZ2VzfVxufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VNZXNzYWdlU29ydGVyXG5cbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IHt1c2VTdGF0ZSx1c2VFZmZlY3R9IGZyb20gJ3ByZWFjdC9ob29rcydcblxuY29uc3QgdXNlTWVzc2FnZXNNYXBwZXIgPShtZXNzYWdlcyk9PntcbiAgY29uc3QgW21hcHBlZE1lc3NhZ2VzLHNldE1hcHBlZE1lc3NhZ2VzXT11c2VTdGF0ZShtZXNzYWdlcylcbiAgY29uc3QgbWFwTWVzc2FnZXMgPSgpPT57XG4gICAgY29uc3QgbG9jYWxTaWRlID1cInJpZ2h0XCJcbiAgICBjb25zdCByZW1vdGVTaWRlPVwibGVmdFwiXG4gICAgaWYobWVzc2FnZXMubGVuZ3RoPT09MCl7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgICBsZXQgZW1haWwgPSBtZXNzYWdlc1swXS5mcm9tXG4gICAgICBsZXQgbGFzdERhdGV0aW1lID0gbWVzc2FnZXNbMF0uZGF0ZXRpbWVcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKChtLCBpKSA9PiB7XG4gIFxuICAgICAgaWYgKGkgPT09IDAgJiYgbS5sb2NhbCkge1xuICAgICAgXG4gICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogbG9jYWxTaWRlLCBvcmRlcjogXCJGXCIsIGRhdGVTcGFjZTogdHJ1ZSB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gMCAmJiAhbS5sb2NhbCkge1xuICAgICBcbiAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXG4gICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IHRydWUsbGV0dGVyIH1cbiAgICAgIH1cbiAgIFxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsID09PSBtLmZyb20gJiYgbS5sb2NhbCkge1xuICAgICAgICAgIGlmIChuZXcgRGF0ZShsYXN0RGF0ZXRpbWUpLmdldERhdGUoKSAhPT0gbmV3IERhdGUobS5kYXRldGltZSkuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgICAgIGVtYWlsID0gbS5mcm9tXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogbG9jYWxTaWRlLCBvcmRlcjogXCJTXCIsIGRhdGVTcGFjZTogdHJ1ZSB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IGxvY2FsU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IGZhbHNlIH1cbiAgICAgICAgICBcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgIT09IG0uZnJvbSAmJiBtLmxvY2FsKSB7XG4gICAgICAgIFxuICAgICAgICAgIGlmIChuZXcgRGF0ZShsYXN0RGF0ZXRpbWUpLmdldERhdGUoKSA9PT0gbmV3IERhdGUobS5kYXRldGltZSkuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICBcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiBmYWxzZSB9XG4gICAgICAgICAgfSBcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsID09PSBtLmZyb20gJiYgIW0ubG9jYWwpIHtcbiAgICAgICAgXG4gICAgICAgICAgaWYgKG5ldyBEYXRlKGxhc3REYXRldGltZSkuZ2V0RGF0ZSgpICE9PSBuZXcgRGF0ZShtLmRhdGV0aW1lKS5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IHRydWUsbGV0dGVyIH1cbiAgICAgICAgICB9IFxuICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IGZhbHNlLGxldHRlciB9XG4gICAgICAgICAgXG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgIT09IG0uZnJvbSAmJiAhbS5sb2NhbCkge1xuICAgICAgICBcbiAgICAgICAgICBpZiAobmV3IERhdGUobGFzdERhdGV0aW1lKS5nZXREYXRlKCkgPT09IG5ldyBEYXRlKG0uZGF0ZXRpbWUpLmdldERhdGUoKSkge1xuICAgICAgICAgXG4gICAgICAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXG4gICAgICAgICAgICAgIGVtYWlsID0gbS5mcm9tXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IGZhbHNlLGxldHRlciB9XG4gICAgICAgICAgfVxuICAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IG0uZnJvbVswXSAhPT11bmRlZmluZWQgPyBtLmZyb21bMF06XCJcIlxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IHJlbW90ZVNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiB0cnVlLGxldHRlciB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICB9KVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpPT57XG4gICAgc2V0TWFwcGVkTWVzc2FnZXMobWFwTWVzc2FnZXMoKSlcbiAgfSxbbWVzc2FnZXNdKVxucmV0dXJuIHttYXBwZWRNZXNzYWdlc31cbn1cblxuZXhwb3J0IGRlZmF1bHQgdXNlTWVzc2FnZXNNYXBwZXJcbiIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kczsiLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXkgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2pzeC1wcm9wcy1uby1zcHJlYWRpbmcgKi9cbmltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IE1lc3NhZ2VPYmplY3RNYXBwZXIgZnJvbSAnLi9tZXNzYWdlLW9iamVjdC1tYXBwZXInXG5cbmNvbnN0IE1lc3NhZ2VDb2xsZWN0aW9uVmlldyA9ICh7IG1lc3NhZ2VzIH0pID0+e1xuXG4gICAgaWYobWVzc2FnZXMubGVuZ3RoPjApe1xuICAgICAgIFxuICAgICAgICByZXR1cm4gIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgaSkgPT4gPE1lc3NhZ2VPYmplY3RNYXBwZXIgey4uLm1lc3NhZ2V9IGtleT17aX0gLz4pXG4gICAgfVxuICAgICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlQ29sbGVjdGlvblZpZXciLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1kZXByZWNhdGVkICovXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuXG5jb25zdCBNZXNzYWdlVmlld1Njcm9sbGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgxODBkZWcpXCIsXG4gICAgICAgIGhlaWdodDogXCI4NSVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZGVmZjJcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwic2Nyb2xsXCIsXG4gICAgICAgIHdpZHRoOlwiMTAwJVwiXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxkaXYgc3R5bGU9e3sgdHJhbnNmb3JtOiBcInJvdGF0ZSgxODBkZWcpXCIgfX0+XG4gICAgICAgIHsgY2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VWaWV3U2Nyb2xsZXI7XG5cblxuIiwiXG5pbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcblxuY29uc3QgTWVzc2FnZUVkaXRvckRpc3BsYXllciA9ICh7XG4gIG9uTWVzc2FnZUNoYW5nZSwgbWVzc2FnZSwgc2VuZE1lc3NhZ2UsIGlkID0gMCwgZGlzYWJsZWQsXG59KSA9PiAoXG4gIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnIH19PlxuICAgIDxpbnB1dCBzdHlsZT17eyBmbGV4OiAxIH19IGRhdGEtdGVzdGlkPXtgbWVzc2FnZSR7aWR9YH0gb25JbnB1dD17b25NZXNzYWdlQ2hhbmdlfSB2YWx1ZT17bWVzc2FnZX0gbmFtZT1cIm1lc3NhZ2VcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiRW50ZXIgbWVzc2FnZSB0ZXh0XCIgLz5cbiAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JyB9fT5cbiAgICAgICAgICA8YnV0dG9uIGRhdGEtdGVzdGlkPXtgc2VuZE1lc3NhZ2Uke2lkfWB9IGRpc2FibGVkPXttZXNzYWdlID09PSAnJyB8fCBkaXNhYmxlZH0gc3R5bGU9e3sgbWFyZ2luTGVmdDogMiwgd2lkdGg6ICcxMDAlJyB9fSBvbkNsaWNrPXtzZW5kTWVzc2FnZX0+XG5cbiAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMi4wMSAyMUwyMyAxMiAyLjAxIDMgMiAxMGwxNSAyLTE1IDJ6XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuKTtcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VFZGl0b3JEaXNwbGF5ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1zaGFkb3cgKi9cbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgdXNlTWVzc2FnZVNvcnRlciBmcm9tIFwiLi91c2VNZXNzYWdlU29ydGVyXCI7XG5pbXBvcnQgdXNlTWVzc2FnZU1hcHBlciBmcm9tIFwiLi91c2VNZXNzYWdlTWFwcGVyXCI7XG5pbXBvcnQgTWVzc2FnZUNvbGxlY3Rpb25WaWV3IGZyb20gXCIuL21lc3NhZ2UtY29sbGVjdGlvbi12aWV3XCI7XG5pbXBvcnQgTWVzc2FnZVZpZXdTY3JvbGxlciBmcm9tIFwiLi9tZXNzYWdlcy12aWV3LXNjcm9sbGVyXCI7XG5pbXBvcnQgTWVzc2FnZUVkaXRvckRpc3BsYXllciBmcm9tIFwiLi4vLi4vbWVzc2FnZS1lZGl0b3ItZGlzcGxheWVyXCI7XG5cbmNvbnN0IE1lc3NhZ2VzRGlzcGxheWVyID0gKHtcbiAgbWVzc2FnZXMsXG4gIHNvY2tldCxcbiAgaWQsXG4gIG1lc3NhZ2VUZXh0LFxuICBzZW5kTWVzc2FnZSxcbiAgaGFuZGxlTWVzc2FnZUNoYW5nZVxufSkgPT4ge1xuICBjb25zdCB7IHNvcnRlZE1lc3NhZ2VzIH0gPSB1c2VNZXNzYWdlU29ydGVyKG1lc3NhZ2VzKTtcbiAgY29uc3QgeyBtYXBwZWRNZXNzYWdlcyB9ID0gdXNlTWVzc2FnZU1hcHBlcihzb3J0ZWRNZXNzYWdlcyk7XG4gIHJldHVybiBbXG5cbiAgICAgIDxNZXNzYWdlVmlld1Njcm9sbGVyPlxuICAgICAgICA8TWVzc2FnZUNvbGxlY3Rpb25WaWV3IG1lc3NhZ2VzPXttYXBwZWRNZXNzYWdlc30gLz5cbiAgICAgIDwvTWVzc2FnZVZpZXdTY3JvbGxlcj4sXG4gICAgICA8TWVzc2FnZUVkaXRvckRpc3BsYXllclxuICAgICAgICBkaXNhYmxlZD17c29ja2V0ID09PSBudWxsfVxuICAgICAgICBpZD17aWR9XG4gICAgICAgIG1lc3NhZ2U9e21lc3NhZ2VUZXh0fVxuICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1lc3NhZ2V9XG4gICAgICAgIG9uTWVzc2FnZUNoYW5nZT17aGFuZGxlTWVzc2FnZUNoYW5nZX1cbiAgICAgIC8+XG5cbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VzRGlzcGxheWVyO1xuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCBNZXNzYWdlRGlzcGxheWVyIGZyb20gXCIuLi8uLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXJcIjtcbmltcG9ydCAnLi9zdHlsZS5jc3MnXG5jb25zdCBDaGF0VXNlciA9ICh7XG4gIG5hbWUsXG4gIHRhcmdldE5hbWUsXG4gIHNvY2tldCxcbiAgZXJyb3JzLFxuICBtZXNzYWdlcyxcbiAgaGFuZGxlTWVzc2FnZUNoYW5nZSxcbiAgbWVzc2FnZVRleHQsXG4gIHNlbmRNZXNzYWdlXG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyb290XCIgc3R5bGU9e3sgaGVpZ2h0OiBcIjk3JVwiLCB3aWR0aDpcIjUwJVwiIH19PlxuICAgICAgPE1lc3NhZ2VEaXNwbGF5ZXJcbiAgICAgICAgZXJyb3JzPXtlcnJvcnN9XG4gICAgICAgIHNvY2tldD17c29ja2V0fVxuICAgICAgICBtZXNzYWdlcz17bWVzc2FnZXN9XG4gICAgICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U9e2hhbmRsZU1lc3NhZ2VDaGFuZ2V9XG4gICAgICAgIG1lc3NhZ2VUZXh0PXttZXNzYWdlVGV4dH1cbiAgICAgICAgc2VuZE1lc3NhZ2U9e3NlbmRNZXNzYWdlfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYXRVc2VyO1xuIiwiZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImltcG9ydCB7aCwgQ29tcG9uZW50fSBmcm9tICdwcmVhY3QnXG5pbXBvcnQge3VzZVN0YXRlLCB1c2VFZmZlY3R9IGZyb20gJ3ByZWFjdC9ob29rcydcblxuY29uc3QgdXNlU29ja2V0TWVzc2FnaW5nID0oe3NvY2tldCx0YXJnZXROYW1lfSk9PntcbmNvbnN0IFttZXNzYWdlVGV4dCxzZXRNZXNzYWdlVGV4dF09dXNlU3RhdGUoJycpXG5jb25zdCBbbWVzc2FnZVJlY2lldmVkLHNldE1lc3NhZ2VSZWNpZXZlZF09dXNlU3RhdGUobnVsbClcbmNvbnN0IFttZXNzYWdlU2VudCxzZXRNZXNzYWdlU2VudF09dXNlU3RhdGUobnVsbClcbmNvbnN0IFtjb25uZWN0ZWQsc2V0Q29ubmVjdGVkXT11c2VTdGF0ZShmYWxzZSlcbmNvbnN0IFtlcnJvcnMsc2V0RXJyb3JdPXVzZVN0YXRlKFtdKVxuICBjb25zdCAgIHNlbmRNZXNzYWdlID0gKCkgPT4ge1xuICBjb25zdCBkYXRldGltZSA9ICBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICBzb2NrZXQuZW1pdChcInRleHRfbWVzc2FnZVwiLHtcbiAgICByZWNpZXZlcjp0YXJnZXROYW1lLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2VUZXh0LFxuICAgIGRhdGV0aW1lfSk7XG4gIHNldE1lc3NhZ2VTZW50KHtyZWNpZXZlcjp0YXJnZXROYW1lLGRhdGV0aW1lLG1lc3NhZ2U6bWVzc2FnZVRleHR9KVxuICBzZXRNZXNzYWdlVGV4dCgnJylcbn1cblxuY29uc3QgaGFuZGxlTWVzc2FnZUNoYW5nZSA9KGUpPT57XG5cbnNldE1lc3NhZ2VUZXh0KGUudGFyZ2V0LnZhbHVlKVxuXG59XG5cbiAgdXNlRWZmZWN0KCgpPT57XG4gICAgaWYoc29ja2V0ICE9PW51bGwpe1xuXG4gICAgIFxuICAgICAgc29ja2V0Lm9uKFwidGV4dF9tZXNzYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbmRlciAsIG1lc3NhZ2UsIGRhdGV0aW1lIH0gPSBkYXRhO1xuICAgICAgIFxuICAgICAgc2V0TWVzc2FnZVJlY2lldmVkKHtzZW5kZXIsbWVzc2FnZSxkYXRldGltZX0pXG4gICAgICB9KTtcbiAgICAgIHNvY2tldC5vbihcImNvbm5lY3RcIiwoKT0+e1xuICAgICAgIFxuICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSlcbiAgICAgIH0pXG4gIFxuICAgICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCgpPT57XG4gICAgICAgIFxuICAgICAgICBzZXRDb25uZWN0ZWQoZmFsc2UpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywoZXJyb3IpPT57XG4gICAgICAgIHNldEVycm9yKFsuLi5lcnJvcnMsZXJyb3JdKVxuICAgICAgfSlcbiAgICB9XG5cbiAgfSlcblxuXG5cbnJldHVybiB7bWVzc2FnZVJlY2lldmVkLG1lc3NhZ2VTZW50LG1lc3NhZ2VUZXh0LHNlbmRNZXNzYWdlLGhhbmRsZU1lc3NhZ2VDaGFuZ2UsZXJyb3JzLGNvbm5lY3RlZH1cblxufVxuZXhwb3J0IGRlZmF1bHQgdXNlU29ja2V0TWVzc2FnaW5nXG5cbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IHt1c2VTdGF0ZSx1c2VFZmZlY3R9IGZyb20gJ3ByZWFjdC9ob29rcydcblxuY29uc3QgdXNlQ2hhdExvZyA9KHtuYW1lLG1lc3NhZ2VSZWNpZXZlZCxtZXNzYWdlU2VudH0pPT57XG4gIGNvbnN0IFttZXNzYWdlcyxzZXRNZXNzYWdlc109dXNlU3RhdGUoW10pXG4gIFxuICBjb25zdCBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSAobSwga2V5KSA9PiB7XG4gICAgY29uc3QgcGVyc2lzdGVkTWVzc2FnZXMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpID09PSBudWxsID8gW21dIDogWy4uLkpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSksIG1dXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShwZXJzaXN0ZWRNZXNzYWdlcykpO1xuICAgIHJldHVybiBwZXJzaXN0ZWRNZXNzYWdlc1xufVxuICAvLyBjb21wb25lbnREaWRNb3VudFxuICB1c2VFZmZlY3QoKCk9PntcbiAgICBzZXRNZXNzYWdlcyhKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpKSA9PT0gbnVsbCA/XG4gICAgIFtdIDogWy4uLkpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkpXSlcbiAgICAgXG4gIH0sW10pXG4gIC8vIHNhdmVSZW1vdGVNZXNzYWdlXG4gdXNlRWZmZWN0KCgpPT57XG4gICBpZihtZXNzYWdlUmVjaWV2ZWQhPT1udWxsKVxuICAge1xuICAgIGNvbnN0IHsgZGF0ZXRpbWUsIG1lc3NhZ2UsIHNlbmRlciB9ID0gbWVzc2FnZVJlY2lldmVkXG4gICAgY29uc3QgbG9jYWwgPSBmYWxzZVxuICBzZXRNZXNzYWdlcyhzYXZlVG9Mb2NhbFN0b3JhZ2UoIHsgbWVzc2FnZSwgZnJvbTogc2VuZGVyLCBsb2NhbCwgZGF0ZXRpbWUsIHRvOiBuYW1lIH0sbmFtZSkpXG4gICB9XG4gIFxuIH0sW21lc3NhZ2VSZWNpZXZlZF0pXG5cbiAgLy8gc2F2ZUxvY2FsTWVzc2FnZVxuICB1c2VFZmZlY3QoKCk9PntcbiAgICBpZihtZXNzYWdlU2VudCE9PW51bGwpe1xuICAgICBcbiAgICAgIGNvbnN0IHsgZGF0ZXRpbWUsIG1lc3NhZ2UsIHJlY2lldmVyIH0gPSBtZXNzYWdlU2VudFxuICAgICAgY29uc3QgbG9jYWwgPSB0cnVlXG4gICAgICBjb25zdCBmcm9tID1uYW1lXG4gICAgc2V0TWVzc2FnZXMoc2F2ZVRvTG9jYWxTdG9yYWdlKCB7IG1lc3NhZ2UsIGZyb20sIGxvY2FsLCBkYXRldGltZSwgdG86IHJlY2lldmVyIH0sbmFtZSkpXG5cbiAgICB9XG59LFttZXNzYWdlU2VudF0pXG4gXG4gIHJldHVybiB7bWVzc2FnZXN9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNoYXRMb2dcblxuIiwiLyoqXHJcbiAqIFBhcnNlcyBhbiBVUklcclxuICpcclxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcclxuXHJcbnZhciBwYXJ0cyA9IFtcclxuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcclxuICAgIHZhciBzcmMgPSBzdHIsXHJcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXHJcbiAgICAgICAgdXJpID0ge30sXHJcbiAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcclxuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVyaTtcclxufTtcclxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHQvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcblx0XHQvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG5cblx0XHQvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zdCBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuXHRcdFx0aW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdHJldHVybiB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcblx0XHRjb25zb2xlLmxvZyAmJlxuXHRcdGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uKTtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5leHBvcnQgZGVmYXVsdCBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuaW1wb3J0ICogYXMgaWVlZTc1NCBmcm9tICcuL2llZWU3NTQnXG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXknXG5cbmV4cG9ydCB2YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWVcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5leHBvcnQge19rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGh9O1xuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICByZXR1cm4gdHJ1ZTtcbiAgLy8gcm9sbHVwIGlzc3Vlc1xuICAvLyB0cnkge1xuICAvLyAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAvLyAgIGFyci5fX3Byb3RvX18gPSB7XG4gIC8vICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuICAvLyAgICAgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gIC8vICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIC8vICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICByZXR1cm4gZmFsc2VcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIC8vICAgdmFsdWU6IG51bGwsXG4gICAgLy8gICBjb25maWd1cmFibGU6IHRydWVcbiAgICAvLyB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbnZhciB3aXRoTmF0aXZlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IChvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKHdpdGhOYXRpdmVCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHNlbGZbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG4iLCIvKipcclxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcclxuICovXHJcblxyXG52YXIgQmxvYkJ1aWxkZXIgPSB0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJLaXRCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1vekJsb2JCdWlsZGVyIDogXHJcbiAgZmFsc2U7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xyXG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXHJcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcclxuICAgIHJldHVybiBiLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcclxuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XHJcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcclxuICByZXR1cm4gYXJ5Lm1hcChmdW5jdGlvbihjaHVuaykge1xyXG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XHJcblxyXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcclxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXHJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNodW5rO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICBiYi5hcHBlbmQocGFydCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJsb2IobWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLCBvcHRpb25zIHx8IHt9KTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBCbG9iQnVpbGRlckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG4gIEJsb2JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBCbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufSkoKTtcclxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGZyLnJlc3VsdCB9LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBidG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gb3B0cy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIHJlc3VsdHMgb2YgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uXG4gIHRoaXMuaXNSZWFjdE5hdGl2ZSA9IG9wdHMuaXNSZWFjdE5hdGl2ZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXHJcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcclxuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG5cclxuICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcclxuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHFzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xyXG4gIHZhciBxcnkgPSB7fTtcclxuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcclxuICB9XHJcbiAgcmV0dXJuIHFyeTtcclxufTtcclxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qIGdsb2JhbCBhdHRhY2hFdmVudCAqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSkgfHxcbiAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcbiAgb3B0cy53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gb3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnN1cHBvcnRzQmluYXJ5ICYmIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsgY2hhcnNldD1VVEYtOCcpIHtcbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09ICdudW1iZXInID8geGhyLnN0YXR1cyA6IDApO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsgY2hhcnNldD1VVEYtOCcpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIGF0dGFjaEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGVybWluYXRpb25FdmVudCA9ICdvbnBhZ2VoaWRlJyBpbiBzZWxmID8gJ3BhZ2VoaWRlJyA6ICd1bmxvYWQnO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodGVybWluYXRpb25FdmVudCwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIFVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbCBpcyBzaGlwcGVkLlxuICovXG5mdW5jdGlvbiBnbG9iICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbn1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICB2YXIgZ2xvYmFsID0gZ2xvYigpO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW8gPSAoZ2xvYmFsLl9fX2VpbyB8fCBbXSk7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge307XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbnZhciBCcm93c2VyV2ViU29ja2V0LCBOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldDtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldEltcGwgPSBCcm93c2VyV2ViU29ja2V0IHx8IE5vZGVXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPVxuICAgICAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIXRoaXMuaXNSZWFjdE5hdGl2ZVxuICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgID8gbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmkpXG4gICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0SW1wbCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldEltcGwgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmVcbiAgICA6ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbi5wb3J0XG4gICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgIDogKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlICE9PSBvcHRzLndpdGhDcmVkZW50aWFscztcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJyk7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBvciBSZWFjdE5hdGl2ZSBjbGllbnRcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmlzUmVhY3ROYXRpdmUpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCB0aGlzLndpdGhDcmVkZW50aWFscyxcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApLFxuICAgIGlzUmVhY3ROYXRpdmU6IHRoaXMuaXNSZWFjdE5hdGl2ZVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAoaW8sIG5zcCwgb3B0cykge1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZmxhZ3MgPSB7fTtcbiAgaWYgKG9wdHMgJiYgb3B0cy5xdWVyeSkge1xuICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB9XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6ICh0aGlzLmZsYWdzLmJpbmFyeSAhPT0gdW5kZWZpbmVkID8gdGhpcy5mbGFncy5iaW5hcnkgOiBoYXNCaW4oYXJncykpID8gcGFyc2VyLkJJTkFSWV9FVkVOVCA6IHBhcnNlci5FVkVOVCxcbiAgICBkYXRhOiBhcmdzXG4gIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICB0aGlzLmZsYWdzID0ge307XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnID8gcGFyc2Vxcy5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuICAgICAgZGVidWcoJ3NlbmRpbmcgY29ubmVjdCBwYWNrZXQgd2l0aCBxdWVyeSAlcycsIHF1ZXJ5KTtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVCwgcXVlcnk6IHF1ZXJ5fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IHBhY2tldC5uc3AgPT09IHRoaXMubnNwO1xuICB2YXIgcm9vdE5hbWVzcGFjZUVycm9yID0gcGFja2V0LnR5cGUgPT09IHBhcnNlci5FUlJPUiAmJiBwYWNrZXQubnNwID09PSAnLyc7XG5cbiAgaWYgKCFzYW1lTmFtZXNwYWNlICYmICFyb290TmFtZXNwYWNlRXJyb3IpIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChjb21wcmVzcykge1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBiaW5hcnkgZmxhZ1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0aGUgZW1pdHRlZCBkYXRhIGNvbnRhaW5zIGJpbmFyeVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuYmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICB0aGlzLmZsYWdzLmJpbmFyeSA9IGJpbmFyeTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IGlvIGZyb20gXCJzb2NrZXQuaW8tY2xpZW50XCI7XG5cbmNvbnN0IHVzZVNvY2tldCA9ICh7dXNlcm5hbWUscm91dGU9Jy9hbm9ueW1vdXMnLHNlcnZlclVybH0pID0+IHtcbiAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc29ja2V0RXJyb3IsIHNldFNvY2tldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUb2tlbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocm91dGUsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWUgfSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIHNldFNvY2tldChpbyhzZXJ2ZXJVcmwsIHsgcXVlcnk6IGB0b2tlbj0ke2RhdGEudG9rZW59YCB9KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZXRTb2NrZXRFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoVG9rZW4oKTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNvY2tldCAhPT0gbnVsbCkge1xuICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICBzZXRTb2NrZXRFcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHNvY2tldC5vbihcIm1lc3NhZ2VcIiwoKT0+e1xuXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW3NvY2tldF0pO1xuICByZXR1cm4geyBzb2NrZXQsIGNvbm5lY3RlZCwgc29ja2V0RXJyb3IgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVNvY2tldDtcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IHVzZVNvY2tldE1lc3NhZ2luZyBmcm9tIFwiLi91c2VTb2NrZXRNZXNzYWdpbmdcIjtcbmltcG9ydCB1c2VDaGF0TG9nIGZyb20gXCIuLi91c2VDaGF0TG9nXCI7XG5pbXBvcnQgdXNlU29ja2V0IGZyb20gXCIuL3VzZVNvY2tldFwiXG5jb25zdCB1c2VTb2NrZXRDbGllbnQgPSh7IG5hbWUsIHRhcmdldE5hbWUscm91dGUsc2VydmVyVXJsIH0pPT57XG4gICBjb25zdCB7c29ja2V0LCBjb25uZWN0ZWQsIHNvY2tldEVycm9yfSA9IHVzZVNvY2tldCh7dXNlcm5hbWU6bmFtZSxyb3V0ZSxzZXJ2ZXJVcmx9KVxuICAgIGNvbnN0IHtcbiBcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBoYW5kbGVNZXNzYWdlQ2hhbmdlLFxuICAgICAgICBtZXNzYWdlUmVjaWV2ZWQsXG4gICAgICAgIG1lc3NhZ2VTZW50LFxuICAgICAgICBtZXNzYWdlVGV4dCxcbiAgICAgICAgc2VuZE1lc3NhZ2VcbiAgICAgIH0gPSB1c2VTb2NrZXRNZXNzYWdpbmcoeyBzb2NrZXQsIHRhcmdldE5hbWUgfSk7XG4gICAgICBjb25zdCB7IG1lc3NhZ2VzIH0gPSB1c2VDaGF0TG9nKHsgbmFtZSwgbWVzc2FnZVJlY2lldmVkLCBtZXNzYWdlU2VudCB9KTtcblxuICAgICAgcmV0dXJuIHttZXNzYWdlcyxtZXNzYWdlUmVjaWV2ZWQsbWVzc2FnZVNlbnQsbWVzc2FnZVRleHQsc2VuZE1lc3NhZ2UsZXJyb3JzLGNvbm5lY3RlZCxoYW5kbGVNZXNzYWdlQ2hhbmdlfVxufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VTb2NrZXRDbGllbnQiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCBUYWJCYXIgZnJvbSBcInByZWFjdC1tYXRlcmlhbC1jb21wb25lbnRzL1RhYkJhclwiO1xuaW1wb3J0IFwicHJlYWN0LW1hdGVyaWFsLWNvbXBvbmVudHMvVGFiQmFyL3N0eWxlLmNzc1wiO1xuaW1wb3J0IFwicHJlYWN0LW1hdGVyaWFsLWNvbXBvbmVudHMvVGFicy9zdHlsZS5jc3NcIjtcblxuaW1wb3J0IENoYXRVc2VyIGZyb20gXCIuL0NoYXRVc2VyXCI7XG5pbXBvcnQgXCIuL3N0eWxlLmNzc1wiO1xuaW1wb3J0IHVzZVNvY2tldENsaWVudCBmcm9tIFwic29ja2V0LWlvLW1lc3NhZ2luZy91c2VTb2NrZXRDbGllbnRcIjtcblxuY29uc3QgQ2hhdFJvb20gPSAoKSA9PiB7XG4gIGNvbnN0IFttc2dGb3JNYXJpbywgc2V0TXNnRm9yTWFyaW9dID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFttc2dGb3JEcmFnb3MsIHNldE1zZ0ZvckRyYWdvc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3NlbGVjdGVkSXRlbSwgc2V0U2VsZWN0ZWRJdGVtXSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IHtcbiAgICBtZXNzYWdlczogbXNnTWFyaW8sXG4gICAgbWVzc2FnZVJlY2lldmVkOiBtc2dSZWNNYXJpbyxcbiAgICBtZXNzYWdlU2VudDogbXNnU250TWFyaW8sXG4gICAgbWVzc2FnZVRleHQ6IG1zZ1R4dE1hcmlvLFxuICAgIHNlbmRNZXNzYWdlOiBzZW5kTXNnTWFyaW8sXG4gICAgZXJyb3JzOiBlcnJNYXJpbyxcbiAgICBjb25uZWN0ZWQ6IGNudE1hcmlvLFxuICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U6IGhkbGVNZXNzYWdlQ2hhZ2VNYXJpbyxcbiAgICBzb2NrZXQ6IG1hcmlvU29ja2V0XG4gIH0gPSB1c2VTb2NrZXRDbGllbnQoe1xuICAgIG5hbWU6IFwibWFyaW9cIixcbiAgICB0YXJnZXROYW1lOiBcImRyYWdvc1wiLFxuICAgIHNlcnZlclVybDpSRUFDVF9BUFBfU09DS0VUX1VSTCxcbiAgICByb3V0ZTonL2Fub255bW91cydcbiAgXG4gIH0pO1xuICBjb25zdCB7XG4gICAgbWVzc2FnZXM6IG1zZ0RyYWdvcyxcbiAgICBtZXNzYWdlUmVjaWV2ZWQ6IG1zZ1JlY0RyYWdvcyxcbiAgICBtZXNzYWdlU2VudDogbXNnU250RHJhZ29zLFxuICAgIG1lc3NhZ2VUZXh0OiBtc2dUeHREcmFnb3MsXG4gICAgc2VuZE1lc3NhZ2U6IHNlbmRNc2dEcmFnb3MsXG4gICAgZXJyb3JzOiBlcnJEcmFnb3MsXG4gICAgY29ubmVjdGVkOiBjbnREcmFnb3MsXG4gICAgaGFuZGxlTWVzc2FnZUNoYW5nZTogaGRsZU1lc3NhZ2VDaGFnZURyYWdvcyxcbiAgICBzb2NrZXQ6IGRyYWdvc1NvY2tldFxuICB9ID0gdXNlU29ja2V0Q2xpZW50KHtcbiAgICBuYW1lOiBcImRyYWdvc1wiLFxuICAgIHRhcmdldE5hbWU6IFwibWFyaW9cIixcbiAgICBzZXJ2ZXJVcmw6UkVBQ1RfQVBQX1NPQ0tFVF9VUkwsXG4gICAgcm91dGU6Jy9hbm9ueW1vdXMnXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYobXNnRm9yRHJhZ29zICE9PW51bGwpXG4gICAgc2V0TXNnRm9yRHJhZ29zKHByZXZTdGF0ZSA9PiBwcmV2U3RhdGUgKyAxKTtcbiAgfSwgW21zZ1JlY0RyYWdvc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmKG1zZ0Zvck1hcmlvICE9PW51bGwpXG4gICAgc2V0TXNnRm9yTWFyaW8ocHJldlN0YXRlID0+IHByZXZTdGF0ZSArIDEpO1xuICB9LCBbbXNnUmVjTWFyaW9dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZWxlY3RlZEl0ZW0gPT09IDApIHtcbiAgICAgIHNldE1zZ0Zvck1hcmlvKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRNc2dGb3JEcmFnb3MoMCk7XG4gICAgfVxuICB9LCBbc2VsZWN0ZWRJdGVtXSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYi1iYXJcIj5cbiAgICAgICAgPGRpdj5cbiAgICAgIDxUYWJCYXI+XG4gICAgICAgIDxUYWJCYXIuVGFiIGFjdGl2ZSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZEl0ZW0oMCl9PlxuICAgICAgICAgIDxUYWJCYXIuVGFiTGFiZWw+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwifX0+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6IGNudE1hcmlvID8gXCJncmVlblwiIDogXCJvcmFuZ2VcIn19Pm1hcmlvPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjaGlwXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtc2dGb3JNYXJpbyA+IDAgPyBcImdyZWVuXCIgOiBcImRhcmtncmV5XCJcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge21zZ0Zvck1hcmlvfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvVGFiQmFyLlRhYkxhYmVsPlxuICAgICAgICA8L1RhYkJhci5UYWI+XG4gICAgICAgIDxUYWJCYXIuVGFiIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkSXRlbSgxKX0+XG4gICAgICAgICAgPFRhYkJhci5UYWJMYWJlbD5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIgfX0+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6IGNudERyYWdvcyA/IFwiZ3JlZW5cIiA6IFwib3JhbmdlXCIgfX0+XG4gICAgICAgICAgICAgICAgZHJhZ29zXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2hpcFwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbXNnRm9yRHJhZ29zID4gMCA/IFwiZ3JlZW5cIiA6IFwiZGFya2dyZXlcIlxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7bXNnRm9yRHJhZ29zfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvVGFiQmFyLlRhYkxhYmVsPlxuICAgICAgICA8L1RhYkJhci5UYWI+XG4gICAgICA8L1RhYkJhcj5cbiAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICB7c2VsZWN0ZWRJdGVtID09PSAwICYmIChcbiAgICAgICAgPENoYXRVc2VyXG4gICAgICAgICAgaGFuZGxlTWVzc2FnZUNoYW5nZT17aGRsZU1lc3NhZ2VDaGFnZU1hcmlvfVxuICAgICAgICAgIGNvbm5lY3RlZD17Y250TWFyaW99XG4gICAgICAgICAgZXJyb3JzPXtlcnJNYXJpb31cbiAgICAgICAgICBtZXNzYWdlU2VudD17bXNnU250TWFyaW99XG4gICAgICAgICAgbWVzc2FnZVRleHQ9e21zZ1R4dE1hcmlvfVxuICAgICAgICAgIG1lc3NhZ2VzPXttc2dNYXJpb31cbiAgICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1zZ01hcmlvfVxuICAgICAgICAgIG1lc3NhZ2VSZWNpZXZlZD17bXNnUmVjTWFyaW99XG4gICAgICAgICAgc29ja2V0PXtkcmFnb3NTb2NrZXR9XG4gICAgICAgICAgbmFtZT1cIm1hcmlvXCJcbiAgICAgICAgICB0YXJnZXROYW1lPVwiZHJhZ29zXCJcbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7c2VsZWN0ZWRJdGVtID09PSAxICYmIChcbiAgICAgICAgPENoYXRVc2VyXG4gICAgICAgICAgaGFuZGxlTWVzc2FnZUNoYW5nZT17aGRsZU1lc3NhZ2VDaGFnZURyYWdvc31cbiAgICAgICAgICBjb25uZWN0ZWQ9e2NudERyYWdvc31cbiAgICAgICAgICBlcnJvcnM9e2VyckRyYWdvc31cbiAgICAgICAgICBtZXNzYWdlU2VudD17bXNnU250RHJhZ29zfVxuICAgICAgICAgIG1lc3NhZ2VUZXh0PXttc2dUeHREcmFnb3N9XG4gICAgICAgICAgbWVzc2FnZXM9e21zZ0RyYWdvc31cbiAgICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1zZ0RyYWdvc31cbiAgICAgICAgICBtZXNzYWdlUmVjaWV2ZWQ9e21zZ1JlY0RyYWdvc31cbiAgICAgICAgICBzb2NrZXQ9e2RyYWdvc1NvY2tldH1cbiAgICAgICAgICBuYW1lPVwiZHJhZ29zXCJcbiAgICAgICAgICB0YXJnZXROYW1lPVwibWFyaW9cIlxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBDaGF0Um9vbTtcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuaW1wb3J0IENoYXRSb29tIGZyb20gJy4vQ2hhdFJvb20nXG5cbmNvbnN0IFNvY2tldElPTWVzc2FnaW5nID0oKT0+e1xuXG4gICAgcmV0dXJuKFxuICAgICAgPENoYXRSb29tIC8+XG4gICAgKVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldElPTWVzc2FnaW5nIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXG5cbmNvbnN0IFdlYlJUQ01lc3NhZ2luZyA9KCk9PntcblxuICAgIHJldHVybihcbiAgICAgICAgPGRpdiBzdHlsZT17e21hcmdpblRvcDoyMDB9fT5XZWJSVEMgTWVzc2FnaW5nPC9kaXY+XG4gICAgKVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFdlYlJUQ01lc3NhZ2luZyIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xuXG5jb25zdCBXZWJSVENWaWRlb0NoYXQgPSgpPT57XG5cbiAgICByZXR1cm4oXG4gICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW5Ub3A6MjAwfX0+XG4gICAgICAgICAgICBXZWJSVENWaWRlb0NoYXRcbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJSVENWaWRlb0NoYXQiXSwibmFtZXMiOlsiY3NzQ2xhc3NlcyIsIkFDVElWRSIsIkZBREUiLCJOT19UUkFOU0lUSU9OIiwic3RyaW5ncyIsIkNPTlRFTlRfU0VMRUNUT1IiLCJNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIiwiTURDRm91bmRhdGlvbiIsImRlZmF1bHRBZGFwdGVyIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCIsInNldENvbnRlbnRTdHlsZVByb3BlcnR5IiwiY29uc3RydWN0b3IiLCJhZGFwdGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRhcHRlcl8iLCJhY3RpdmF0ZSIsInByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCIsImRlYWN0aXZhdGUiLCJNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiIsImN1cnJlbnRDbGllbnRSZWN0Iiwid2lkdGhEZWx0YSIsIndpZHRoIiwieFBvc2l0aW9uIiwibGVmdCIsIk1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24iLCJNRENUYWJJbmRpY2F0b3IiLCJNRENDb21wb25lbnQiLCJhdHRhY2hUbyIsInJvb3QiLCJhcmdzIiwiY29udGVudF8iLCJpbml0aWFsaXplIiwicm9vdF8iLCJxdWVyeVNlbGVjdG9yIiwiZm91bmRhdGlvbl8iLCJnZXREZWZhdWx0Rm91bmRhdGlvbiIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInByb3AiLCJ2YWx1ZSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJjb250YWlucyIsIkFSSUFfU0VMRUNURUQiLCJSSVBQTEVfU0VMRUNUT1IiLCJUQUJfSU5ESUNBVE9SX1NFTEVDVE9SIiwiVEFCSU5ERVgiLCJJTlRFUkFDVEVEX0VWRU5UIiwiTURDVGFiRm91bmRhdGlvbiIsImhhc0NsYXNzIiwic2V0QXR0ciIsImFjdGl2YXRlSW5kaWNhdG9yIiwiZGVhY3RpdmF0ZUluZGljYXRvciIsIm5vdGlmeUludGVyYWN0ZWQiLCJnZXRPZmZzZXRMZWZ0IiwiZ2V0T2Zmc2V0V2lkdGgiLCJnZXRDb250ZW50T2Zmc2V0TGVmdCIsImdldENvbnRlbnRPZmZzZXRXaWR0aCIsImZvY3VzIiwiaGFuZGxlQ2xpY2tfIiwiaGFuZGxlQ2xpY2siLCJpc0FjdGl2ZSIsImNvbXB1dGVEaW1lbnNpb25zIiwicm9vdFdpZHRoIiwicm9vdExlZnQiLCJjb250ZW50V2lkdGgiLCJjb250ZW50TGVmdCIsInJvb3RSaWdodCIsImNvbnRlbnRSaWdodCIsIk1EQ1RhYiIsInJpcHBsZV8iLCJ0YWJJbmRpY2F0b3JfIiwicmlwcGxlRmFjdG9yeSIsImVsIiwiZm91bmRhdGlvbiIsIk1EQ1JpcHBsZSIsInRhYkluZGljYXRvckZhY3RvcnkiLCJyaXBwbGVTdXJmYWNlIiwicmlwcGxlQWRhcHRlciIsImNyZWF0ZUFkYXB0ZXIiLCJ1cGRhdGVDc3NWYXJpYWJsZSIsInZhck5hbWUiLCJyaXBwbGVGb3VuZGF0aW9uIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsInRhYkluZGljYXRvckVsZW1lbnQiLCJpbml0aWFsU3luY1dpdGhET00iLCJiaW5kIiwibGlzdGVuIiwiZGVzdHJveSIsInVubGlzdGVuIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsImVtaXQiLCJ0YWIiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJhY3RpdmUiLCJjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCIsIkFOSU1BVElORyIsIlNDUk9MTF9URVNUIiwiU0NST0xMX0FSRUFfU0NST0xMIiwiQVJFQV9TRUxFQ1RPUiIsIk1EQ1RhYlNjcm9sbGVyUlRMIiwiZ2V0U2Nyb2xsUG9zaXRpb25SVEwiLCJ0cmFuc2xhdGVYIiwic2Nyb2xsVG9SVEwiLCJzY3JvbGxYIiwiaW5jcmVtZW50U2Nyb2xsUlRMIiwiZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24iLCJNRENUYWJTY3JvbGxlclJUTERlZmF1bHQiLCJjdXJyZW50U2Nyb2xsTGVmdCIsImdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0IiwicmlnaHQiLCJjYWxjdWxhdGVTY3JvbGxFZGdlc18iLCJNYXRoIiwicm91bmQiLCJlZGdlcyIsImNsYW1wZWRTY3JvbGxMZWZ0IiwiY2xhbXBTY3JvbGxWYWx1ZV8iLCJmaW5hbFNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsRGVsdGEiLCJnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgiLCJnZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGgiLCJtaW4iLCJtYXgiLCJNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlIiwiTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIiwiTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uIiwiZXZlbnRUYXJnZXRNYXRjaGVzU2VsZWN0b3IiLCJhZGRTY3JvbGxBcmVhQ2xhc3MiLCJzZXRTY3JvbGxBcmVhU3R5bGVQcm9wZXJ0eSIsInNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5IiwiZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWUiLCJzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCIsImNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCIsImNvbXB1dGVTY3JvbGxDb250ZW50Q2xpZW50UmVjdCIsImNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0IiwiaXNBbmltYXRpbmdfIiwicnRsU2Nyb2xsZXJJbnN0YW5jZV8iLCJpbml0IiwiaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImdldFNjcm9sbFBvc2l0aW9uIiwiaXNSVExfIiwiY29tcHV0ZUN1cnJlbnRTY3JvbGxQb3NpdGlvblJUTF8iLCJjdXJyZW50VHJhbnNsYXRlWCIsImNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXyIsInNjcm9sbExlZnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsInN0b3BTY3JvbGxBbmltYXRpb25fIiwiaGFuZGxlVHJhbnNpdGlvbkVuZCIsImV2dCIsInRhcmdldCIsImluY3JlbWVudFNjcm9sbCIsInNjcm9sbFhJbmNyZW1lbnQiLCJpbmNyZW1lbnRTY3JvbGxSVExfIiwiaW5jcmVtZW50U2Nyb2xsXyIsInNjcm9sbFRvIiwic2Nyb2xsVG9SVExfIiwic2Nyb2xsVG9fIiwiZ2V0UlRMU2Nyb2xsZXIiLCJydGxTY3JvbGxlckZhY3RvcnlfIiwidHJhbnNmb3JtVmFsdWUiLCJyZXN1bHRzIiwiZXhlYyIsInBhcnRzIiwic3BsaXQiLCJwYXJzZUZsb2F0IiwiY3VycmVudFNjcm9sbFgiLCJzYWZlU2Nyb2xsWCIsImFuaW1hdGVfIiwiYW5pbWF0aW9uIiwidGFyZ2V0U2Nyb2xsWCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImN1cnJlbnRTY3JvbGxQb3NpdGlvbiIsImdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uXyIsImluaXRpYWxTY3JvbGxMZWZ0IiwibmV3U2Nyb2xsTGVmdCIsInJvb3RDbGllbnRSZWN0IiwiY29udGVudENsaWVudFJlY3QiLCJyaWdodEVkZ2VEZWx0YSIsImhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfIiwiZG9jdW1lbnRPYmoiLCJzaG91bGRDYWNoZVJlc3VsdCIsImNyZWF0ZUVsZW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJvZmZzZXRIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJyZW1vdmVDaGlsZCIsImdldE1hdGNoZXNQcm9wZXJ0eSIsIkhUTUxFbGVtZW50UHJvdG90eXBlIiwiZmlsdGVyIiwicCIsInBvcCIsIk1EQ1RhYlNjcm9sbGVyIiwiYXJlYV8iLCJoYW5kbGVJbnRlcmFjdGlvbl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kXyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0VGFyZ2V0Iiwic2VsZWN0b3IiLCJNQVRDSEVTIiwidXRpbCIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwicHJvcE5hbWUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImRvY3VtZW50IiwiZ2V0U2Nyb2xsQ29udGVudFdpZHRoIiwiVEFCX0FDVElWQVRFRF9FVkVOVCIsIlRBQl9TQ1JPTExFUl9TRUxFQ1RPUiIsIlRBQl9TRUxFQ1RPUiIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiRU5EX0tFWSIsIkhPTUVfS0VZIiwiRU5URVJfS0VZIiwiU1BBQ0VfS0VZIiwibnVtYmVycyIsIkVYVFJBX1NDUk9MTF9BTU9VTlQiLCJBUlJPV19MRUZUX0tFWUNPREUiLCJBUlJPV19SSUdIVF9LRVlDT0RFIiwiRU5EX0tFWUNPREUiLCJIT01FX0tFWUNPREUiLCJFTlRFUl9LRVlDT0RFIiwiU1BBQ0VfS0VZQ09ERSIsIkFDQ0VQVEFCTEVfS0VZUyIsIlNldCIsIktFWUNPREVfTUFQIiwiTWFwIiwic2V0IiwiTURDVGFiQmFyRm91bmRhdGlvbiIsImlzUlRMIiwic2V0QWN0aXZlVGFiIiwiYWN0aXZhdGVUYWJBdEluZGV4IiwiZGVhY3RpdmF0ZVRhYkF0SW5kZXgiLCJmb2N1c1RhYkF0SW5kZXgiLCJnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleCIsImdldFRhYkRpbWVuc2lvbnNBdEluZGV4IiwiZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCIsImdldEZvY3VzZWRUYWJJbmRleCIsImdldEluZGV4T2ZUYWIiLCJnZXRUYWJMaXN0TGVuZ3RoIiwibm90aWZ5VGFiQWN0aXZhdGVkIiwidXNlQXV0b21hdGljQWN0aXZhdGlvbl8iLCJzZXRVc2VBdXRvbWF0aWNBY3RpdmF0aW9uIiwidXNlQXV0b21hdGljQWN0aXZhdGlvbiIsImFjdGl2YXRlVGFiIiwiaW5kZXgiLCJwcmV2aW91c0FjdGl2ZUluZGV4IiwiaW5kZXhJc0luUmFuZ2VfIiwic2Nyb2xsSW50b1ZpZXciLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiZ2V0S2V5RnJvbUV2ZW50XyIsInVuZGVmaW5lZCIsImlzQWN0aXZhdGlvbktleV8iLCJwcmV2ZW50RGVmYXVsdCIsImRldGVybWluZVRhcmdldEZyb21LZXlfIiwiZm9jdXNlZFRhYkluZGV4IiwiaGFuZGxlVGFiSW50ZXJhY3Rpb24iLCJkZXRhaWwiLCJzY3JvbGxJbnRvVmlld1JUTF8iLCJzY3JvbGxJbnRvVmlld18iLCJvcmlnaW4iLCJtYXhJbmRleCIsInNob3VsZEdvVG9FbmQiLCJzaG91bGREZWNyZW1lbnQiLCJzaG91bGRJbmNyZW1lbnQiLCJjYWxjdWxhdGVTY3JvbGxJbmNyZW1lbnRfIiwibmV4dEluZGV4Iiwic2Nyb2xsUG9zaXRpb24iLCJiYXJXaWR0aCIsIm5leHRUYWJEaW1lbnNpb25zIiwicmVsYXRpdmVDb250ZW50TGVmdCIsInJlbGF0aXZlQ29udGVudFJpZ2h0IiwibGVmdEluY3JlbWVudCIsInJpZ2h0SW5jcmVtZW50IiwiY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyIsInNjcm9sbENvbnRlbnRXaWR0aCIsImZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZV8iLCJ0YWJEaW1lbnNpb25zIiwicmVsYXRpdmVSb290TGVmdCIsInJlbGF0aXZlUm9vdFJpZ2h0IiwicmVsYXRpdmVSb290RGVsdGEiLCJsZWZ0RWRnZUlzQ2xvc2VyIiwicmlnaHRFZGdlSXNDbG9zZXIiLCJmaW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VSVExfIiwicm9vdERlbHRhIiwiaGFzIiwiZ2V0Iiwia2V5Q29kZSIsInNjcm9sbEluY3JlbWVudCIsInNjcm9sbFdpZHRoIiwiTURDVGFiQmFyIiwidGFiTGlzdF8iLCJ0YWJGYWN0b3J5XyIsInRhYlNjcm9sbGVyXyIsInRhYlNjcm9sbGVyRmFjdG9yeV8iLCJoYW5kbGVUYWJJbnRlcmFjdGlvbl8iLCJoYW5kbGVLZXlEb3duXyIsInRhYkZhY3RvcnkiLCJ0YWJTY3JvbGxlckZhY3RvcnkiLCJnZXRUYWJFbGVtZW50c18iLCJtYXAiLCJ0YWJTY3JvbGxlckVsZW1lbnQiLCJpIiwibGVuZ3RoIiwiZm9yRWFjaCIsImNsaWVudFJlY3QiLCJ0YWJFbGVtZW50cyIsImFjdGl2ZUVsZW1lbnQiLCJpbmRleE9mIiwidGFiVG9GaW5kIiwic2xpY2UiLCJjYWxsIiwicXVlcnlTZWxlY3RvckFsbCIsIlRhYiIsIm1kY05vdGlmeVByb3BzIiwiY2xhc3MiLCJEYXRlTGluZWJyZWFrIiwiZGF0ZXRpbWUiLCJkaXNwbGF5IiwiZmxleCIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk1lc3NhZ2VBbGlnbmVyIiwiY2hpbGRyZW4iLCJzaWRlIiwiYWxpZ25tZW50IiwianVzdGlmeUNvbnRlbnQiLCJNZXNzYWdlVmlldyIsIm1lc3NhZ2UiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYWRkaW5nIiwibWFyZ2luIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwibWF4V2lkdGgiLCJ3b3JkV3JhcCIsIndvcmRCcmVhayIsIm1pbldpZHRoIiwiZm9udFNpemUiLCJwYWRkaW5nVG9wIiwidGV4dEFsaWduIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiU3Vic2VxdWVudE1lc3NhZ2UiLCJhbGlnbkl0ZW1zIiwibWFyZ2luTGVmdCIsIk1lc3NhZ2UiLCJoZWlnaHQiLCJjb2xvciIsIk1lc3NhZ2VBdmF0YXIiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsIkZpcnN0TWVzc2FnZSIsImxvY2FsIiwiTWVzc2FnZU9iamVjdE1hcHB0ZXIiLCJwcm9wcyIsIm9yZGVyIiwiZGF0ZVNwYWNlIiwidXNlTWVzc2FnZVNvcnRlciIsIm1lc3NhZ2VzIiwidXNlU3RhdGUiLCJzb3J0ZWRNZXNzYWdlcyIsInNldFNvcnRlZE1lc3NhZ2VzIiwidXNlRWZmZWN0Iiwic29ydCIsImEiLCJiIiwidXNlTWVzc2FnZXNNYXBwZXIiLCJtYXBwZWRNZXNzYWdlcyIsInNldE1hcHBlZE1lc3NhZ2VzIiwibWFwTWVzc2FnZXMiLCJsb2NhbFNpZGUiLCJyZW1vdGVTaWRlIiwiZW1haWwiLCJmcm9tIiwibGFzdERhdGV0aW1lIiwibSIsImdldERhdGUiLCJfZXh0ZW5kcyIsIm1vZHVsZSIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiYXBwbHkiLCJNZXNzYWdlQ29sbGVjdGlvblZpZXciLCJNZXNzYWdlT2JqZWN0TWFwcGVyIiwiTWVzc2FnZVZpZXdTY3JvbGxlciIsInRyYW5zZm9ybSIsIm92ZXJmbG93IiwiTWVzc2FnZUVkaXRvckRpc3BsYXllciIsIm9uTWVzc2FnZUNoYW5nZSIsInNlbmRNZXNzYWdlIiwiaWQiLCJkaXNhYmxlZCIsIk1lc3NhZ2VzRGlzcGxheWVyIiwic29ja2V0IiwibWVzc2FnZVRleHQiLCJoYW5kbGVNZXNzYWdlQ2hhbmdlIiwidXNlTWVzc2FnZU1hcHBlciIsIkNoYXRVc2VyIiwibmFtZSIsInRhcmdldE5hbWUiLCJlcnJvcnMiLCJNZXNzYWdlRGlzcGxheWVyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiYXJyIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyMiIsIl9pdGVyYWJsZVRvQXJyYXkiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0b1N0cmluZyIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIl90b0NvbnN1bWFibGVBcnJheSIsImFycmF5V2l0aG91dEhvbGVzIiwiaXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVTcHJlYWQiLCJ1c2VTb2NrZXRNZXNzYWdpbmciLCJzZXRNZXNzYWdlVGV4dCIsIm1lc3NhZ2VSZWNpZXZlZCIsInNldE1lc3NhZ2VSZWNpZXZlZCIsIm1lc3NhZ2VTZW50Iiwic2V0TWVzc2FnZVNlbnQiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJzZXRFcnJvciIsImdldFRpbWUiLCJyZWNpZXZlciIsImUiLCJvbiIsImRhdGEiLCJzZW5kZXIiLCJlcnJvciIsInVzZUNoYXRMb2ciLCJzZXRNZXNzYWdlcyIsInNhdmVUb0xvY2FsU3RvcmFnZSIsInBlcnNpc3RlZE1lc3NhZ2VzIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ0byIsInJlIiwicGFyc2V1cmkiLCJzdHIiLCJzcmMiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidXJpIiwiaG9zdCIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJzIiwiaCIsImQiLCJ3IiwieSIsInZhbCIsIm9wdGlvbnMiLCJ0eXBlIiwiaXNGaW5pdGUiLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwiRXJyb3IiLCJTdHJpbmciLCJtYXRjaCIsIm4iLCJ0b0xvd2VyQ2FzZSIsIm1zIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSQkMCIsImtleXMiLCJpbnN0YW5jZXMiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJwcmV2VGltZSIsInNlbGYiLCJjdXJyIiwiTnVtYmVyIiwiZGlmZiIsInByZXYiLCJ1bnNoaWZ0IiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwidXNlQ29sb3JzIiwiZXh0ZW5kIiwicHVzaCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwibmFtZXNwYWNlcyIsInNhdmUiLCJsZW4iLCJSZWdFeHAiLCJzdWJzdHIiLCJpbnN0YW5jZSIsInRvTmFtZXNwYWNlIiwiam9pbiIsInRlc3QiLCJyZWdleHAiLCJzdGFjayIsImxvYWQiLCJleHBvcnRzIiwibG9jYWxzdG9yYWdlIiwicHJvY2VzcyIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRvY3VtZW50RWxlbWVudCIsIldlYmtpdEFwcGVhcmFuY2UiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCIkMSIsImMiLCJsYXN0QyIsInN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiciIsIkRFQlVHIiwiaiIsInYiLCJ1cmwiLCJsb2MiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiY2hhckF0IiwicG9ydCIsInBhdGgiLCJpcHY2IiwiaHJlZiIsImlzTmFOIiwiZmxvb3IiLCJjZWlsIiwiY2hyb21lIiwiZXJyIiwiRnVuY3Rpb24iLCJFbWl0dGVyIiwibWl4aW4iLCJldmVudCIsImZuIiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImNhbGxiYWNrcyIsImNiIiwibGlzdGVuZXJzIiwiaGFzTGlzdGVuZXJzIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImluaXRlZCIsImNvZGUiLCJ0b0J5dGVBcnJheSIsImI2NCIsImwiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0IiwiZnJvbUJ5dGVBcnJheSIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJyZWFkIiwiYnVmZmVyIiwib2Zmc2V0IiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJJbmZpbml0eSIsInBvdyIsIndyaXRlIiwicnQiLCJMTjIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIkJ1ZmZlciIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJrTWF4TGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJfX3Byb3RvX18iLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImJ5dGVMZW5ndGgiLCJhY3R1YWwiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJieXRlT2Zmc2V0IiwiaW50ZXJuYWxJc0J1ZmZlciIsImNvcHkiLCJpc25hbiIsImlzQnVmZmVyIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIngiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsInRvSlNPTiIsIl9hcnIiLCJiYXNlNjQiLCJyZXMiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwiZnJvbUNoYXJDb2RlIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInN1YmFycmF5Iiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJpZWVlNzU0IiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsImRzdCIsImlzRmFzdEJ1ZmZlciIsImlzU2xvd0J1ZmZlciIsImlzQnVmIiwid2l0aE5hdGl2ZUJ1ZmZlciIsIndpdGhOYXRpdmVBcnJheUJ1ZmZlciIsIndpdGhOYXRpdmVCbG9iIiwiQmxvYiIsIndpdGhOYXRpdmVGaWxlIiwiRmlsZSIsInBhY2tldCIsImJ1ZmZlcnMiLCJwYWNrZXREYXRhIiwicGFjayIsIl9kZWNvbnN0cnVjdFBhY2tldCIsImF0dGFjaG1lbnRzIiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJuZXdEYXRhIiwiX3JlY29uc3RydWN0UGFja2V0IiwiY2FsbGJhY2siLCJfcmVtb3ZlQmxvYnMiLCJjdXJLZXkiLCJjb250YWluaW5nT2JqZWN0IiwicGVuZGluZ0Jsb2JzIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJibG9ibGVzc0RhdGEiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIkVuY29kZXIiLCJEZWNvZGVyIiwiRVJST1JfUEFDS0VUIiwiRVJST1IiLCJlbmNvZGUiLCJCSU5BUllfRVZFTlQiLCJCSU5BUllfQUNLIiwiZW5jb2RlQXNCaW5hcnkiLCJlbmNvZGVBc1N0cmluZyIsIm5zcCIsInBheWxvYWQiLCJ0cnlTdHJpbmdpZnkiLCJ3cml0ZUVuY29kaW5nIiwiZGVjb25zdHJ1Y3Rpb24iLCJiaW5hcnkiLCJkZWNvbnN0cnVjdFBhY2tldCIsInJlbW92ZUJsb2JzIiwicmVjb25zdHJ1Y3RvciIsImRlY29kZVN0cmluZyIsIkJpbmFyeVJlY29uc3RydWN0b3IiLCJyZWNvblBhY2siLCJ0YWtlQmluYXJ5RGF0YSIsInR5cGVzIiwibmV4dCIsInRyeVBhcnNlIiwiaXNQYXlsb2FkVmFsaWQiLCJmaW5pc2hlZFJlY29uc3RydWN0aW9uIiwiYmluRGF0YSIsInJlY29uc3RydWN0UGFja2V0IiwibXNnIiwiWE1MSHR0cFJlcXVlc3QiLCJvcHRzIiwieGRvbWFpbiIsInhzY2hlbWUiLCJlbmFibGVzWERSIiwiaGFzQ09SUyIsIlhEb21haW5SZXF1ZXN0IiwiaGFzQmluYXJ5IiwiYXJyYXlidWZmZXIiLCJhYnYiLCJpaSIsImFmdGVyIiwiY291bnQiLCJlcnJfY2IiLCJiYWlsIiwibm9vcCIsInByb3h5Iiwic3RyaW5nRnJvbUNoYXJDb2RlIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJjaGVja1NjYWxhclZhbHVlIiwic3RyaWN0IiwiY3JlYXRlQnl0ZSIsInNoaWZ0IiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwidXRmOGVuY29kZSIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInV0ZjhkZWNvZGUiLCJ2ZXJzaW9uIiwiZGVjb2RlIiwiY2hhcnMiLCJidWZmZXJMZW5ndGgiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJibG9iU3VwcG9ydGVkIiwiYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3IiwiYmxvYkJ1aWxkZXJTdXBwb3J0ZWQiLCJhcHBlbmQiLCJnZXRCbG9iIiwibWFwQXJyYXlCdWZmZXJWaWV3cyIsImFyeSIsImNodW5rIiwiQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvciIsImJiIiwicGFydCIsIkJsb2JDb25zdHJ1Y3RvciIsImJhc2U2NGVuY29kZXIiLCJpc0FuZHJvaWQiLCJpc1BoYW50b21KUyIsImRvbnRTZW5kQmxvYnMiLCJwYWNrZXRzIiwib3BlbiIsImNsb3NlIiwicGluZyIsInBvbmciLCJ1cGdyYWRlIiwicGFja2V0c2xpc3QiLCJzdXBwb3J0c0JpbmFyeSIsImVuY29kZUFycmF5QnVmZmVyIiwiZW5jb2RlQmxvYiIsImVuY29kZUJhc2U2NE9iamVjdCIsImVuY29kZWQiLCJ1dGY4IiwiZW5jb2RlQmFzZTY0UGFja2V0IiwiY29udGVudEFycmF5IiwicmVzdWx0QnVmZmVyIiwiZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIiLCJmciIsImVuY29kZVBhY2tldCIsImJsb2IiLCJyZWFkQXNEYXRhVVJMIiwiYjY0ZGF0YSIsInR5cGVkIiwiYmFzaWMiLCJidG9hIiwiYmluYXJ5VHlwZSIsImRlY29kZUJhc2U2NFBhY2tldCIsInRyeURlY29kZSIsImFzQXJyYXkiLCJyZXN0Iiwic2xpY2VCdWZmZXIiLCJpc0JpbmFyeSIsImVuY29kZVBheWxvYWRBc0Jsb2IiLCJlbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciIsInNldExlbmd0aEhlYWRlciIsImVuY29kZU9uZSIsImRvbmVDYWxsYmFjayIsImVhY2giLCJkb25lIiwiZWFjaFdpdGhJbmRleCIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsImNociIsImRlY29kZVBhY2tldCIsImVuY29kZWRQYWNrZXRzIiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHRBcnJheSIsImJ1ZmZlckluZGV4IiwiaXNTdHJpbmciLCJhYiIsInZpZXciLCJsZW5TdHIiLCJiaW5hcnlJZGVudGlmaWVyIiwibGVuZ3RoQXJ5IiwiYnVmZmVyVGFpbCIsInRhaWxBcnJheSIsIm1zZ0xlbmd0aCIsInRvdGFsIiwiVHJhbnNwb3J0IiwiaG9zdG5hbWUiLCJzZWN1cmUiLCJxdWVyeSIsInRpbWVzdGFtcFBhcmFtIiwidGltZXN0YW1wUmVxdWVzdHMiLCJyZWFkeVN0YXRlIiwiYWdlbnQiLCJ3aXRoQ3JlZGVudGlhbHMiLCJwZngiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImZvcmNlTm9kZSIsImlzUmVhY3ROYXRpdmUiLCJleHRyYUhlYWRlcnMiLCJsb2NhbEFkZHJlc3MiLCJvbkVycm9yIiwiZGVzYyIsImRlc2NyaXB0aW9uIiwiZG9PcGVuIiwiZG9DbG9zZSIsIm9uQ2xvc2UiLCJzZW5kIiwib25PcGVuIiwib25EYXRhIiwicGFyc2VyIiwib25QYWNrZXQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxcyIsInFyeSIsInBhaXJzIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImFscGhhYmV0Iiwic2VlZCIsImRlY29kZWQiLCJ5ZWFzdCIsIm5vdyIsIlBvbGxpbmciLCJoYXNYSFIyIiwicmVxdWlyZSQkMSIsInhociIsInJlc3BvbnNlVHlwZSIsImZvcmNlQmFzZTY0IiwiaW5oZXJpdCIsInBvbGwiLCJwYXVzZSIsIm9uUGF1c2UiLCJwb2xsaW5nIiwiZG9Qb2xsIiwiZGVjb2RlUGF5bG9hZCIsImNhbGxiYWNrZm4iLCJlbmNvZGVQYXlsb2FkIiwiZG9Xcml0ZSIsInNjaGVtYSIsInNpZCIsInBhcnNlcXMiLCJYSFIiLCJSZXF1ZXN0IiwiZW1wdHkiLCJyZXF1ZXN0VGltZW91dCIsImlzU1NMIiwieGQiLCJ4cyIsInJlcXVlc3QiLCJyZXEiLCJtZXRob2QiLCJzZW5kWGhyIiwicG9sbFhociIsImFzeW5jIiwiY3JlYXRlIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsInRpbWVvdXQiLCJoYXNYRFIiLCJvbkxvYWQiLCJvbmVycm9yIiwicmVzcG9uc2VUZXh0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiY29udGVudFR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsInN0YXR1cyIsInNldFRpbWVvdXQiLCJyZXF1ZXN0c0NvdW50IiwicmVxdWVzdHMiLCJvblN1Y2Nlc3MiLCJjbGVhbnVwIiwiZnJvbUVycm9yIiwiYWJvcnQiLCJyZXNwb25zZSIsImF0dGFjaEV2ZW50IiwidW5sb2FkSGFuZGxlciIsInRlcm1pbmF0aW9uRXZlbnQiLCJKU09OUFBvbGxpbmciLCJyTmV3bGluZSIsInJFc2NhcGVkTmV3bGluZSIsImdsb2IiLCJfX19laW8iLCJzY3JpcHQiLCJwYXJlbnROb2RlIiwiZm9ybSIsImlmcmFtZSIsImluc2VydEF0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJoZWFkIiwiaXNVQWdlY2tvIiwiYXJlYSIsImlmcmFtZUlkIiwicG9zaXRpb24iLCJ0b3AiLCJhY3Rpb24iLCJjb21wbGV0ZSIsImluaXRJZnJhbWUiLCJodG1sIiwic3VibWl0IiwiQnJvd3NlcldlYlNvY2tldCIsIk5vZGVXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXRJbXBsIiwiV1MiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsInVzaW5nQnJvd3NlcldlYlNvY2tldCIsInByb3RvY29scyIsImNoZWNrIiwiaGVhZGVycyIsIndzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ub3BlbiIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJldiIsImNvbXByZXNzIiwidGhyZXNob2xkIiwid2Vic29ja2V0IiwianNvbnAiLCJmb3JjZUpTT05QIiwiSlNPTlAiLCJTb2NrZXQiLCJ0cmFuc3BvcnRzIiwidHJhbnNwb3J0T3B0aW9ucyIsIndyaXRlQnVmZmVyIiwicHJldkJ1ZmZlckxlbiIsInBvbGljeVBvcnQiLCJyZW1lbWJlclVwZ3JhZGUiLCJvbmx5QmluYXJ5VXBncmFkZXMiLCJwcm9kdWN0IiwidXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbFRpbWVyIiwicGluZ1RpbWVvdXRUaW1lciIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsImNyZWF0ZVRyYW5zcG9ydCIsImNsb25lIiwiRUlPIiwidHJhbnNwb3J0IiwibyIsInNldFRyYW5zcG9ydCIsIm9uRHJhaW4iLCJwcm9iZSIsImZhaWxlZCIsIm9uVHJhbnNwb3J0T3BlbiIsInVwZ3JhZGVMb3Nlc0JpbmFyeSIsInVwZ3JhZGluZyIsImZsdXNoIiwiZnJlZXplVHJhbnNwb3J0Iiwib25UcmFuc3BvcnRDbG9zZSIsIm9udXBncmFkZSIsIm9uSGFuZHNoYWtlIiwic2V0UGluZyIsImZpbHRlclVwZ3JhZGVzIiwib25IZWFydGJlYXQiLCJjbGVhclRpbWVvdXQiLCJzZW5kUGFja2V0Iiwid2FpdEZvclVwZ3JhZGUiLCJjbGVhbnVwQW5kQ2xvc2UiLCJyZWFzb24iLCJmaWx0ZXJlZFVwZ3JhZGVzIiwidG9BcnJheSIsImV2ZW50cyIsImNvbm5lY3QiLCJjb25uZWN0X2Vycm9yIiwiY29ubmVjdF90aW1lb3V0IiwiY29ubmVjdGluZyIsImRpc2Nvbm5lY3QiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfYXR0ZW1wdCIsInJlY29ubmVjdF9mYWlsZWQiLCJyZWNvbm5lY3RfZXJyb3IiLCJyZWNvbm5lY3RpbmciLCJpbyIsImpzb24iLCJpZHMiLCJhY2tzIiwicmVjZWl2ZUJ1ZmZlciIsInNlbmRCdWZmZXIiLCJkaXNjb25uZWN0ZWQiLCJmbGFncyIsImF1dG9Db25uZWN0Iiwic3ViRXZlbnRzIiwic3VicyIsImhhc0JpbiIsIkVWRU5UIiwiQ09OTkVDVCIsIm9ucGFja2V0Iiwic2FtZU5hbWVzcGFjZSIsInJvb3ROYW1lc3BhY2VFcnJvciIsIm9uY29ubmVjdCIsIm9uZXZlbnQiLCJBQ0siLCJvbmFjayIsIkRJU0NPTk5FQ1QiLCJvbmRpc2Nvbm5lY3QiLCJhY2siLCJzZW50IiwiZW1pdEJ1ZmZlcmVkIiwiQmFja29mZiIsImZhY3RvciIsImppdHRlciIsImF0dGVtcHRzIiwiZHVyYXRpb24iLCJyYW5kIiwicmFuZG9tIiwiZGV2aWF0aW9uIiwicmVzZXQiLCJzZXRNaW4iLCJzZXRNYXgiLCJzZXRKaXR0ZXIiLCJNYW5hZ2VyIiwibnNwcyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJhbmRvbWl6YXRpb25GYWN0b3IiLCJiYWNrb2ZmIiwibGFzdFBpbmciLCJwYWNrZXRCdWZmZXIiLCJfcGFyc2VyIiwiZW5jb2RlciIsImRlY29kZXIiLCJlbWl0QWxsIiwidXBkYXRlU29ja2V0SWRzIiwiZ2VuZXJhdGVJZCIsImVuZ2luZSIsIl9yZWNvbm5lY3Rpb24iLCJfcmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJfcmVjb25uZWN0aW9uRGVsYXkiLCJfcmFuZG9taXphdGlvbkZhY3RvciIsIl9yZWNvbm5lY3Rpb25EZWxheU1heCIsIl90aW1lb3V0IiwibWF5YmVSZWNvbm5lY3RPbk9wZW4iLCJlaW8iLCJza2lwUmVjb25uZWN0Iiwib3BlblN1YiIsImVycm9yU3ViIiwidGltZXIiLCJvbnBpbmciLCJvbnBvbmciLCJvbmRhdGEiLCJvbmRlY29kZWQiLCJvbkNvbm5lY3RpbmciLCJwcm9jZXNzUGFja2V0UXVldWUiLCJzdWJzTGVuZ3RoIiwiZGVsYXkiLCJvbnJlY29ubmVjdCIsImF0dGVtcHQiLCJjYWNoZSIsIm5ld0Nvbm5lY3Rpb24iLCJmb3JjZU5ldyIsIm11bHRpcGxleCIsInVzZVNvY2tldCIsInVzZXJuYW1lIiwicm91dGUiLCJzZXJ2ZXJVcmwiLCJzZXRTb2NrZXQiLCJzb2NrZXRFcnJvciIsInNldFNvY2tldEVycm9yIiwiZmV0Y2hUb2tlbiIsImZldGNoIiwidG9rZW4iLCJ1c2VTb2NrZXRDbGllbnQiLCJDaGF0Um9vbSIsIm1zZ0Zvck1hcmlvIiwic2V0TXNnRm9yTWFyaW8iLCJtc2dGb3JEcmFnb3MiLCJzZXRNc2dGb3JEcmFnb3MiLCJzZWxlY3RlZEl0ZW0iLCJzZXRTZWxlY3RlZEl0ZW0iLCJtc2dNYXJpbyIsIm1zZ1JlY01hcmlvIiwibXNnU250TWFyaW8iLCJtc2dUeHRNYXJpbyIsInNlbmRNc2dNYXJpbyIsImVyck1hcmlvIiwiY250TWFyaW8iLCJoZGxlTWVzc2FnZUNoYWdlTWFyaW8iLCJtYXJpb1NvY2tldCIsIm1zZ0RyYWdvcyIsIm1zZ1JlY0RyYWdvcyIsIm1zZ1NudERyYWdvcyIsIm1zZ1R4dERyYWdvcyIsInNlbmRNc2dEcmFnb3MiLCJlcnJEcmFnb3MiLCJjbnREcmFnb3MiLCJoZGxlTWVzc2FnZUNoYWdlRHJhZ29zIiwiZHJhZ29zU29ja2V0IiwicHJldlN0YXRlIiwiU29ja2V0SU9NZXNzYWdpbmciLCJXZWJSVENNZXNzYWdpbmciLCJtYXJnaW5Ub3AiLCJXZWJSVENWaWRlb0NoYXQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7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

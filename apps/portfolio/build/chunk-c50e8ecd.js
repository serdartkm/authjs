import { q as MDCRipple, A as MDCRippleFoundation, a as createCommonjsModule, b as _interopRequireDefault, l as require$$0, c as require$$1, d as require$$0$1, e as require$$2, f as require$$3, g as require$$4, h as require$$5, j as _preact, k as unwrapExports, o as styleInject, p as h, v, w as _slicedToArray, z as p, u as commonjsGlobal } from './chunk-f15771b5.js';
import { a as process, b as global$1 } from './index-dddac872.js';
import { a as _regeneratorRuntime } from './chunk-1296537a.js';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent(root, new MDCFoundation());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$1 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$1 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$1(root, new MDCFoundation$1());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$2 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$2 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$2(root, new MDCFoundation$2());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  ACTIVE: 'mdc-tab-indicator--active',
  FADE: 'mdc-tab-indicator--fade',
  NO_TRANSITION: 'mdc-tab-indicator--no-transition'
};
/** @enum {string} */

const strings = {
  CONTENT_SELECTOR: '.mdc-tab-indicator__content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
 * @abstract
 */

class MDCTabIndicatorFoundation extends MDCFoundation$2 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }
  /** @return enum {string} */


  static get strings() {
    return strings;
  }
  /**
   * @see MDCTabIndicatorAdapter for typing information
   * @return {!MDCTabIndicatorAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabIndicatorAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        computeContentClientRect: () => {},
        setContentStyleProperty: () => {}
      }
    );
  }
  /** @param {!MDCTabIndicatorAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter));
  }
  /** @return {!ClientRect} */


  computeContentClientRect() {
    return this.adapter_.computeContentClientRect();
  }
  /**
   * Activates the indicator
   * @param {!ClientRect=} previousIndicatorClientRect
   * @abstract
   */


  activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

  /** @abstract */


  deactivate() {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCSlidingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  /** @param {!ClientRect=} previousIndicatorClientRect */
  activate(previousIndicatorClientRect) {
    // Early exit if no indicator is present to handle cases where an indicator
    // may be activated without a prior indicator state
    if (!previousIndicatorClientRect) {
      this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
      return;
    } // This animation uses the FLIP approach. You can read more about it at the link below:
    // https://aerotwist.com/blog/flip-your-animations/
    // Calculate the dimensions based on the dimensions of the previous indicator


    const currentClientRect = this.computeContentClientRect();
    const widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
    const xPosition = previousIndicatorClientRect.left - currentClientRect.left;
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.setContentStyleProperty('transform', `translateX(${xPosition}px) scaleX(${widthDelta})`); // Force repaint before updating classes and transform to ensure the transform properly takes effect

    this.computeContentClientRect();
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    this.adapter_.setContentStyleProperty('transform', '');
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCFadingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  activate() {
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
 * @final
 */

class MDCTabIndicator extends MDCComponent$2 {
  /**
   * @param {!Element} root
   * @return {!MDCTabIndicator}
   */
  static attachTo(root) {
    return new MDCTabIndicator(root);
  }
  /**
   * @param {...?} args
   */


  constructor(...args) {
    super(...args);
    /** @type {?Element} */

    this.content_;
  }

  initialize() {
    this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
  }
  /**
   * @return {!ClientRect}
   */


  computeContentClientRect() {
    return this.foundation_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabIndicatorFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabIndicatorAdapter} */
    Object.assign({
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      computeContentClientRect: () => this.content_.getBoundingClientRect(),
      setContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value)
    });

    if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
      return new MDCFadingTabIndicatorFoundation(adapter);
    } // Default to the sliding indicator


    return new MDCSlidingTabIndicatorFoundation(adapter);
  }
  /**
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.foundation_.activate(previousIndicatorClientRect);
  }

  deactivate() {
    this.foundation_.deactivate();
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$1 = {
  ACTIVE: 'mdc-tab--active'
};
/** @enum {string} */

const strings$1 = {
  ARIA_SELECTED: 'aria-selected',
  RIPPLE_SELECTOR: '.mdc-tab__ripple',
  CONTENT_SELECTOR: '.mdc-tab__content',
  TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
  TABINDEX: 'tabIndex',
  INTERACTED_EVENT: 'MDCTab:interacted'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabAdapter>}
 * @final
 */

class MDCTabFoundation extends MDCFoundation$1 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$1;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$1;
  }
  /**
   * @see MDCTabAdapter for typing information
   * @return {!MDCTabAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        hasClass: () => {},
        setAttr: () => {},
        activateIndicator: () => {},
        deactivateIndicator: () => {},
        notifyInteracted: () => {},
        getOffsetLeft: () => {},
        getOffsetWidth: () => {},
        getContentOffsetLeft: () => {},
        getContentOffsetWidth: () => {},
        focus: () => {}
      }
    );
  }
  /** @param {!MDCTabAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabFoundation.defaultAdapter, adapter));
    /** @private {function(?Event): undefined} */

    this.handleClick_ = () => this.handleClick();
  }
  /**
   * Handles the "click" event
   */


  handleClick() {
    // It's up to the parent component to keep track of the active Tab and
    // ensure we don't activate a Tab that's already active.
    this.adapter_.notifyInteracted();
  }
  /**
   * Returns the Tab's active state
   * @return {boolean}
   */


  isActive() {
    return this.adapter_.hasClass(cssClasses$1.ACTIVE);
  }
  /**
   * Activates the Tab
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.adapter_.addClass(cssClasses$1.ACTIVE);
    this.adapter_.setAttr(strings$1.ARIA_SELECTED, 'true');
    this.adapter_.setAttr(strings$1.TABINDEX, '0');
    this.adapter_.activateIndicator(previousIndicatorClientRect);
    this.adapter_.focus();
  }
  /**
   * Deactivates the Tab
   */


  deactivate() {
    // Early exit
    if (!this.isActive()) {
      return;
    }

    this.adapter_.removeClass(cssClasses$1.ACTIVE);
    this.adapter_.setAttr(strings$1.ARIA_SELECTED, 'false');
    this.adapter_.setAttr(strings$1.TABINDEX, '-1');
    this.adapter_.deactivateIndicator();
  }
  /**
   * Returns the dimensions of the Tab
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    const rootWidth = this.adapter_.getOffsetWidth();
    const rootLeft = this.adapter_.getOffsetLeft();
    const contentWidth = this.adapter_.getContentOffsetWidth();
    const contentLeft = this.adapter_.getContentOffsetLeft();
    return {
      rootLeft,
      rootRight: rootLeft + rootWidth,
      contentLeft: rootLeft + contentLeft,
      contentRight: rootLeft + contentLeft + contentWidth
    };
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabFoundation>}
 * @final
 */

class MDCTab extends MDCComponent$1 {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {?MDCRipple} */

    this.ripple_;
    /** @private {?MDCTabIndicator} */

    this.tabIndicator_;
    /** @private {?Element} */

    this.content_;
    /** @private {?Function} */

    this.handleClick_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTab}
   */


  static attachTo(root) {
    return new MDCTab(root);
  }

  initialize(rippleFactory = (el, foundation) => new MDCRipple(el, foundation), tabIndicatorFactory = el => new MDCTabIndicator(el)) {
    const rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
    const rippleAdapter = Object.assign(MDCRipple.createAdapter(
    /** @type {!RippleCapableSurface} */
    this), {
      addClass: className => rippleSurface.classList.add(className),
      removeClass: className => rippleSurface.classList.remove(className),
      updateCssVariable: (varName, value) => rippleSurface.style.setProperty(varName, value)
    });
    const rippleFoundation = new MDCRippleFoundation(rippleAdapter);
    this.ripple_ = rippleFactory(this.root_, rippleFoundation);
    const tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
    this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
    this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
    this.listen('click', this.handleClick_);
  }

  destroy() {
    this.unlisten('click',
    /** @type {!Function} */
    this.handleClick_);
    this.ripple_.destroy();
    super.destroy();
  }
  /**
   * @return {!MDCTabFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabFoundation(
    /** @type {!MDCTabAdapter} */
    {
      setAttr: (attr, value) => this.root_.setAttribute(attr, value),
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      hasClass: className => this.root_.classList.contains(className),
      activateIndicator: previousIndicatorClientRect => this.tabIndicator_.activate(previousIndicatorClientRect),
      deactivateIndicator: () => this.tabIndicator_.deactivate(),
      notifyInteracted: () => this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, {
        tab: this
      }, true
      /* bubble */
      ),
      getOffsetLeft: () => this.root_.offsetLeft,
      getOffsetWidth: () => this.root_.offsetWidth,
      getContentOffsetLeft: () => this.content_.offsetLeft,
      getContentOffsetWidth: () => this.content_.offsetWidth,
      focus: () => this.root_.focus()
    });
  }
  /**
   * Getter for the active state of the tab
   * @return {boolean}
   */


  get active() {
    return this.foundation_.isActive();
  }
  /**
   * Activates the tab
   * @param {!ClientRect=} computeIndicatorClientRect
   */


  activate(computeIndicatorClientRect) {
    this.foundation_.activate(computeIndicatorClientRect);
  }
  /**
   * Deactivates the tab
   */


  deactivate() {
    this.foundation_.deactivate();
  }
  /**
   * Returns the indicator's client rect
   * @return {!ClientRect}
   */


  computeIndicatorClientRect() {
    return this.tabIndicator_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    return this.foundation_.computeDimensions();
  }
  /**
   * Focuses the tab
   */


  focus() {
    this.root_.focus();
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$3 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$3 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$3(root, new MDCFoundation$3());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$2 = {
  ANIMATING: 'mdc-tab-scroller--animating',
  SCROLL_TEST: 'mdc-tab-scroller__test',
  SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
};
/** @enum {string} */

const strings$2 = {
  AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
  CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @abstract
 */

class MDCTabScrollerRTL {
  /** @param {!MDCTabScrollerAdapter} adapter */
  constructor(adapter) {
    /** @private */
    this.adapter_ = adapter;
  }
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getScrollPositionRTL(translateX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  scrollToRTL(scrollX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  incrementScrollRTL(scrollX) {}
  /**
   * @param {number} scrollX The current scrollX position
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getAnimatingScrollPosition(scrollX, translateX) {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLDefault extends MDCTabScrollerRTL {
  /**
   * @return {number}
   */
  getScrollPositionRTL() {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const {
      right
    } = this.calculateScrollEdges_(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(right - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const edges = this.calculateScrollEdges_();
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX) {
    return scrollX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLNegative extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return Math.round(translateX - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(-scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @param {number} translateX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX - translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: rootWidth - contentWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.max(Math.min(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLReverse extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(currentScrollLeft - translateX);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX + translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: contentWidth - rootWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
 * @final
 */

class MDCTabScrollerFoundation extends MDCFoundation$3 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$2;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$2;
  }
  /**
   * @see MDCTabScrollerAdapter for typing information
   * @return {!MDCTabScrollerAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabScrollerAdapter} */
      {
        eventTargetMatchesSelector: () => {},
        addClass: () => {},
        removeClass: () => {},
        addScrollAreaClass: () => {},
        setScrollAreaStyleProperty: () => {},
        setScrollContentStyleProperty: () => {},
        getScrollContentStyleValue: () => {},
        setScrollAreaScrollLeft: () => {},
        getScrollAreaScrollLeft: () => {},
        getScrollContentOffsetWidth: () => {},
        getScrollAreaOffsetWidth: () => {},
        computeScrollAreaClientRect: () => {},
        computeScrollContentClientRect: () => {},
        computeHorizontalScrollbarHeight: () => {}
      }
    );
  }
  /** @param {!MDCTabScrollerAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabScrollerFoundation.defaultAdapter, adapter));
    /**
     * This boolean controls whether we should handle the transitionend and interaction events during the animation.
     * @private {boolean}
     */

    this.isAnimating_ = false;
    /**
     * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
     * of RTL scrolling in it's own class.
     * @private {?MDCTabScrollerRTL}
     */

    this.rtlScrollerInstance_;
  }

  init() {
    // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
    // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
    const horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
    this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
    this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
  }
  /**
   * Computes the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    if (this.isRTL_()) {
      return this.computeCurrentScrollPositionRTL_();
    }

    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return scrollLeft - currentTranslateX;
  }
  /**
   * Handles interaction events that occur during transition
   */


  handleInteraction() {
    // Early exit if we aren't animating
    if (!this.isAnimating_) {
      return;
    } // Prevent other event listeners from handling this event


    this.stopScrollAnimation_();
  }
  /**
   * Handles the transitionend event
   * @param {!Event} evt
   */


  handleTransitionEnd(evt) {
    // Early exit if we aren't animating or the event was triggered by a different element.
    if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
      return;
    }

    this.isAnimating_ = false;
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
  }
  /**
   * Increment the scroll value by the scrollXIncrement
   * @param {number} scrollXIncrement The value by which to increment the scroll position
   */


  incrementScroll(scrollXIncrement) {
    // Early exit for non-operational increment values
    if (scrollXIncrement === 0) {
      return;
    }

    if (this.isRTL_()) {
      return this.incrementScrollRTL_(scrollXIncrement);
    }

    this.incrementScroll_(scrollXIncrement);
  }
  /**
   * Scrolls to the given scrollX value
   * @param {number} scrollX
   */


  scrollTo(scrollX) {
    if (this.isRTL_()) {
      return this.scrollToRTL_(scrollX);
    }

    this.scrollTo_(scrollX);
  }
  /**
   * Returns the appropriate version of the MDCTabScrollerRTL
   * @return {!MDCTabScrollerRTL}
   */


  getRTLScroller() {
    if (!this.rtlScrollerInstance_) {
      this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
    }

    return this.rtlScrollerInstance_;
  }
  /**
   * Returns the translateX value from a CSS matrix transform function string
   * @return {number}
   * @private
   */


  calculateCurrentTranslateX_() {
    const transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

    if (transformValue === 'none') {
      return 0;
    } // The transform value comes back as a matrix transformation in the form
    // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
    // we're going to grab all the parenthesized values, strip out tx, and
    // parse it.


    const results = /\((.+)\)/.exec(transformValue)[1];
    const parts = results.split(',');
    return parseFloat(parts[4]);
  }
  /**
   * Calculates a safe scroll value that is > 0 and < the max scroll value
   * @param {number} scrollX The distance to scroll
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }
  /**
   * @return {number}
   * @private
   */


  computeCurrentScrollPositionRTL_() {
    const translateX = this.calculateCurrentTranslateX_();
    return this.getRTLScroller().getScrollPositionRTL(translateX);
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * Internal scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollTo_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const safeScrollX = this.clampScrollValue_(scrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal RTL scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollToRTL_(scrollX) {
    const animation = this.getRTLScroller().scrollToRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Internal increment scroll method
   * @param {number} scrollX The new scroll position increment
   * @private
   */


  incrementScroll_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const targetScrollX = scrollX + currentScrollX;
    const safeScrollX = this.clampScrollValue_(targetScrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal incremenet scroll RTL method
   * @param {number} scrollX The new scroll position RTL increment
   * @private
   */


  incrementScrollRTL_(scrollX) {
    const animation = this.getRTLScroller().incrementScrollRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Animates the tab scrolling
   * @param {!MDCTabScrollerAnimation} animation The animation to apply
   * @private
   */


  animate_(animation) {
    // Early exit if translateX is 0, which means there's no animation to perform
    if (animation.scrollDelta === 0) {
      return;
    }

    this.stopScrollAnimation_(); // This animation uses the FLIP approach.
    // Read more here: https://aerotwist.com/blog/flip-your-animations/

    this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
    this.adapter_.setScrollContentStyleProperty('transform', `translateX(${animation.scrollDelta}px)`); // Force repaint

    this.adapter_.computeScrollAreaClientRect();
    requestAnimationFrame(() => {
      this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
      this.adapter_.setScrollContentStyleProperty('transform', 'none');
    });
    this.isAnimating_ = true;
  }
  /**
   * Stops scroll animation
   * @private
   */


  stopScrollAnimation_() {
    this.isAnimating_ = false;
    const currentScrollPosition = this.getAnimatingScrollPosition_();
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
    this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
    this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
  }
  /**
   * Gets the current scroll position during animation
   * @return {number}
   * @private
   */


  getAnimatingScrollPosition_() {
    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();

    if (this.isRTL_()) {
      return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
    }

    return scrollLeft - currentTranslateX;
  }
  /**
   * Determines the RTL Scroller to use
   * @return {!MDCTabScrollerRTL}
   * @private
   */


  rtlScrollerFactory_() {
    // Browsers have three different implementations of scrollLeft in RTL mode,
    // dependent on the browser. The behavior is based off the max LTR
    // scrollleft value and 0.
    //
    // * Default scrolling in RTL *
    //    - Left-most value: 0
    //    - Right-most value: Max LTR scrollLeft value
    //
    // * Negative scrolling in RTL *
    //    - Left-most value: Negated max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // * Reverse scrolling in RTL *
    //    - Left-most value: Max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // We use those principles below to determine which RTL scrollLeft
    // behavior is implemented in the current browser.
    const initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
    const newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
    // implemented negative RTL scrolling, since all other implementations have
    // only positive values.

    if (newScrollLeft < 0) {
      // Undo the scrollLeft test check
      this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
      return new MDCTabScrollerRTLNegative(this.adapter_);
    }

    const rootClientRect = this.adapter_.computeScrollAreaClientRect();
    const contentClientRect = this.adapter_.computeScrollContentClientRect();
    const rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
    // the content element, we can determine how much the scroll value changed
    // when we performed the scrollLeft subtraction above.

    if (rightEdgeDelta === newScrollLeft) {
      return new MDCTabScrollerRTLReverse(this.adapter_);
    }

    return new MDCTabScrollerRTLDefault(this.adapter_);
  }
  /**
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
 * @private {number|undefined}
 */

let horizontalScrollbarHeight_;
/**
 * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
 * May return 0 (e.g. on OS X browsers under default configuration).
 * @param {!Document} documentObj
 * @param {boolean=} shouldCacheResult
 * @return {number}
 */

function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult = true) {
  if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
    return horizontalScrollbarHeight_;
  }

  const el = documentObj.createElement('div');
  el.classList.add(cssClasses$2.SCROLL_TEST);
  documentObj.body.appendChild(el);
  const horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
  documentObj.body.removeChild(el);

  if (shouldCacheResult) {
    horizontalScrollbarHeight_ = horizontalScrollbarHeight;
  }

  return horizontalScrollbarHeight;
}
/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */


function getMatchesProperty(HTMLElementPrototype) {
  return ['msMatchesSelector', 'matches'].filter(p$$1 => p$$1 in HTMLElementPrototype).pop();
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabScrollerFoundation>}
 * @final
 */

class MDCTabScroller extends MDCComponent$3 {
  /**
   * @param {!Element} root
   * @return {!MDCTabScroller}
   */
  static attachTo(root) {
    return new MDCTabScroller(root);
  }

  constructor(...args) {
    super(...args);
    /** @private {?Element} */

    this.content_;
    /** @private {?Element} */

    this.area_;
    /** @private {?function(?Event): undefined} */

    this.handleInteraction_;
    /** @private {?function(!Event): undefined} */

    this.handleTransitionEnd_;
  }

  initialize() {
    this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
    this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleInteraction_ = () => this.foundation_.handleInteraction();

    this.handleTransitionEnd_ = evt => this.foundation_.handleTransitionEnd(evt);

    this.area_.addEventListener('wheel', this.handleInteraction_);
    this.area_.addEventListener('touchstart', this.handleInteraction_);
    this.area_.addEventListener('pointerdown', this.handleInteraction_);
    this.area_.addEventListener('mousedown', this.handleInteraction_);
    this.area_.addEventListener('keydown', this.handleInteraction_);
    this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
  }

  destroy() {
    super.destroy();
    this.area_.removeEventListener('wheel', this.handleInteraction_);
    this.area_.removeEventListener('touchstart', this.handleInteraction_);
    this.area_.removeEventListener('pointerdown', this.handleInteraction_);
    this.area_.removeEventListener('mousedown', this.handleInteraction_);
    this.area_.removeEventListener('keydown', this.handleInteraction_);
    this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
  }
  /**
   * @return {!MDCTabScrollerFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabScrollerAdapter} */
    {
      eventTargetMatchesSelector: (evtTarget, selector) => {
        const MATCHES = getMatchesProperty(HTMLElement.prototype);
        return evtTarget[MATCHES](selector);
      },
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      addScrollAreaClass: className => this.area_.classList.add(className),
      setScrollAreaStyleProperty: (prop, value) => this.area_.style.setProperty(prop, value),
      setScrollContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value),
      getScrollContentStyleValue: propName => window.getComputedStyle(this.content_).getPropertyValue(propName),
      setScrollAreaScrollLeft: scrollX => this.area_.scrollLeft = scrollX,
      getScrollAreaScrollLeft: () => this.area_.scrollLeft,
      getScrollContentOffsetWidth: () => this.content_.offsetWidth,
      getScrollAreaOffsetWidth: () => this.area_.offsetWidth,
      computeScrollAreaClientRect: () => this.area_.getBoundingClientRect(),
      computeScrollContentClientRect: () => this.content_.getBoundingClientRect(),
      computeHorizontalScrollbarHeight: () => computeHorizontalScrollbarHeight(document)
    };
    return new MDCTabScrollerFoundation(adapter);
  }
  /**
   * Returns the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    return this.foundation_.getScrollPosition();
  }
  /**
   * Returns the width of the scroll content
   * @return {number}
   */


  getScrollContentWidth() {
    return this.content_.offsetWidth;
  }
  /**
   * Increments the scroll value by the given amount
   * @param {number} scrollXIncrement The pixel value by which to increment the scroll value
   */


  incrementScroll(scrollXIncrement) {
    this.foundation_.incrementScroll(scrollXIncrement);
  }
  /**
   * Scrolls to the given pixel position
   * @param {number} scrollX The pixel value to scroll to
   */


  scrollTo(scrollX) {
    this.foundation_.scrollTo(scrollX);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const strings$3 = {
  TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
  TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
  TAB_SELECTOR: '.mdc-tab',
  ARROW_LEFT_KEY: 'ArrowLeft',
  ARROW_RIGHT_KEY: 'ArrowRight',
  END_KEY: 'End',
  HOME_KEY: 'Home',
  ENTER_KEY: 'Enter',
  SPACE_KEY: 'Space'
};
/** @enum {number} */

const numbers = {
  EXTRA_SCROLL_AMOUNT: 20,
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  HOME_KEYCODE: 36,
  ENTER_KEYCODE: 13,
  SPACE_KEYCODE: 32
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @type {Set<string>}
 */

const ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand

ACCEPTABLE_KEYS.add(strings$3.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings$3.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings$3.END_KEY);
ACCEPTABLE_KEYS.add(strings$3.HOME_KEY);
ACCEPTABLE_KEYS.add(strings$3.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings$3.SPACE_KEY);
/**
 * @type {Map<number, string>}
 */

const KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand

KEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings$3.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings$3.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers.END_KEYCODE, strings$3.END_KEY);
KEYCODE_MAP.set(numbers.HOME_KEYCODE, strings$3.HOME_KEY);
KEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings$3.ENTER_KEY);
KEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings$3.SPACE_KEY);
/**
 * @extends {MDCFoundation<!MDCTabBarAdapter>}
 * @final
 */

class MDCTabBarFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$3;
  }
  /** @return enum {number} */


  static get numbers() {
    return numbers;
  }
  /**
   * @see MDCTabBarAdapter for typing information
   * @return {!MDCTabBarAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabBarAdapter} */
      {
        scrollTo: () => {},
        incrementScroll: () => {},
        getScrollPosition: () => {},
        getScrollContentWidth: () => {},
        getOffsetWidth: () => {},
        isRTL: () => {},
        setActiveTab: () => {},
        activateTabAtIndex: () => {},
        deactivateTabAtIndex: () => {},
        focusTabAtIndex: () => {},
        getTabIndicatorClientRectAtIndex: () => {},
        getTabDimensionsAtIndex: () => {},
        getPreviousActiveTabIndex: () => {},
        getFocusedTabIndex: () => {},
        getIndexOfTab: () => {},
        getTabListLength: () => {},
        notifyTabActivated: () => {}
      }
    );
  }
  /**
   * @param {!MDCTabBarAdapter} adapter
   * */


  constructor(adapter) {
    super(Object.assign(MDCTabBarFoundation.defaultAdapter, adapter));
    /** @private {boolean} */

    this.useAutomaticActivation_ = false;
  }
  /**
   * Switches between automatic and manual activation modes.
   * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
   * @param {boolean} useAutomaticActivation
   */


  setUseAutomaticActivation(useAutomaticActivation) {
    this.useAutomaticActivation_ = useAutomaticActivation;
  }
  /**
   * Activates the tab at the given index
   * @param {number} index
   */


  activateTab(index) {
    const previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();

    if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
      return;
    }

    this.adapter_.deactivateTabAtIndex(previousActiveIndex);
    this.adapter_.activateTabAtIndex(index, this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex));
    this.scrollIntoView(index);
    this.adapter_.notifyTabActivated(index);
  }
  /**
   * Handles the keydown event
   * @param {!Event} evt
   */


  handleKeyDown(evt) {
    // Get the key from the event
    const key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys

    if (key === undefined) {
      return;
    } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple


    if (!this.isActivationKey_(key)) {
      evt.preventDefault();
    }

    if (this.useAutomaticActivation_) {
      if (this.isActivationKey_(key)) {
        return;
      }

      const index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
      this.adapter_.setActiveTab(index);
      this.scrollIntoView(index);
    } else {
      const focusedTabIndex = this.adapter_.getFocusedTabIndex();

      if (this.isActivationKey_(key)) {
        this.adapter_.setActiveTab(focusedTabIndex);
      } else {
        const index = this.determineTargetFromKey_(focusedTabIndex, key);
        this.adapter_.focusTabAtIndex(index);
        this.scrollIntoView(index);
      }
    }
  }
  /**
   * Handles the MDCTab:interacted event
   * @param {!Event} evt
   */


  handleTabInteraction(evt) {
    this.adapter_.setActiveTab(this.adapter_.getIndexOfTab(evt.detail.tab));
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index The tab index to make visible
   */


  scrollIntoView(index) {
    // Early exit if the index is out of range
    if (!this.indexIsInRange_(index)) {
      return;
    } // Always scroll to 0 if scrolling to the 0th index


    if (index === 0) {
      return this.adapter_.scrollTo(0);
    } // Always scroll to the max value if scrolling to the Nth index
    // MDCTabScroller.scrollTo() will never scroll past the max possible value


    if (index === this.adapter_.getTabListLength() - 1) {
      return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
    }

    if (this.isRTL_()) {
      return this.scrollIntoViewRTL_(index);
    }

    this.scrollIntoView_(index);
  }
  /**
   * Private method for determining the index of the destination tab based on what key was pressed
   * @param {number} origin The original index from which to determine the destination
   * @param {string} key The name of the key
   * @return {number}
   * @private
   */


  determineTargetFromKey_(origin, key) {
    const isRTL = this.isRTL_();
    const maxIndex = this.adapter_.getTabListLength() - 1;
    const shouldGoToEnd = key === strings$3.END_KEY;
    const shouldDecrement = key === strings$3.ARROW_LEFT_KEY && !isRTL || key === strings$3.ARROW_RIGHT_KEY && isRTL;
    const shouldIncrement = key === strings$3.ARROW_RIGHT_KEY && !isRTL || key === strings$3.ARROW_LEFT_KEY && isRTL;
    let index = origin;

    if (shouldGoToEnd) {
      index = maxIndex;
    } else if (shouldDecrement) {
      index -= 1;
    } else if (shouldIncrement) {
      index += 1;
    } else {
      index = 0;
    }

    if (index < 0) {
      index = maxIndex;
    } else if (index > maxIndex) {
      index = 0;
    }

    return index;
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @return {number}
   * @private
   */


  calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
    const relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
    const leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;

    if (nextIndex < index) {
      return Math.min(leftIncrement, 0);
    }

    return Math.max(rightIncrement, 0);
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible in RTL
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @param {number} scrollContentWidth The width of the scroll content
   * @return {number}
   * @private
   */


  calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
    const relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
    const leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;

    if (nextIndex > index) {
      return Math.max(leftIncrement, 0);
    }

    return Math.min(rightIncrement, 0);
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth) {
    /**
     * Tabs are laid out in the Tab Scroller like this:
     *
     *    Scroll Position
     *    +---+
     *    |   |   Bar Width
     *    |   +-----------------------------------+
     *    |   |                                   |
     *    |   V                                   V
     *    |   +-----------------------------------+
     *    V   |             Tab Scroller          |
     *    +------------+--------------+-------------------+
     *    |    Tab     |      Tab     |        Tab        |
     *    +------------+--------------+-------------------+
     *        |                                   |
     *        +-----------------------------------+
     *
     * To determine the next adjacent index, we look at the Tab root left and
     * Tab root right, both relative to the scroll position. If the Tab root
     * left is less than 0, then we know it's out of view to the left. If the
     * Tab root right minus the bar width is greater than 0, we know the Tab is
     * out of view to the right. From there, we either increment or decrement
     * the index.
     */
    const relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
    const relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
    const relativeRootDelta = relativeRootLeft + relativeRootRight;
    const leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
    const rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;

    if (leftEdgeIsCloser) {
      return index - 1;
    }

    if (rightEdgeIsCloser) {
      return index + 1;
    }

    return -1;
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @param {number} scrollContentWidth The width of the scroller content
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
    const rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
    const rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
    const rootDelta = rootLeft + rootRight;
    const leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
    const rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;

    if (leftEdgeIsCloser) {
      return index + 1;
    }

    if (rightEdgeIsCloser) {
      return index - 1;
    }

    return -1;
  }
  /**
   * Returns the key associated with a keydown event
   * @param {!Event} evt The keydown event
   * @return {string}
   * @private
   */


  getKeyFromEvent_(evt) {
    if (ACCEPTABLE_KEYS.has(evt.key)) {
      return evt.key;
    }

    return KEYCODE_MAP.get(evt.keyCode);
  }

  isActivationKey_(key) {
    return key === strings$3.SPACE_KEY || key === strings$3.ENTER_KEY;
  }
  /**
   * Returns whether a given index is inclusively between the ends
   * @param {number} index The index to test
   * @private
   */


  indexIsInRange_(index) {
    return index >= 0 && index < this.adapter_.getTabListLength();
  }
  /**
   * Returns the view's RTL property
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.isRTL();
  }
  /**
   * Scrolls the tab at the given index into view for left-to-right useragents
   * @param {number} index The index of the tab to scroll into view
   * @private
   */


  scrollIntoView_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }
  /**
   * Scrolls the tab at the given index into view in RTL
   * @param {number} index The tab index to make visible
   * @private
   */


  scrollIntoViewRTL_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const scrollWidth = this.adapter_.getScrollContentWidth();
    const nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabBarFoundation>}
 * @final
 */

class MDCTabBar extends MDCComponent {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {!Array<!MDCTab>} */

    this.tabList_;
    /** @type {(function(!Element): !MDCTab)} */

    this.tabFactory_;
    /** @private {?MDCTabScroller} */

    this.tabScroller_;
    /** @type {(function(!Element): !MDCTabScroller)} */

    this.tabScrollerFactory_;
    /** @private {?function(?Event): undefined} */

    this.handleTabInteraction_;
    /** @private {?function(?Event): undefined} */

    this.handleKeyDown_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTabBar}
   */


  static attachTo(root) {
    return new MDCTabBar(root);
  }

  set useAutomaticActivation(useAutomaticActivation) {
    this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
  }
  /**
   * @param {(function(!Element): !MDCTab)=} tabFactory A function which creates a new MDCTab
   * @param {(function(!Element): !MDCTabScroller)=} tabScrollerFactory A function which creates a new MDCTabScroller
   */


  initialize(tabFactory = el => new MDCTab(el), tabScrollerFactory = el => new MDCTabScroller(el)) {
    this.tabFactory_ = tabFactory;
    this.tabScrollerFactory_ = tabScrollerFactory;
    this.tabList_ = this.getTabElements_().map(el => this.tabFactory_(el));
    const tabScrollerElement = this.root_.querySelector(MDCTabBarFoundation.strings.TAB_SCROLLER_SELECTOR);

    if (tabScrollerElement) {
      this.tabScroller_ = this.tabScrollerFactory_(tabScrollerElement);
    }
  }

  initialSyncWithDOM() {
    this.handleTabInteraction_ = evt => this.foundation_.handleTabInteraction(evt);

    this.handleKeyDown_ = evt => this.foundation_.handleKeyDown(evt);

    this.root_.addEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.addEventListener('keydown', this.handleKeyDown_);

    for (let i = 0; i < this.tabList_.length; i++) {
      if (this.tabList_[i].active) {
        this.scrollIntoView(i);
        break;
      }
    }
  }

  destroy() {
    super.destroy();
    this.root_.removeEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.removeEventListener('keydown', this.handleKeyDown_);
    this.tabList_.forEach(tab => tab.destroy());
    this.tabScroller_.destroy();
  }
  /**
   * @return {!MDCTabBarFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabBarFoundation(
    /** @type {!MDCTabBarAdapter} */
    {
      scrollTo: scrollX => this.tabScroller_.scrollTo(scrollX),
      incrementScroll: scrollXIncrement => this.tabScroller_.incrementScroll(scrollXIncrement),
      getScrollPosition: () => this.tabScroller_.getScrollPosition(),
      getScrollContentWidth: () => this.tabScroller_.getScrollContentWidth(),
      getOffsetWidth: () => this.root_.offsetWidth,
      isRTL: () => window.getComputedStyle(this.root_).getPropertyValue('direction') === 'rtl',
      setActiveTab: index => this.foundation_.activateTab(index),
      activateTabAtIndex: (index, clientRect) => this.tabList_[index].activate(clientRect),
      deactivateTabAtIndex: index => this.tabList_[index].deactivate(),
      focusTabAtIndex: index => this.tabList_[index].focus(),
      getTabIndicatorClientRectAtIndex: index => this.tabList_[index].computeIndicatorClientRect(),
      getTabDimensionsAtIndex: index => this.tabList_[index].computeDimensions(),
      getPreviousActiveTabIndex: () => {
        for (let i = 0; i < this.tabList_.length; i++) {
          if (this.tabList_[i].active) {
            return i;
          }
        }

        return -1;
      },
      getFocusedTabIndex: () => {
        const tabElements = this.getTabElements_();
        const activeElement = document.activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTab: tabToFind => this.tabList_.indexOf(tabToFind),
      getTabListLength: () => this.tabList_.length,
      notifyTabActivated: index => this.emit(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {
        index
      }, true)
    });
  }
  /**
   * Activates the tab at the given index
   * @param {number} index The index of the tab
   */


  activateTab(index) {
    this.foundation_.activateTab(index);
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index THe index of the tab
   */


  scrollIntoView(index) {
    this.foundation_.scrollIntoView(index);
  }

  getTabElements_() {
    return [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
  }

}

var tabBar = /*#__PURE__*/Object.freeze({
  MDCTabBar: MDCTabBar,
  MDCTabBarFoundation: MDCTabBarFoundation
});

var TabBar_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.TabBar = exports.Tab = exports.TabIcon = exports.TabLabel = void 0;

  var _get2 = _interopRequireDefault(require$$0);

  var _classCallCheck2 = _interopRequireDefault(require$$1);

  var _createClass2 = _interopRequireDefault(require$$0$1);

  var _possibleConstructorReturn2 = _interopRequireDefault(require$$2);

  var _getPrototypeOf2 = _interopRequireDefault(require$$3);

  var _inherits2 = _interopRequireDefault(require$$4);

  var _MaterialComponent5 = _interopRequireDefault(require$$5);

  var TabLabel =
  /*#__PURE__*/
  function (_MaterialComponent) {
    (0, _inherits2.default)(TabLabel, _MaterialComponent);

    function TabLabel() {
      var _this;

      (0, _classCallCheck2.default)(this, TabLabel);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabLabel).apply(this, arguments));
      _this.componentName = 'tab__text-label';
      _this.mdcProps = [];
      return _this;
    }

    (0, _createClass2.default)(TabLabel, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({}, props), props.children);
      }
    }]);
    return TabLabel;
  }(_MaterialComponent5.default);

  exports.TabLabel = TabLabel;

  var TabIcon =
  /*#__PURE__*/
  function (_MaterialComponent2) {
    (0, _inherits2.default)(TabIcon, _MaterialComponent2);

    function TabIcon() {
      var _this2;

      (0, _classCallCheck2.default)(this, TabIcon);
      _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabIcon).apply(this, arguments));
      _this2.componentName = 'tab__icon';
      _this2.mdcProps = [];
      return _this2;
    }

    (0, _createClass2.default)(TabIcon, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({
          className: "material-icons"
        }, props), props.children);
      }
    }]);
    return TabIcon;
  }(_MaterialComponent5.default);

  exports.TabIcon = TabIcon;

  var Tab =
  /*#__PURE__*/
  function (_MaterialComponent3) {
    (0, _inherits2.default)(Tab, _MaterialComponent3);

    function Tab() {
      var _this3;

      (0, _classCallCheck2.default)(this, Tab);
      _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Tab).apply(this, arguments));
      _this3.componentName = 'tab';
      _this3.mdcProps = ['active'];
      _this3.mdcNotifyProps = ['active'];
      return _this3;
    }

    (0, _createClass2.default)(Tab, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("button", Object.assign({
          class: "mdc-tab",
          role: "tab",
          "aria-selected": "true"
        }, props), (0, _preact.h)("span", {
          class: "mdc-tab__content"
        }, props.children), (0, _preact.h)("span", {
          class: "mdc-tab-indicator ".concat(props.active ? 'mdc-tab-indicator--active' : '')
        }, (0, _preact.h)("span", {
          class: "mdc-tab-indicator__content mdc-tab-indicator__content--underline"
        })), (0, _preact.h)("span", {
          class: "mdc-tab__ripple"
        }));
      }
    }]);
    return Tab;
  }(_MaterialComponent5.default);

  exports.Tab = Tab;

  var TabBar =
  /*#__PURE__*/
  function (_MaterialComponent4) {
    (0, _inherits2.default)(TabBar, _MaterialComponent4);

    function TabBar() {
      var _this4;

      (0, _classCallCheck2.default)(this, TabBar);
      _this4 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabBar).apply(this, arguments));
      _this4.componentName = 'tab-bar';
      _this4.mdcProps = [];
      _this4.mdcNotifyProps = ['activeTabIndex'];
      return _this4;
    }

    (0, _createClass2.default)(TabBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentDidMount", this).call(this);

        if (this.control) {
          this.MDComponent = new tabBar.MDCTabBar(this.control);
        }

        this.afterComponentDidMount();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentWillUnmount", this).call(this);

        if (this.MDComponent) {
          this.MDComponent.destroy();
        }
      }
    }, {
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("div", {
          class: "mdc-tab-bar",
          role: "tablist",
          ref: this.setControlRef
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-area"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-content"
        }, props.children))));
      }
    }]);
    return TabBar;
  }(_MaterialComponent5.default);

  exports.TabBar = TabBar;

  var default_1 =
  /*#__PURE__*/
  function (_TabBar) {
    (0, _inherits2.default)(default_1, _TabBar);

    function default_1() {
      (0, _classCallCheck2.default)(this, default_1);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(default_1).apply(this, arguments));
    }

    return default_1;
  }(TabBar);

  exports.default = default_1;
  default_1.Tab = Tab;
  default_1.TabLabel = TabLabel;
  default_1.TabIcon = TabIcon;
});
var TabBar = unwrapExports(TabBar_1);
var TabBar_2 = TabBar_1.TabBar;
var TabBar_3 = TabBar_1.Tab;
var TabBar_4 = TabBar_1.TabIcon;
var TabBar_5 = TabBar_1.TabLabel;

var css = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n.mdc-tab-bar {\n  width: 100%; }";
styleInject(css);

var css$1 = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n@-webkit-keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n@keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n.mdc-ripple-surface--test-edge-var-bug {\n  --mdc-ripple-surface-test-edge-var: 1px solid #000;\n  visibility: hidden; }\n  .mdc-ripple-surface--test-edge-var-bug::before {\n    border: var(--mdc-ripple-surface-test-edge-var); }\n\n.mdc-tab {\n  font-family: Roboto, sans-serif;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-size: 0.875rem;\n  line-height: 2.25rem;\n  font-weight: 500;\n  letter-spacing: 0.08929em;\n  text-decoration: none;\n  text-transform: uppercase;\n  color: rgba(0, 0, 0, 0.54);\n  /* @alternate */\n  color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n  --mdc-ripple-fg-size: 0;\n  --mdc-ripple-left: 0;\n  --mdc-ripple-top: 0;\n  --mdc-ripple-fg-scale: 1;\n  --mdc-ripple-fg-translate-end: 0;\n  --mdc-ripple-fg-translate-start: 0;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  will-change: transform, opacity;\n  display: table-cell;\n  position: relative;\n  box-sizing: border-box;\n  min-width: 160px;\n  min-height: 48px;\n  padding: 0 24px;\n  text-align: center;\n  text-decoration: none;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n  vertical-align: middle; }\n  .mdc-tab .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54)); }\n  .mdc-tab::before, .mdc-tab::after {\n    position: absolute;\n    border-radius: 50%;\n    opacity: 0;\n    pointer-events: none;\n    content: \"\"; }\n  .mdc-tab::before {\n    transition: opacity 15ms linear;\n    z-index: 1; }\n  .mdc-tab.mdc-ripple-upgraded::before {\n    -webkit-transform: scale(var(--mdc-ripple-fg-scale, 1));\n            transform: scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    top: 0;\n    /* @noflip */\n    left: 0;\n    -webkit-transform: scale(0);\n            transform: scale(0);\n    -webkit-transform-origin: center center;\n            transform-origin: center center; }\n  .mdc-tab.mdc-ripple-upgraded--unbounded::after {\n    top: var(--mdc-ripple-top, 0);\n    /* @noflip */\n    left: var(--mdc-ripple-left, 0); }\n  .mdc-tab.mdc-ripple-upgraded--foreground-activation::after {\n    -webkit-animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards;\n            animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards; }\n  .mdc-tab.mdc-ripple-upgraded--foreground-deactivation::after {\n    -webkit-animation: 150ms mdc-ripple-fg-opacity-out;\n            animation: 150ms mdc-ripple-fg-opacity-out;\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab::before, .mdc-tab::after {\n    background-color: black; }\n  .mdc-tab:hover::before {\n    opacity: 0.04; }\n  .mdc-tab:not(.mdc-ripple-upgraded):focus::before, .mdc-tab.mdc-ripple-upgraded--background-focused::before {\n    transition-duration: 75ms;\n    opacity: 0.12; }\n  .mdc-tab:not(.mdc-ripple-upgraded)::after {\n    transition: opacity 150ms linear; }\n  .mdc-tab:not(.mdc-ripple-upgraded):active::after {\n    transition-duration: 75ms;\n    opacity: 0.16; }\n  .mdc-tab.mdc-ripple-upgraded {\n    --mdc-ripple-fg-opacity: 0.16; }\n  .mdc-tab::before, .mdc-tab::after {\n    top: calc(50% - 100%);\n    /* @noflip */\n    left: calc(50% - 100%);\n    width: 200%;\n    height: 200%; }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    width: var(--mdc-ripple-fg-size, 100%);\n    height: var(--mdc-ripple-fg-size, 100%); }\n  .mdc-tab:hover {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab:hover .mdc-tab__icon {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab:focus {\n    outline: none; }\n  @media screen and (max-width: 600px) {\n    .mdc-tab {\n      min-width: 72px;\n      padding: 0 12px; } }\n  .mdc-tab__icon {\n    display: block;\n    margin: 0 auto;\n    width: 24px;\n    height: 24px; }\n    .mdc-tab-bar--icons-with-text .mdc-tab__icon {\n      margin-top: 4px; }\n  .mdc-tab__icon-text {\n    display: block;\n    margin: 0 auto; }\n  .mdc-tab__icon + .mdc-tab__icon-text {\n    padding-top: 6px; }\n\n.mdc-tab--active {\n  color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active::before {\n    bottom: 0; }\n\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 2px;\n  width: calc(100% - 4px); }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:hover .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:active .mdc-tab__indicator {\n  visibility: visible; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):hover .mdc-tab__indicator {\n  opacity: .38; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):active .mdc-tab__indicator {\n  opacity: .87; }\n\n.mdc-tab-bar__indicator,\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n\n.mdc-tab-bar {\n  display: table;\n  position: relative;\n  height: 48px;\n  margin: 0 auto;\n  text-transform: uppercase; }\n\n.mdc-tab-bar__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 0;\n  width: 100%;\n  -webkit-transform-origin: left top;\n          transform-origin: left top;\n  transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  will-change: transform; }\n\n.mdc-tab-bar--icons-with-text {\n  height: 72px; }\n\n.mdc-tab-bar-scroller {\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  background-color: inherit;\n  overflow: hidden; }\n  .mdc-tab-bar-scroller__scroll-frame {\n    display: flex;\n    position: relative;\n    flex: 1;\n    justify-content: flex-start;\n    overflow: hidden; }\n    .mdc-tab-bar-scroller__scroll-frame__tabs {\n      transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      will-change: transform; }\n  .mdc-tab-bar-scroller__indicator {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 48px;\n    cursor: pointer;\n    visibility: hidden; }\n    .mdc-tab-bar-scroller__indicator:hover {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab-bar-scroller__indicator__inner {\n      color: inherit;\n      text-decoration: inherit;\n      cursor: inherit; }\n      .mdc-tab-bar-scroller__indicator__inner:focus {\n        outline-color: inherit; }\n      .mdc-tab-bar-scroller[dir=\"rtl\"] .mdc-tab-bar-scroller__indicator__inner,\n      [dir=\"rtl\"] .mdc-tab-bar-scroller .mdc-tab-bar-scroller__indicator__inner {\n        -webkit-transform: rotate(180deg);\n                transform: rotate(180deg); }\n    .mdc-tab-bar-scroller__indicator__inner:hover {\n      color: inherit; }\n  .mdc-tab-bar-scroller__indicator--enabled {\n    visibility: visible; }";
styleInject(css$1);

var DateLinebreak = function DateLinebreak(_ref) {
  var datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex"
    }
  }, h("div", {
    style: {
      flex: "1"
    }
  }, h("hr", null)), h("div", null, new Date(datetime).toLocaleDateString()), h("div", {
    style: {
      flex: 1
    }
  }, h("hr", null)));
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MessageAligner = function MessageAligner(_ref) {
  var children = _ref.children,
      side = _ref.side,
      style = _ref.style;
  var alignment = side === "left" ? "flex-start" : "flex-end";
  return h("div", {
    style: _objectSpread({
      display: "flex",
      justifyContent: alignment
    }, style)
  }, children);
};

var MessageView = function MessageView(_ref) {
  var message = _ref.message,
      backgroundColor = _ref.backgroundColor,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      backgroundColor: backgroundColor,
      padding: 5,
      margin: 2,
      borderRadius: 15,
      borderColor: '#9E9E9E',
      borderStyle: 'solid',
      borderWidth: 2,
      maxWidth: '100%',
      wordWrap: 'break-word',
      wordBreak: 'break-all',
      minWidth: '30%'
    }
  }, h("div", null, message), h("div", {
    style: {
      fontSize: 10,
      paddingTop: 2,
      textAlign: 'end'
    }
  }, h("i", {
    style: {
      backgroundColor: '#efebe9'
    }
  }, new Date(datetime).toLocaleTimeString())));
};

var SubsequentMessage = function SubsequentMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center",
      marginLeft: 45
    }
  }, h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

var style = {
  height: 30,
  width: 40,
  padding: 3,
  borderRadius: 30,
  backgroundColor: 'darkSmoke',
  borderStyle: 'solid',
  borderWidth: 2,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: '#009688',
  borderColor: '#80cbc4'
};

var MessageAvatar = function MessageAvatar(_ref) {
  var _ref$letter = _ref.letter,
      letter = _ref$letter === void 0 ? 'U' : _ref$letter;
  return h("div", {
    style: style
  }, h("div", null, letter.toUpperCase()));
};

var FirstMessage = function FirstMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime,
      letter = _ref.letter,
      local = _ref.local;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, !local && h(MessageAvatar, {
    letter: letter
  }), h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

/* eslint-disable react/jsx-props-no-spreading */

var MessageObjectMappter = function MessageObjectMappter(props) {
  var order = props.order,
      dateSpace = props.dateSpace;
  return h("div", null, dateSpace && h(DateLinebreak, props), h(MessageAligner, props, order === 'F' ? h(FirstMessage, props) : h(SubsequentMessage, props)));
};

var useMessageSorter = function useMessageSorter(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      sortedMessages = _useState2[0],
      setSortedMessages = _useState2[1];

  p(function () {
    setSortedMessages(messages.sort(function (a, b) {
      return a.datetime - b.datetime;
    }));
  }, [messages]);
  return {
    sortedMessages: sortedMessages
  };
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useMessagesMapper = function useMessagesMapper(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      mappedMessages = _useState2[0],
      setMappedMessages = _useState2[1];

  var mapMessages = function mapMessages() {
    var localSide = "right";
    var remoteSide = "left";

    if (messages.length === 0) {
      return [];
    }

    var email = messages[0].from;
    var lastDatetime = messages[0].datetime;
    return messages.map(function (m, i) {
      if (i === 0 && m.local) {
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i === 0 && !m.local) {
        var letter = m.from[0] !== undefined ? m.from[0] : "";
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: letter
        });
      }

      if (i > 0 && email === m.from && m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "S",
            dateSpace: true
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "S",
          dateSpace: false
        });
      }

      if (i > 0 && email !== m.from && m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "F",
            dateSpace: false
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i > 0 && email === m.from && !m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          var _letter2 = m.from[0] !== undefined ? m.from[0] : "";

          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "S",
            dateSpace: true,
            letter: _letter2
          });
        }

        var _letter = m.from[0] !== undefined ? m.from[0] : "";

        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "S",
          dateSpace: false,
          letter: _letter
        });
      }

      if (i > 0 && email !== m.from && !m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          var _letter4 = m.from[0] !== undefined ? m.from[0] : "";

          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "F",
            dateSpace: false,
            letter: _letter4
          });
        }

        var _letter3 = m.from[0] !== undefined ? m.from[0] : "";

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: _letter3
        });
      }

      return null;
    });
  };

  p(function () {
    setMappedMessages(mapMessages());
  }, [messages]);
  return {
    mappedMessages: mappedMessages
  };
};

var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
});

var MessageCollectionView = function MessageCollectionView(_ref) {
  var messages = _ref.messages;

  if (messages.length > 0) {
    return messages.map(function (message, i) {
      return h(MessageObjectMappter, _extends_1({}, message, {
        key: i
      }));
    });
  }

  return null;
};

/* eslint-disable react/no-deprecated */

var MessageViewScroller = function MessageViewScroller(_ref) {
  var children = _ref.children;
  return h("div", {
    style: {
      transform: "rotate(180deg)",
      height: "85%",
      backgroundColor: "#edeff2",
      overflow: "scroll",
      width: "100%"
    }
  }, h("div", {
    style: {
      transform: "rotate(180deg)"
    }
  }, children));
};

var MessageEditorDisplayer = function MessageEditorDisplayer(_ref) {
  var onMessageChange = _ref.onMessageChange,
      message = _ref.message,
      sendMessage = _ref.sendMessage,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 0 : _ref$id,
      disabled = _ref.disabled;
  return h("div", {
    style: {
      display: 'flex'
    }
  }, h("input", {
    style: {
      flex: 1
    },
    "data-testid": "message".concat(id),
    onInput: onMessageChange,
    value: message,
    name: "message",
    type: "text",
    placeholder: "Enter message text"
  }), h("div", {
    style: {
      display: 'flex'
    }
  }, h("button", {
    "data-testid": "sendMessage".concat(id),
    disabled: message === '' || disabled,
    style: {
      marginLeft: 2,
      width: '100%'
    },
    onClick: sendMessage
  }, h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, h("path", {
    d: "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"
  }), h("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  })))));
};

/* eslint-disable no-shadow */

var MessagesDisplayer = function MessagesDisplayer(_ref) {
  var messages = _ref.messages,
      socket = _ref.socket,
      id = _ref.id,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage,
      handleMessageChange = _ref.handleMessageChange;

  var _useMessageSorter = useMessageSorter(messages),
      sortedMessages = _useMessageSorter.sortedMessages;

  var _useMessageMapper = useMessagesMapper(sortedMessages),
      mappedMessages = _useMessageMapper.mappedMessages;

  return [h(MessageViewScroller, null, h(MessageCollectionView, {
    messages: mappedMessages
  })), h(MessageEditorDisplayer, {
    disabled: socket === null,
    id: id,
    message: messageText,
    sendMessage: sendMessage,
    onMessageChange: handleMessageChange
  })];
};

var css$2 = ".chip{\r\n    background-color: darkgrey;\r\n    color: white;\r\n    width: 20px;\r\n    height: 20px;\r\n    border-radius: 10px;\r\n   line-height: 20px;\r\n}\r\n\r\n.media-height{\r\nheight: 100%;\r\n}\r\n\r\n\r\n.root{\r\n    padding: 3px;\r\n    margin-left: 5px;\r\n    margin-bottom: 5px;\r\n    box-shadow: 0 3px 3px -2px rgba(0,0,0,.2), 0 3px 4px 0 rgba(0,0,0,.14), 0 1px 8px 0 rgba(0,0,0,.12);\r\n}\r\n\r\n.tab-bar{\r\n    padding: 0;\r\n    width: 50%;\r\n    display: flex ;\r\n    justify-content: center;\r\n  \r\n    \r\n}";
styleInject(css$2);

var ChatUser = function ChatUser(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      socket = _ref.socket,
      errors = _ref.errors,
      messages = _ref.messages,
      handleMessageChange = _ref.handleMessageChange,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage;
  return h("div", {
    className: "root",
    style: {
      height: "97%",
      width: "50%"
    }
  }, h(MessagesDisplayer, {
    errors: errors,
    socket: socket,
    messages: messages,
    handleMessageChange: handleMessageChange,
    messageText: messageText,
    sendMessage: sendMessage
  }));
};

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

var useSocketMessaging = function useSocketMessaging(_ref) {
  var socket = _ref.socket,
      targetName = _ref.targetName;

  var _useState = v(''),
      _useState2 = _slicedToArray(_useState, 2),
      messageText = _useState2[0],
      setMessageText = _useState2[1];

  var _useState3 = v(null),
      _useState4 = _slicedToArray(_useState3, 2),
      messageRecieved = _useState4[0],
      setMessageRecieved = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      messageSent = _useState6[0],
      setMessageSent = _useState6[1];

  var _useState7 = v(false),
      _useState8 = _slicedToArray(_useState7, 2),
      connected = _useState8[0],
      setConnected = _useState8[1];

  var _useState9 = v([]),
      _useState10 = _slicedToArray(_useState9, 2),
      errors = _useState10[0],
      setError = _useState10[1];

  var sendMessage = function sendMessage() {
    var datetime = new Date().getTime();
    socket.emit("text_message", {
      reciever: targetName,
      message: messageText,
      datetime: datetime
    });
    setMessageSent({
      reciever: targetName,
      datetime: datetime,
      message: messageText
    });
    setMessageText('');
  };

  var handleMessageChange = function handleMessageChange(e) {
    setMessageText(e.target.value);
  };

  p(function () {
    if (socket !== null) {
      socket.on("text_message", function (data) {
        var sender = data.sender,
            message = data.message,
            datetime = data.datetime;
        setMessageRecieved({
          sender: sender,
          message: message,
          datetime: datetime
        });
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("disconnect", function () {
        setConnected(false);
      });
      socket.on('error', function (error) {
        setError([].concat(toConsumableArray(errors), [error]));
      });
    }
  });
  return {
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    handleMessageChange: handleMessageChange,
    errors: errors,
    connected: connected
  };
};

var useChatLog = function useChatLog(_ref) {
  var name = _ref.name,
      messageRecieved = _ref.messageRecieved,
      messageSent = _ref.messageSent;

  var _useState = v([]),
      _useState2 = _slicedToArray(_useState, 2),
      messages = _useState2[0],
      setMessages = _useState2[1];

  var saveToLocalStorage = function saveToLocalStorage(m, key) {
    var persistedMessages = JSON.parse(localStorage.getItem(key)) === null ? [m] : [].concat(toConsumableArray(JSON.parse(localStorage.getItem(key))), [m]);
    localStorage.setItem(key, JSON.stringify(persistedMessages));
    return persistedMessages;
  }; // componentDidMount


  p(function () {
    setMessages(JSON.parse(localStorage.getItem(name)) === null ? [] : toConsumableArray(JSON.parse(localStorage.getItem(name))));
  }, []); // saveRemoteMessage

  p(function () {
    if (messageRecieved !== null) {
      var datetime = messageRecieved.datetime,
          message = messageRecieved.message,
          sender = messageRecieved.sender;
      var local = false;
      setMessages(saveToLocalStorage({
        message: message,
        from: sender,
        local: local,
        datetime: datetime,
        to: name
      }, name));
    }
  }, [messageRecieved]); // saveLocalMessage

  p(function () {
    if (messageSent !== null) {
      var datetime = messageSent.datetime,
          message = messageSent.message,
          reciever = messageSent.reciever;
      var local = true;
      var from = name;
      setMessages(saveToLocalStorage({
        message: message,
        from: from,
        local: local,
        datetime: datetime,
        to: reciever
      }, name));
    }
  }, [messageSent]);
  return {
    messages: messages
  };
};

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

var parseuri = function parseuri(str) {
  var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');

  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }

  var m = re.exec(str || ''),
      uri = {},
      i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }

  return uri;
};

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h$1 = m * 60;
var d = h$1 * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h$1) {
    return plural(ms, msAbs, h$1, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set `diff` timestamp

      const curr = Number(new Date());
      const ms$$1 = curr - (prevTime || curr);
      self.diff = ms$$1;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    const index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      const instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

var common = setup;

var browser = createCommonjsModule(function (module, exports) {
  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log(...args) {
    // This hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return typeof console === 'object' && console.log && console.log(...args);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    let r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
});
var browser_1 = browser.log;
var browser_2 = browser.formatArgs;
var browser_3 = browser.save;
var browser_4 = browser.load;
var browser_5 = browser.useColors;
var browser_6 = browser.storage;
var browser_7 = browser.colors;

/**
 * Module dependencies.
 */

var debug = browser('socket.io-client:url');
/**
 * Module exports.
 */

var url_1 = url;
/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc) {
  var obj = uri; // default to window.location

  loc = loc || typeof location !== 'undefined' && location;
  if (null == uri) uri = loc.protocol + '//' + loc.host; // relative path support

  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);

      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    } // parse


    debug('parse %s', uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';
  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host; // define unique id

  obj.id = obj.protocol + '://' + host + ':' + obj.port; // define href

  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
  return obj;
}

/**
 * Helpers.
 */
var s$1 = 1000;
var m$1 = s$1 * 60;
var h$2 = m$1 * 60;
var d$1 = h$2 * 24;
var y$1 = d$1 * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse$1(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;

    case 'days':
    case 'day':
    case 'd':
      return n * d$1;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort$1(ms) {
  if (ms >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }

  if (ms >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }

  if (ms >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }

  if (ms >= s$1) {
    return Math.round(ms / s$1) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong$1(ms) {
  return plural$1(ms, d$1, 'day') || plural$1(ms, h$2, 'hour') || plural$1(ms, m$1, 'minute') || plural$1(ms, s$1, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = ms$1;
  /**
   * Active `debug` instances.
   */

  exports.instances = [];
  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};
  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0,
        i;

    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */


  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // disabled?
      if (!debug.enabled) return;
      var self = debug; // set `diff` timestamp

      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr; // turn the `arguments` into a proper Array

      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      } // apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];

        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // apply env-specific formatting (colors, etc.)

      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy; // env-specific initialization logic for debug instances

    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    exports.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = exports.instances.indexOf(this);

    if (index !== -1) {
      exports.instances.splice(index, 1);
      return true;
    } else {
      return false;
    }
  }
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */


  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < exports.instances.length; i++) {
      var instance = exports.instances[i];
      instance.enabled = exports.enabled(instance.namespace);
    }
  }
  /**
   * Disable debug output.
   *
   * @api public
   */


  function disable() {
    exports.enable('');
  }
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i, len;

    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */


  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
});
var debug_1 = debug$1.coerce;
var debug_2 = debug$1.disable;
var debug_3 = debug$1.enable;
var debug_4 = debug$1.enabled;
var debug_5 = debug$1.humanize;
var debug_6 = debug$1.instances;
var debug_7 = debug$1.names;
var debug_8 = debug$1.skips;
var debug_9 = debug$1.formatters;

var browser$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = debug$1;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */


  exports.formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors) return;
    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if ('%%' === match) return;
      index++;

      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    var r;

    try {
      r = exports.storage.debug;
    } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */


  exports.enable(load());
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});
var browser_1$1 = browser$1.log;
var browser_2$1 = browser$1.formatArgs;
var browser_3$1 = browser$1.save;
var browser_4$1 = browser$1.load;
var browser_5$1 = browser$1.useColors;
var browser_6$1 = browser$1.storage;
var browser_7$1 = browser$1.colors;

var componentEmitter = createCommonjsModule(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1),
        callbacks = this._callbacks['$' + event];

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
});

var toString = {}.toString;

var isarray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;
var isArray = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}
Buffer.isBuffer = isBuffer;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read$$1(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read$$1(arr, i + j) !== read$$1(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write$$1(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var isBuffer$1 = isBuf;
var withNativeBuffer = typeof Buffer === 'function' && typeof isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */


function isBuf(obj) {
  return withNativeBuffer && isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
}

/*global Blob,File*/

/**
 * Module requirements
 */

var toString$2 = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$2.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString$2.call(File) === '[object FileConstructor]';
/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

var deconstructPacket = function (packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuffer$1(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (isarray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};

    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }

    return newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */


var reconstructPacket = function (packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isarray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}
/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */


var removeBlobs = function (data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj; // convert any blob

    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
      pendingBlobs++; // async filereader

      var fileReader = new FileReader();

      fileReader.onload = function () {
        // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        } else {
          bloblessData = this.result;
        } // if nothing pending its callback time


        if (! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isarray(obj)) {
      // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuffer$1(obj)) {
      // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;

  _removeBlobs(bloblessData);

  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

var binary = {
  deconstructPacket: deconstructPacket,
  reconstructPacket: reconstructPacket,
  removeBlobs: removeBlobs
};

var socket_ioParser = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser$1('socket.io-parser');
  /**
   * Protocol version.
   *
   * @api public
   */

  exports.protocol = 4;
  /**
   * Packet types.
   *
   * @api public
   */

  exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
  /**
   * Packet type `connect`.
   *
   * @api public
   */

  exports.CONNECT = 0;
  /**
   * Packet type `disconnect`.
   *
   * @api public
   */

  exports.DISCONNECT = 1;
  /**
   * Packet type `event`.
   *
   * @api public
   */

  exports.EVENT = 2;
  /**
   * Packet type `ack`.
   *
   * @api public
   */

  exports.ACK = 3;
  /**
   * Packet type `error`.
   *
   * @api public
   */

  exports.ERROR = 4;
  /**
   * Packet type 'binary event'
   *
   * @api public
   */

  exports.BINARY_EVENT = 5;
  /**
   * Packet type `binary ack`. For acks with binary arguments.
   *
   * @api public
   */

  exports.BINARY_ACK = 6;
  /**
   * Encoder constructor.
   *
   * @api public
   */

  exports.Encoder = Encoder;
  /**
   * Decoder constructor.
   *
   * @api public
   */

  exports.Decoder = Decoder;
  /**
   * A socket.io Encoder instance
   *
   * @api public
   */

  function Encoder() {}

  var ERROR_PACKET = exports.ERROR + '"encode error"';
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   * @param {Function} callback - function to handle encodings (likely engine.write)
   * @return Calls callback with Array of encodings
   * @api public
   */

  Encoder.prototype.encode = function (obj, callback) {
    debug('encoding packet %j', obj);

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      encodeAsBinary(obj, callback);
    } else {
      var encoding = encodeAsString(obj);
      callback([encoding]);
    }
  };
  /**
   * Encode packet as string.
   *
   * @param {Object} packet
   * @return {String} encoded
   * @api private
   */


  function encodeAsString(obj) {
    // first is type
    var str = '' + obj.type; // attachments if we have them

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      str += obj.attachments + '-';
    } // if we have a namespace other than `/`
    // we append it followed by a comma `,`


    if (obj.nsp && '/' !== obj.nsp) {
      str += obj.nsp + ',';
    } // immediately followed by the id


    if (null != obj.id) {
      str += obj.id;
    } // json data


    if (null != obj.data) {
      var payload = tryStringify(obj.data);

      if (payload !== false) {
        str += payload;
      } else {
        return ERROR_PACKET;
      }
    }

    debug('encoded %j as %s', obj, str);
    return str;
  }

  function tryStringify(str) {
    try {
      return JSON.stringify(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   *
   * @param {Object} packet
   * @return {Buffer} encoded
   * @api private
   */


  function encodeAsBinary(obj, callback) {
    function writeEncoding(bloblessData) {
      var deconstruction = binary.deconstructPacket(bloblessData);
      var pack = encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      callback(buffers); // write all the buffers
    }

    binary.removeBlobs(obj, writeEncoding);
  }
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   * @api public
   */


  function Decoder() {
    this.reconstructor = null;
  }
  /**
   * Mix in `Emitter` with Decoder.
   */


  componentEmitter(Decoder.prototype);
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   * @return {Object} packet
   * @api public
   */

  Decoder.prototype.add = function (obj) {
    var packet;

    if (typeof obj === 'string') {
      packet = decodeString(obj);

      if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
        // binary packet's json
        this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

        if (this.reconstructor.reconPack.attachments === 0) {
          this.emit('decoded', packet);
        }
      } else {
        // non-binary full packet
        this.emit('decoded', packet);
      }
    } else if (isBuffer$1(obj) || obj.base64) {
      // raw binary data
      if (!this.reconstructor) {
        throw new Error('got binary data when not reconstructing a packet');
      } else {
        packet = this.reconstructor.takeBinaryData(obj);

        if (packet) {
          // received final buffer
          this.reconstructor = null;
          this.emit('decoded', packet);
        }
      }
    } else {
      throw new Error('Unknown type: ' + obj);
    }
  };
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   * @api private
   */


  function decodeString(str) {
    var i = 0; // look up type

    var p$$1 = {
      type: Number(str.charAt(0))
    };

    if (null == exports.types[p$$1.type]) {
      return error('unknown packet type ' + p$$1.type);
    } // look up attachments if type binary


    if (exports.BINARY_EVENT === p$$1.type || exports.BINARY_ACK === p$$1.type) {
      var buf = '';

      while (str.charAt(++i) !== '-') {
        buf += str.charAt(i);
        if (i == str.length) break;
      }

      if (buf != Number(buf) || str.charAt(i) !== '-') {
        throw new Error('Illegal attachments');
      }

      p$$1.attachments = Number(buf);
    } // look up namespace (if any)


    if ('/' === str.charAt(i + 1)) {
      p$$1.nsp = '';

      while (++i) {
        var c = str.charAt(i);
        if (',' === c) break;
        p$$1.nsp += c;
        if (i === str.length) break;
      }
    } else {
      p$$1.nsp = '/';
    } // look up id


    var next = str.charAt(i + 1);

    if ('' !== next && Number(next) == next) {
      p$$1.id = '';

      while (++i) {
        var c = str.charAt(i);

        if (null == c || Number(c) != c) {
          --i;
          break;
        }

        p$$1.id += str.charAt(i);
        if (i === str.length) break;
      }

      p$$1.id = Number(p$$1.id);
    } // look up json data


    if (str.charAt(++i)) {
      var payload = tryParse(str.substr(i));
      var isPayloadValid = payload !== false && (p$$1.type === exports.ERROR || isarray(payload));

      if (isPayloadValid) {
        p$$1.data = payload;
      } else {
        return error('invalid payload');
      }
    }

    debug('decoded %s as %j', str, p$$1);
    return p$$1;
  }

  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Deallocates a parser's resources
   *
   * @api public
   */


  Decoder.prototype.destroy = function () {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  };
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   * @api private
   */


  function BinaryReconstructor(packet) {
    this.reconPack = packet;
    this.buffers = [];
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   * @api private
   */


  BinaryReconstructor.prototype.takeBinaryData = function (binData) {
    this.buffers.push(binData);

    if (this.buffers.length === this.reconPack.attachments) {
      // done with buffer list
      var packet = binary.reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }

    return null;
  };
  /**
   * Cleans up binary packet reconstruction variables.
   *
   * @api private
   */


  BinaryReconstructor.prototype.finishedReconstruction = function () {
    this.reconPack = null;
    this.buffers = [];
  };

  function error(msg) {
    return {
      type: exports.ERROR,
      data: 'parser error: ' + msg
    };
  }
});
var socket_ioParser_1 = socket_ioParser.protocol;
var socket_ioParser_2 = socket_ioParser.types;
var socket_ioParser_3 = socket_ioParser.CONNECT;
var socket_ioParser_4 = socket_ioParser.DISCONNECT;
var socket_ioParser_5 = socket_ioParser.EVENT;
var socket_ioParser_6 = socket_ioParser.ACK;
var socket_ioParser_7 = socket_ioParser.ERROR;
var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
var socket_ioParser_10 = socket_ioParser.Encoder;
var socket_ioParser_11 = socket_ioParser.Decoder;

var hasCors = createCommonjsModule(function (module) {
  /**
   * Module exports.
   *
   * Logic borrowed from Modernizr:
   *
   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
   */
  try {
    module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
    module.exports = false;
  }
});

var xmlhttprequest = function (opts) {
  var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

  var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217

  var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE

  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
      return new XMLHttpRequest();
    }
  } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example


  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) {}
  }
};

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */
var keys = Object.keys || function keys(obj) {
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }

  return arr;
};

var toString$3 = {}.toString;

var isarray$1 = Array.isArray || function (arr) {
  return toString$3.call(arr) == '[object Array]';
};

/* global Blob File */

/*
 * Module requirements.
 */

var toString$4 = Object.prototype.toString;
var withNativeBlob$1 = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$4.call(Blob) === '[object BlobConstructor]';
var withNativeFile$1 = typeof File === 'function' || typeof File !== 'undefined' && toString$4.call(File) === '[object FileConstructor]';
/**
 * Module exports.
 */

var hasBinary2 = hasBinary;
/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isarray$1(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (typeof Buffer === 'function' && isBuffer && isBuffer(obj) || typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
    return true;
  } // see: https://github.com/Automattic/has-binary/pull/4


  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */
var arraybuffer_slice = function (arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) {
    return arraybuffer.slice(start, end);
  }

  if (start < 0) {
    start += bytes;
  }

  if (end < 0) {
    end += bytes;
  }

  if (end > bytes) {
    end = bytes;
  }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);

  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }

  return result.buffer;
};

var after_1 = after;

function after(count, callback, err_cb) {
  var bail = false;
  err_cb = err_cb || noop;
  proxy.count = count;
  return count === 0 ? callback() : proxy;

  function proxy(err, result) {
    if (proxy.count <= 0) {
      throw new Error('after called too many times');
    }

    --proxy.count; // after first error, rest are passed to err_cb

    if (err) {
      bail = true;
      callback(err); // future error callbacks will go to error handler

      callback = err_cb;
    } else if (proxy.count === 0 && !bail) {
      callback(null, result);
    }
  }
}

function noop() {}

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode

function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  var value;
  var extra;

  while (counter < length) {
    value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
} // Taken from https://mths.be/punycode


function ucs2encode(array) {
  var length = array.length;
  var index = -1;
  var value;
  var output = '';

  while (++index < length) {
    value = array[index];

    if (value > 0xFFFF) {
      value -= 0x10000;
      output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      value = 0xDC00 | value & 0x3FF;
    }

    output += stringFromCharCode(value);
  }

  return output;
}

function checkScalarValue(codePoint, strict) {
  if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    if (strict) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }

    return false;
  }

  return true;
}
/*--------------------------------------------------------------------------*/


function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
}

function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 0xFFFFFF80) == 0) {
    // 1-byte sequence
    return stringFromCharCode(codePoint);
  }

  var symbol = '';

  if ((codePoint & 0xFFFFF800) == 0) {
    // 2-byte sequence
    symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
  } else if ((codePoint & 0xFFFF0000) == 0) {
    // 3-byte sequence
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 0xFFFD;
    }

    symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 0xFFE00000) == 0) {
    // 4-byte sequence
    symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }

  symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
  return symbol;
}

function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length = codePoints.length;
  var index = -1;
  var codePoint;
  var byteString = '';

  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint, strict);
  }

  return byteString;
}
/*--------------------------------------------------------------------------*/


function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error('Invalid byte index');
  }

  var continuationByte = byteArray[byteIndex] & 0xFF;
  byteIndex++;

  if ((continuationByte & 0xC0) == 0x80) {
    return continuationByte & 0x3F;
  } // If we end up here, it’s not a continuation byte


  throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;

  if (byteIndex > byteCount) {
    throw Error('Invalid byte index');
  }

  if (byteIndex == byteCount) {
    return false;
  } // Read first byte


  byte1 = byteArray[byteIndex] & 0xFF;
  byteIndex++; // 1-byte sequence (no continuation bytes)

  if ((byte1 & 0x80) == 0) {
    return byte1;
  } // 2-byte sequence


  if ((byte1 & 0xE0) == 0xC0) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 0x1F) << 6 | byte2;

    if (codePoint >= 0x80) {
      return codePoint;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 3-byte sequence (may include unpaired surrogates)


  if ((byte1 & 0xF0) == 0xE0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;

    if (codePoint >= 0x0800) {
      return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 4-byte sequence


  if ((byte1 & 0xF8) == 0xF0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;

    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      return codePoint;
    }
  }

  throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;

function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;

  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }

  return ucs2encode(codePoints);
}

var utf8 = {
  version: '2.1.2',
  encode: utf8encode,
  decode: utf8decode
};

var base64Arraybuffer = createCommonjsModule(function (module, exports) {
  /*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
  (function () {

    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index.

    var lookup = new Uint8Array(256);

    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }

    exports.encode = function (arraybuffer) {
      var bytes = new Uint8Array(arraybuffer),
          i,
          len = bytes.length,
          base64 = "";

      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }

      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }

      return base64;
    };

    exports.decode = function (base64) {
      var bufferLength = base64.length * 0.75,
          len = base64.length,
          i,
          p$$1 = 0,
          encoded1,
          encoded2,
          encoded3,
          encoded4;

      if (base64[base64.length - 1] === "=") {
        bufferLength--;

        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }

      var arraybuffer = new ArrayBuffer(bufferLength),
          bytes = new Uint8Array(arraybuffer);

      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p$$1++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p$$1++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p$$1++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }

      return arraybuffer;
    };
  })();
});
var base64Arraybuffer_1 = base64Arraybuffer.encode;
var base64Arraybuffer_2 = base64Arraybuffer.decode;

/**
 * Create a blob builder even when vendor prefixes exist
 */
var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : false;
/**
 * Check if Blob constructor is supported
 */

var blobSupported = function () {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */


var blobSupportsArrayBufferView = blobSupported && function () {
  try {
    var b = new Blob([new Uint8Array([1, 2])]);
    return b.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if BlobBuilder is supported
 */


var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function (chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer; // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer

      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};
  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function (part) {
    bb.append(part);
  });
  return options.type ? bb.getBlob(options.type) : bb.getBlob();
}

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
}

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

var blob = function () {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
}();

var browser$2 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var base64encoder;

  if (typeof ArrayBuffer !== 'undefined') {
    base64encoder = base64Arraybuffer;
  }
  /**
   * Check if we are running an android browser. That requires us to use
   * ArrayBuffer with polling transports...
   *
   * http://ghinda.net/jpeg-blob-ajax-android/
   */


  var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
  /**
   * Check if we are running in PhantomJS.
   * Uploading a Blob with PhantomJS does not work correctly, as reported here:
   * https://github.com/ariya/phantomjs/issues/11395
   * @type boolean
   */

  var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
  /**
   * When true, avoids using Blobs to encode payloads.
   * @type boolean
   */

  var dontSendBlobs = isAndroid || isPhantomJS;
  /**
   * Current protocol version.
   */

  exports.protocol = 3;
  /**
   * Packet types.
   */

  var packets = exports.packets = {
    open: 0 // non-ws
    ,
    close: 1 // non-ws
    ,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = keys(packets);
  /**
   * Premade error packet.
   */

  var err = {
    type: 'error',
    data: 'parser error'
  };
  /**
   * Create a blob api even for blob builder when vendor prefixes exist
   */

  /**
   * Encodes a packet.
   *
   *     <packet type id> [ <data> ]
   *
   * Example:
   *
   *     5hello world
   *     3
   *     4
   *
   * Binary is encoded in an identical principle
   *
   * @api private
   */

  exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = false;
    }

    if (typeof utf8encode === 'function') {
      callback = utf8encode;
      utf8encode = null;
    }

    var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

    if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
      return encodeArrayBuffer(packet, supportsBinary, callback);
    } else if (typeof blob !== 'undefined' && data instanceof blob) {
      return encodeBlob(packet, supportsBinary, callback);
    } // might be an object with { base64: true, data: dataAsBase64String }


    if (data && data.base64) {
      return encodeBase64Object(packet, callback);
    } // Sending data as a utf-8 string


    var encoded = packets[packet.type]; // data fragment is optional

    if (undefined !== packet.data) {
      encoded += utf8encode ? utf8.encode(String(packet.data), {
        strict: false
      }) : String(packet.data);
    }

    return callback('' + encoded);
  };

  function encodeBase64Object(packet, callback) {
    // packet data is an object { base64: true, data: dataAsBase64String }
    var message = 'b' + exports.packets[packet.type] + packet.data.data;
    return callback(message);
  }
  /**
   * Encode packet helpers for binary types
   */


  function encodeArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var data = packet.data;
    var contentArray = new Uint8Array(data);
    var resultBuffer = new Uint8Array(1 + data.byteLength);
    resultBuffer[0] = packets[packet.type];

    for (var i = 0; i < contentArray.length; i++) {
      resultBuffer[i + 1] = contentArray[i];
    }

    return callback(resultBuffer.buffer);
  }

  function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var fr = new FileReader();

    fr.onload = function () {
      exports.encodePacket({
        type: packet.type,
        data: fr.result
      }, supportsBinary, true, callback);
    };

    return fr.readAsArrayBuffer(packet.data);
  }

  function encodeBlob(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    if (dontSendBlobs) {
      return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
    }

    var length = new Uint8Array(1);
    length[0] = packets[packet.type];
    var blob$$1 = new blob([length.buffer, packet.data]);
    return callback(blob$$1);
  }
  /**
   * Encodes a packet with binary data in a base64 string
   *
   * @param {Object} packet, has `type` and `data`
   * @return {String} base64 encoded message
   */


  exports.encodeBase64Packet = function (packet, callback) {
    var message = 'b' + exports.packets[packet.type];

    if (typeof blob !== 'undefined' && packet.data instanceof blob) {
      var fr = new FileReader();

      fr.onload = function () {
        var b64 = fr.result.split(',')[1];
        callback(message + b64);
      };

      return fr.readAsDataURL(packet.data);
    }

    var b64data;

    try {
      b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
    } catch (e) {
      // iPhone Safari doesn't let you apply with typed arrays
      var typed = new Uint8Array(packet.data);
      var basic = new Array(typed.length);

      for (var i = 0; i < typed.length; i++) {
        basic[i] = typed[i];
      }

      b64data = String.fromCharCode.apply(null, basic);
    }

    message += btoa(b64data);
    return callback(message);
  };
  /**
   * Decodes a packet. Changes format to Blob if requested.
   *
   * @return {Object} with `type` and `data` (if any)
   * @api private
   */


  exports.decodePacket = function (data, binaryType, utf8decode) {
    if (data === undefined) {
      return err;
    } // String data


    if (typeof data === 'string') {
      if (data.charAt(0) === 'b') {
        return exports.decodeBase64Packet(data.substr(1), binaryType);
      }

      if (utf8decode) {
        data = tryDecode(data);

        if (data === false) {
          return err;
        }
      }

      var type = data.charAt(0);

      if (Number(type) != type || !packetslist[type]) {
        return err;
      }

      if (data.length > 1) {
        return {
          type: packetslist[type],
          data: data.substring(1)
        };
      } else {
        return {
          type: packetslist[type]
        };
      }
    }

    var asArray = new Uint8Array(data);
    var type = asArray[0];
    var rest = arraybuffer_slice(data, 1);

    if (blob && binaryType === 'blob') {
      rest = new blob([rest]);
    }

    return {
      type: packetslist[type],
      data: rest
    };
  };

  function tryDecode(data) {
    try {
      data = utf8.decode(data, {
        strict: false
      });
    } catch (e) {
      return false;
    }

    return data;
  }
  /**
   * Decodes a packet encoded in a base64 string
   *
   * @param {String} base64 encoded message
   * @return {Object} with `type` and `data` (if any)
   */


  exports.decodeBase64Packet = function (msg, binaryType) {
    var type = packetslist[msg.charAt(0)];

    if (!base64encoder) {
      return {
        type: type,
        data: {
          base64: true,
          data: msg.substr(1)
        }
      };
    }

    var data = base64encoder.decode(msg.substr(1));

    if (binaryType === 'blob' && blob) {
      data = new blob([data]);
    }

    return {
      type: type,
      data: data
    };
  };
  /**
   * Encodes multiple messages (payload).
   *
   *     <length>:data
   *
   * Example:
   *
   *     11:hello world2:hi
   *
   * If any contents are binary, they will be encoded as base64 strings. Base64
   * encoded strings are marked with a b before the length specifier
   *
   * @param {Array} packets
   * @api private
   */


  exports.encodePayload = function (packets, supportsBinary, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = null;
    }

    var isBinary = hasBinary2(packets);

    if (supportsBinary && isBinary) {
      if (blob && !dontSendBlobs) {
        return exports.encodePayloadAsBlob(packets, callback);
      }

      return exports.encodePayloadAsArrayBuffer(packets, callback);
    }

    if (!packets.length) {
      return callback('0:');
    }

    function setLengthHeader(message) {
      return message.length + ':' + message;
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
        doneCallback(null, setLengthHeader(message));
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(results.join(''));
    });
  };
  /**
   * Async array map using after
   */


  function map(ary, each, done) {
    var result = new Array(ary.length);
    var next = after_1(ary.length, done);

    var eachWithIndex = function (i, el, cb) {
      each(el, function (error, msg) {
        result[i] = msg;
        cb(error, result);
      });
    };

    for (var i = 0; i < ary.length; i++) {
      eachWithIndex(i, ary[i], next);
    }
  }
  /*
   * Decodes data when a payload is maybe expected. Possible binary contents are
   * decoded from their base64 representation
   *
   * @param {String} data, callback method
   * @api public
   */


  exports.decodePayload = function (data, binaryType, callback) {
    if (typeof data !== 'string') {
      return exports.decodePayloadAsBinary(data, binaryType, callback);
    }

    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var packet;

    if (data === '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    var length = '',
        n,
        msg;

    for (var i = 0, l = data.length; i < l; i++) {
      var chr = data.charAt(i);

      if (chr !== ':') {
        length += chr;
        continue;
      }

      if (length === '' || length != (n = Number(length))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, false);

        if (err.type === packet.type && err.data === packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      } // advance cursor


      i += n;
      length = '';
    }

    if (length !== '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }
  };
  /**
   * Encodes multiple messages (payload) as binary.
   *
   * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
   * 255><data>
   *
   * Example:
   * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
   *
   * @param {Array} packets
   * @return {ArrayBuffer} encoded payload
   * @api private
   */


  exports.encodePayloadAsArrayBuffer = function (packets, callback) {
    if (!packets.length) {
      return callback(new ArrayBuffer(0));
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (data) {
        return doneCallback(null, data);
      });
    }

    map(packets, encodeOne, function (err, encodedPackets) {
      var totalLength = encodedPackets.reduce(function (acc, p$$1) {
        var len;

        if (typeof p$$1 === 'string') {
          len = p$$1.length;
        } else {
          len = p$$1.byteLength;
        }

        return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
      }, 0);
      var resultArray = new Uint8Array(totalLength);
      var bufferIndex = 0;
      encodedPackets.forEach(function (p$$1) {
        var isString = typeof p$$1 === 'string';
        var ab = p$$1;

        if (isString) {
          var view = new Uint8Array(p$$1.length);

          for (var i = 0; i < p$$1.length; i++) {
            view[i] = p$$1.charCodeAt(i);
          }

          ab = view.buffer;
        }

        if (isString) {
          // not true binary
          resultArray[bufferIndex++] = 0;
        } else {
          // true binary
          resultArray[bufferIndex++] = 1;
        }

        var lenStr = ab.byteLength.toString();

        for (var i = 0; i < lenStr.length; i++) {
          resultArray[bufferIndex++] = parseInt(lenStr[i]);
        }

        resultArray[bufferIndex++] = 255;
        var view = new Uint8Array(ab);

        for (var i = 0; i < view.length; i++) {
          resultArray[bufferIndex++] = view[i];
        }
      });
      return callback(resultArray.buffer);
    });
  };
  /**
   * Encode as Blob
   */


  exports.encodePayloadAsBlob = function (packets, callback) {
    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (encoded) {
        var binaryIdentifier = new Uint8Array(1);
        binaryIdentifier[0] = 1;

        if (typeof encoded === 'string') {
          var view = new Uint8Array(encoded.length);

          for (var i = 0; i < encoded.length; i++) {
            view[i] = encoded.charCodeAt(i);
          }

          encoded = view.buffer;
          binaryIdentifier[0] = 0;
        }

        var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
        var lenStr = len.toString();
        var lengthAry = new Uint8Array(lenStr.length + 1);

        for (var i = 0; i < lenStr.length; i++) {
          lengthAry[i] = parseInt(lenStr[i]);
        }

        lengthAry[lenStr.length] = 255;

        if (blob) {
          var blob$$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
          doneCallback(null, blob$$1);
        }
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(new blob(results));
    });
  };
  /*
   * Decodes data when a payload is maybe expected. Strings are decoded by
   * interpreting each byte as a key code for entries marked to start with 0. See
   * description of encodePayloadAsBinary
   *
   * @param {ArrayBuffer} data, callback method
   * @api public
   */


  exports.decodePayloadAsBinary = function (data, binaryType, callback) {
    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var bufferTail = data;
    var buffers = [];

    while (bufferTail.byteLength > 0) {
      var tailArray = new Uint8Array(bufferTail);
      var isString = tailArray[0] === 0;
      var msgLength = '';

      for (var i = 1;; i++) {
        if (tailArray[i] === 255) break; // 310 = char length of Number.MAX_VALUE

        if (msgLength.length > 310) {
          return callback(err, 0, 1);
        }

        msgLength += tailArray[i];
      }

      bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
      msgLength = parseInt(msgLength);
      var msg = arraybuffer_slice(bufferTail, 0, msgLength);

      if (isString) {
        try {
          msg = String.fromCharCode.apply(null, new Uint8Array(msg));
        } catch (e) {
          // iPhone Safari doesn't let you apply to typed arrays
          var typed = new Uint8Array(msg);
          msg = '';

          for (var i = 0; i < typed.length; i++) {
            msg += String.fromCharCode(typed[i]);
          }
        }
      }

      buffers.push(msg);
      bufferTail = arraybuffer_slice(bufferTail, msgLength);
    }

    var total = buffers.length;
    buffers.forEach(function (buffer, i) {
      callback(exports.decodePacket(buffer, binaryType, true), i, total);
    });
  };
});
var browser_1$2 = browser$2.protocol;
var browser_2$2 = browser$2.packets;
var browser_3$2 = browser$2.encodePacket;
var browser_4$2 = browser$2.encodeBase64Packet;
var browser_5$2 = browser$2.decodePacket;
var browser_6$2 = browser$2.decodeBase64Packet;
var browser_7$2 = browser$2.encodePayload;
var browser_8 = browser$2.decodePayload;
var browser_9 = browser$2.encodePayloadAsArrayBuffer;
var browser_10 = browser$2.encodePayloadAsBlob;
var browser_11 = browser$2.decodePayloadAsBinary;

/**
 * Module dependencies.
 */

/**
 * Module exports.
 */

var transport = Transport;
/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport(opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode; // results of ReactNative environment detection

  this.isReactNative = opts.isReactNative; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Transport.prototype);
/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};
/**
 * Opens the transport.
 *
 * @api public
 */


Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};
/**
 * Closes the transport.
 *
 * @api private
 */


Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};
/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */


Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};
/**
 * Called upon open
 *
 * @api private
 */


Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};
/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */


Transport.prototype.onData = function (data) {
  var packet = browser$2.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};
/**
 * Called with a decoded packet.
 */


Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon close.
 *
 * @api private
 */


Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
var encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */


var decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');

  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }

  return qry;
};

var parseqs = {
  encode: encode,
  decode: decode
};

var componentInherit = function (a, b) {
  var fn = function () {};

  fn.prototype = b.prototype;
  a.prototype = new fn();
  a.prototype.constructor = a;
};

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */

function encode$1(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */


function decode$1(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */


function yeast() {
  var now = encode$1(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode$1(seed++);
} //
// Map each character to its index.
//


for (; i < length; i++) map[alphabet[i]] = i; //
// Expose the `yeast`, `encode` and `decode` functions.
//


yeast.encode = encode$1;
yeast.decode = decode$1;
var yeast_1 = yeast;

/**
 * Module dependencies.
 */

var debug$2 = browser('engine.io-client:polling');
/**
 * Module exports.
 */

var polling = Polling;
/**
 * Is XHR2 supported?
 */

var hasXHR2 = function () {
  var XMLHttpRequest = xmlhttprequest;
  var xhr = new XMLHttpRequest({
    xdomain: false
  });
  return null != xhr.responseType;
}();
/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */


function Polling(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(Polling, transport);
/**
 * Transport name.
 */

Polling.prototype.name = 'polling';
/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};
/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */


Polling.prototype.pause = function (onPause) {
  var self = this;
  this.readyState = 'pausing';

  function pause() {
    debug$2('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug$2('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug$2('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug$2('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug$2('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};
/**
 * Starts polling cycle.
 *
 * @api public
 */


Polling.prototype.poll = function () {
  debug$2('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};
/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */


Polling.prototype.onData = function (data) {
  var self = this;
  debug$2('polling got data %s', data);

  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    } // if its a close packet, we close the ongoing requests


    if ('close' === packet.type) {
      self.onClose();
      return false;
    } // otherwise bypass onData and handle the message


    self.onPacket(packet);
  }; // decode payload


  browser$2.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing

  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug$2('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};
/**
 * For polling, send a close packet.
 *
 * @api private
 */


Polling.prototype.doClose = function () {
  var self = this;

  function close() {
    debug$2('writing close packet');
    self.write([{
      type: 'close'
    }]);
  }

  if ('open' === this.readyState) {
    debug$2('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug$2('transport not open - deferring close');
    this.once('open', close);
  }
};
/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */


Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  browser$2.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = ''; // cache busting is forced

  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // avoid port if default for schema

  if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // prepend ? to query


  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/* global attachEvent */

/**
 * Module requirements.
 */

var debug$3 = browser('engine.io-client:polling-xhr');
/**
 * Module exports.
 */

var pollingXhr = XHR;
var Request_1 = Request;
/**
 * Empty function
 */

function empty() {}
/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */


function XHR(opts) {
  polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = typeof location !== 'undefined' && opts.hostname !== location.hostname || port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(XHR, polling);
/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;
/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout; // other options for Node.js client

  opts.extraHeaders = this.extraHeaders;
  return new Request(opts);
};
/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */


XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({
    method: 'POST',
    data: data,
    isBinary: isBinary
  });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


XHR.prototype.doPoll = function () {
  debug$3('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};
/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */


function Request(opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.create();
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Request.prototype);
/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = {
    agent: this.agent,
    xdomain: this.xd,
    xscheme: this.xs,
    enablesXDR: this.enablesXDR
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  var xhr = this.xhr = new xmlhttprequest(opts);
  var self = this;

  try {
    debug$3('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);

    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {} // ie6 check


    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };

      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');

            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }

        if (4 !== xhr.readyState) return;

        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug$3('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};
/**
 * Called upon successful response.
 *
 * @api private
 */


Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};
/**
 * Called if we have data.
 *
 * @api private
 */


Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};
/**
 * Called upon error.
 *
 * @api private
 */


Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};
/**
 * Cleans up house.
 *
 * @api private
 */


Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  } // xmlhttprequest


  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};
/**
 * Called upon load.
 *
 * @api private
 */


Request.prototype.onLoad = function () {
  var data;

  try {
    var contentType;

    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}

    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }

  if (null != data) {
    this.onData(data);
  }
};
/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */


Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};
/**
 * Aborts the request.
 *
 * @api public
 */


Request.prototype.abort = function () {
  this.cleanup();
};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */


Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
pollingXhr.Request = Request_1;

/**
 * Module requirements.
 */

/**
 * Module exports.
 */

var pollingJsonp = JSONPPolling;
/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
/**
 * Global JSONP callbacks.
 */

var callbacks;
/**
 * Noop.
 */

function empty$1() {}
/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */


function glob() {
  return typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : {};
}
/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */


function JSONPPolling(opts) {
  polling.call(this, opts);
  this.query = this.query || {}; // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution

  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = global.___eio || [];
  } // callback identifier


  this.index = callbacks.length; // add callback to jsonp global

  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  }); // append to query string

  this.query.j = this.index; // prevent spurious errors from being emitted when the window is unloaded

  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty$1;
    }, false);
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(JSONPPolling, polling);
/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;
/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  polling.prototype.doClose.call(this);
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();

  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];

  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }

  this.script = script;
  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};
/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */


JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;
    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);
    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete() {
    initIframe();
    fn();
  }

  function initIframe() {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;
    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side

  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

var require$$1$1 = {};

/**
 * Module dependencies.
 */

var debug$4 = browser('engine.io-client:websocket');
var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require$$1$1;
  } catch (e) {}
}
/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */


var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
/**
 * Module exports.
 */

var websocket = WS;
/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (forceBase64) {
    this.supportsBinary = false;
  }

  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;

  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(WS, transport);
/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';
/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;
/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};
/**
 * Adds event listeners to the socket
 *
 * @api private
 */


WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };

  this.ws.onclose = function () {
    self.onClose();
  };

  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };

  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};
/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */


WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false; // encodePacket efficient as it uses WS framing
  // no need for encodePayload

  var total = packets.length;

  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      browser$2.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};

          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;

            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        } // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error


        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug$4('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done() {
    self.emit('flush'); // fake drain
    // defer to next tick to allow Socket to clear writeBuffer

    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};
/**
 * Called upon close
 *
 * @api private
 */


WS.prototype.onClose = function () {
  transport.prototype.onClose.call(this);
};
/**
 * Closes socket.
 *
 * @api private
 */


WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = ''; // avoid port if default for schema

  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // append timestamp to URI


  if (this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  } // communicate binary support capabilities


  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // prepend ? to query

  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};
/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */


WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/**
 * Module dependencies
 */

/**
 * Export transports.
 */

var polling_1 = polling$1;
var websocket_1 = websocket;
/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling$1(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new xmlhttprequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new pollingXhr(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new pollingJsonp(opts);
  }
}

var transports = {
  polling: polling_1,
  websocket: websocket_1
};

var indexOf = [].indexOf;

var indexof = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/**
 * Module dependencies.
 */

var debug$5 = browser('engine.io-client:socket');
/**
 * Module exports.
 */

var socket = Socket;
/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);
  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure : typeof location !== 'undefined' && 'https:' === location.protocol;

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port ? location.port : this.secure ? 443 : 80);
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
  if (true === this.perMessageDeflate) this.perMessageDeflate = {};

  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  } // SSL options for Node.js client


  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode; // detect ReactNative environment

  this.isReactNative = typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative'; // other options for Node.js or ReactNative client

  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  } // set on handshake


  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null; // set on heartbeat

  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;
  this.open();
}

Socket.priorWebsocketSuccess = false;
/**
 * Mix in `Emitter`.
 */

componentEmitter(Socket.prototype);
/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = browser$2.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = transport;
Socket.transports = transports;
Socket.parser = browser$2;
/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug$5('creating transport "%s"', name);
  var query = clone(this.query); // append engine.io protocol identifier

  query.EIO = browser$2.protocol; // transport name

  query.transport = name; // per-transport options

  var options = this.transportOptions[name] || {}; // session id if we already have one

  if (this.id) query.sid = this.id;
  var transport$$1 = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void 0,
    isReactNative: this.isReactNative
  });
  return transport$$1;
};

function clone(obj) {
  var o = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }

  return o;
}
/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */


Socket.prototype.open = function () {
  var transport$$1;

  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport$$1 = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport$$1 = this.transports[0];
  }

  this.readyState = 'opening'; // Retry with the next transport if the transport is disabled (jsonp: false)

  try {
    transport$$1 = this.createTransport(transport$$1);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport$$1.open();
  this.setTransport(transport$$1);
};
/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */


Socket.prototype.setTransport = function (transport$$1) {
  debug$5('setting transport %s', transport$$1.name);
  var self = this;

  if (this.transport) {
    debug$5('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  } // set up transport


  this.transport = transport$$1; // set up transport listeners

  transport$$1.on('drain', function () {
    self.onDrain();
  }).on('packet', function (packet) {
    self.onPacket(packet);
  }).on('error', function (e) {
    self.onError(e);
  }).on('close', function () {
    self.onClose('transport close');
  });
};
/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */


Socket.prototype.probe = function (name) {
  debug$5('probing transport "%s"', name);
  var transport$$1 = this.createTransport(name, {
    probe: 1
  });
  var failed = false;
  var self = this;
  Socket.priorWebsocketSuccess = false;

  function onTransportOpen() {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }

    if (failed) return;
    debug$5('probe transport "%s" opened', name);
    transport$$1.send([{
      type: 'ping',
      data: 'probe'
    }]);
    transport$$1.once('packet', function (msg) {
      if (failed) return;

      if ('pong' === msg.type && 'probe' === msg.data) {
        debug$5('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport$$1);
        if (!transport$$1) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport$$1.name;
        debug$5('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug$5('changing transport and sending upgrade packet');
          cleanup();
          self.setTransport(transport$$1);
          transport$$1.send([{
            type: 'upgrade'
          }]);
          self.emit('upgrade', transport$$1);
          transport$$1 = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug$5('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport$$1.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return; // Any callback called by transport should be ignored since now

    failed = true;
    cleanup();
    transport$$1.close();
    transport$$1 = null;
  } // Handle any error that happens while probing


  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport$$1.name;
    freezeTransport();
    debug$5('probe transport "%s" failed because of error: %s', name, err);
    self.emit('upgradeError', error);
  }

  function onTransportClose() {
    onerror('transport closed');
  } // When the socket is closed while we're probing


  function onclose() {
    onerror('socket closed');
  } // When the socket is upgraded while we're probing


  function onupgrade(to) {
    if (transport$$1 && to.name !== transport$$1.name) {
      debug$5('"%s" works - aborting "%s"', to.name, transport$$1.name);
      freezeTransport();
    }
  } // Remove all listeners on the transport and on self


  function cleanup() {
    transport$$1.removeListener('open', onTransportOpen);
    transport$$1.removeListener('error', onerror);
    transport$$1.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport$$1.once('open', onTransportOpen);
  transport$$1.once('error', onerror);
  transport$$1.once('close', onTransportClose);
  this.once('close', onclose);
  this.once('upgrading', onupgrade);
  transport$$1.open();
};
/**
 * Called when connection is deemed open.
 *
 * @api public
 */


Socket.prototype.onOpen = function () {
  debug$5('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush(); // we check for `readyState` in case an `open`
  // listener already closed the socket

  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug$5('starting upgrade probes');

    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};
/**
 * Handles a packet.
 *
 * @api private
 */


Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);
    this.emit('packet', packet); // Socket is live - any packet counts

    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug$5('packet received with socket readyState "%s"', this.readyState);
  }
};
/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */


Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen(); // In case open handler closes socket

  if ('closed' === this.readyState) return;
  this.setPing(); // Prolong liveness of socket on heartbeat

  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};
/**
 * Resets ping timeout.
 *
 * @api private
 */


Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || self.pingInterval + self.pingTimeout);
};
/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */


Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug$5('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};
/**
* Sends a ping packet.
*
* @api private
*/


Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};
/**
 * Called on `drain` event
 *
 * @api private
 */


Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`

  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};
/**
 * Flush write buffers.
 *
 * @api private
 */


Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
    debug$5('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`

    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};
/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */


Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};
/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */


Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;
  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};
/**
 * Closes the connection.
 *
 * @api private
 */


Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';
    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug$5('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};
/**
 * Called upon transport error
 *
 * @api private
 */


Socket.prototype.onError = function (err) {
  debug$5('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};
/**
 * Called upon transport close.
 *
 * @api private
 */


Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket close with reason: "%s"', reason);
    var self = this; // clear timers

    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport

    this.transport.removeAllListeners('close'); // ensure transport won't stay open

    this.transport.close(); // ignore further transport communication

    this.transport.removeAllListeners(); // set ready state

    this.readyState = 'closed'; // clear session id

    this.id = null; // emit close event

    this.emit('close', reason, desc); // clean buffers after, so users can still
    // grab the buffers on `close` event

    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};
/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */


Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];

  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~indexof(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }

  return filteredUpgrades;
};

var lib = socket;
/**
 * Exports parser
 *
 * @api public
 *
 */

var parser = browser$2;
lib.parser = parser;

var toArray_1 = toArray;

function toArray(list, index) {
  var array = [];
  index = index || 0;

  for (var i = index || 0; i < list.length; i++) {
    array[i - index] = list[i];
  }

  return array;
}

/**
 * Module exports.
 */
var on_1 = on;
/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

/**
 * Slice reference.
 */
var slice = [].slice;
/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

var componentBind = function (obj, fn) {
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function () {
    return fn.apply(obj, args.concat(slice.call(arguments)));
  };
};

var socket$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client:socket');
  /**
   * Module exports.
   */

  module.exports = exports = Socket;
  /**
   * Internal events (blacklisted).
   * These events can't be emitted by the user.
   *
   * @api private
   */

  var events = {
    connect: 1,
    connect_error: 1,
    connect_timeout: 1,
    connecting: 1,
    disconnect: 1,
    error: 1,
    reconnect: 1,
    reconnect_attempt: 1,
    reconnect_failed: 1,
    reconnect_error: 1,
    reconnecting: 1,
    ping: 1,
    pong: 1
  };
  /**
   * Shortcut to `Emitter#emit`.
   */

  var emit = componentEmitter.prototype.emit;
  /**
   * `Socket` constructor.
   *
   * @api public
   */

  function Socket(io, nsp, opts) {
    this.io = io;
    this.nsp = nsp;
    this.json = this; // compat

    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    this.flags = {};

    if (opts && opts.query) {
      this.query = opts.query;
    }

    if (this.io.autoConnect) this.open();
  }
  /**
   * Mix in `Emitter`.
   */


  componentEmitter(Socket.prototype);
  /**
   * Subscribe to open, close and packet events
   *
   * @api private
   */

  Socket.prototype.subEvents = function () {
    if (this.subs) return;
    var io = this.io;
    this.subs = [on_1(io, 'open', componentBind(this, 'onopen')), on_1(io, 'packet', componentBind(this, 'onpacket')), on_1(io, 'close', componentBind(this, 'onclose'))];
  };
  /**
   * "Opens" the socket.
   *
   * @api public
   */


  Socket.prototype.open = Socket.prototype.connect = function () {
    if (this.connected) return this;
    this.subEvents();
    this.io.open(); // ensure open

    if ('open' === this.io.readyState) this.onopen();
    this.emit('connecting');
    return this;
  };
  /**
   * Sends a `message` event.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.send = function () {
    var args = toArray_1(arguments);
    args.unshift('message');
    this.emit.apply(this, args);
    return this;
  };
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @param {String} event name
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.emit = function (ev) {
    if (events.hasOwnProperty(ev)) {
      emit.apply(this, arguments);
      return this;
    }

    var args = toArray_1(arguments);
    var packet = {
      type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback

    if ('function' === typeof args[args.length - 1]) {
      debug('emitting packet with ack id %d', this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }

    if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }

    this.flags = {};
    return this;
  };
  /**
   * Sends a packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.packet = function (packet) {
    packet.nsp = this.nsp;
    this.io.packet(packet);
  };
  /**
   * Called upon engine `open`.
   *
   * @api private
   */


  Socket.prototype.onopen = function () {
    debug('transport is open - connecting'); // write connect packet if necessary

    if ('/' !== this.nsp) {
      if (this.query) {
        var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
        debug('sending connect packet with query %s', query);
        this.packet({
          type: socket_ioParser.CONNECT,
          query: query
        });
      } else {
        this.packet({
          type: socket_ioParser.CONNECT
        });
      }
    }
  };
  /**
   * Called upon engine `close`.
   *
   * @param {String} reason
   * @api private
   */


  Socket.prototype.onclose = function (reason) {
    debug('close (%s)', reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emit('disconnect', reason);
  };
  /**
   * Called with socket packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onpacket = function (packet) {
    var sameNamespace = packet.nsp === this.nsp;
    var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === '/';
    if (!sameNamespace && !rootNamespaceError) return;

    switch (packet.type) {
      case socket_ioParser.CONNECT:
        this.onconnect();
        break;

      case socket_ioParser.EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.BINARY_EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.ACK:
        this.onack(packet);
        break;

      case socket_ioParser.BINARY_ACK:
        this.onack(packet);
        break;

      case socket_ioParser.DISCONNECT:
        this.ondisconnect();
        break;

      case socket_ioParser.ERROR:
        this.emit('error', packet.data);
        break;
    }
  };
  /**
   * Called upon a server event.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onevent = function (packet) {
    var args = packet.data || [];
    debug('emitting event %j', args);

    if (null != packet.id) {
      debug('attaching ack callback to event');
      args.push(this.ack(packet.id));
    }

    if (this.connected) {
      emit.apply(this, args);
    } else {
      this.receiveBuffer.push(args);
    }
  };
  /**
   * Produces an ack callback to emit with an event.
   *
   * @api private
   */


  Socket.prototype.ack = function (id) {
    var self = this;
    var sent = false;
    return function () {
      // prevent double callbacks
      if (sent) return;
      sent = true;
      var args = toArray_1(arguments);
      debug('sending ack %j', args);
      self.packet({
        type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
        id: id,
        data: args
      });
    };
  };
  /**
   * Called upon a server acknowlegement.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onack = function (packet) {
    var ack = this.acks[packet.id];

    if ('function' === typeof ack) {
      debug('calling ack %s with %j', packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug('bad ack %s', packet.id);
    }
  };
  /**
   * Called upon server connect.
   *
   * @api private
   */


  Socket.prototype.onconnect = function () {
    this.connected = true;
    this.disconnected = false;
    this.emit('connect');
    this.emitBuffered();
  };
  /**
   * Emit buffered events (received and emitted).
   *
   * @api private
   */


  Socket.prototype.emitBuffered = function () {
    var i;

    for (i = 0; i < this.receiveBuffer.length; i++) {
      emit.apply(this, this.receiveBuffer[i]);
    }

    this.receiveBuffer = [];

    for (i = 0; i < this.sendBuffer.length; i++) {
      this.packet(this.sendBuffer[i]);
    }

    this.sendBuffer = [];
  };
  /**
   * Called upon server disconnect.
   *
   * @api private
   */


  Socket.prototype.ondisconnect = function () {
    debug('server disconnect (%s)', this.nsp);
    this.destroy();
    this.onclose('io server disconnect');
  };
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @api private.
   */


  Socket.prototype.destroy = function () {
    if (this.subs) {
      // clean subscriptions to avoid reconnections
      for (var i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }

      this.subs = null;
    }

    this.io.destroy(this);
  };
  /**
   * Disconnects the socket manually.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.close = Socket.prototype.disconnect = function () {
    if (this.connected) {
      debug('performing disconnect (%s)', this.nsp);
      this.packet({
        type: socket_ioParser.DISCONNECT
      });
    } // remove socket from pool


    this.destroy();

    if (this.connected) {
      // fire events
      this.onclose('io client disconnect');
    }

    return this;
  };
  /**
   * Sets the compress flag.
   *
   * @param {Boolean} if `true`, compresses the sending data
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.compress = function (compress) {
    this.flags.compress = compress;
    return this;
  };
  /**
   * Sets the binary flag
   *
   * @param {Boolean} whether the emitted data contains binary
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.binary = function (binary) {
    this.flags.binary = binary;
    return this;
  };
});

/**
 * Expose `Backoff`.
 */
var backo2 = Backoff;
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */


Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);

  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }

  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */


Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */


Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */


Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */


Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/**
 * Module dependencies.
 */

var debug$6 = browser('socket.io-client:manager');
/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;
/**
 * Module exports
 */

var manager = Manager;
/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new backo2({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];

  var _parser = opts.parser || socket_ioParser;

  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}
/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */


Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);

  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};
/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */


Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};
/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */


Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
};
/**
 * Mix in `Emitter`.
 */


componentEmitter(Manager.prototype);
/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v$$1) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v$$1;
  return this;
};
/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionAttempts = function (v$$1) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v$$1;
  return this;
};
/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelay = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v$$1;
  this.backoff && this.backoff.setMin(v$$1);
  return this;
};

Manager.prototype.randomizationFactor = function (v$$1) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v$$1;
  this.backoff && this.backoff.setJitter(v$$1);
  return this;
};
/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelayMax = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v$$1;
  this.backoff && this.backoff.setMax(v$$1);
  return this;
};
/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.timeout = function (v$$1) {
  if (!arguments.length) return this._timeout;
  this._timeout = v$$1;
  return this;
};
/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */


Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};
/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */


Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
  debug$6('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;
  debug$6('opening %s', this.uri);
  this.engine = lib(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false; // emit `open`

  var openSub = on_1(socket, 'open', function () {
    self.onopen();
    fn && fn();
  }); // emit `connect_error`

  var errorSub = on_1(socket, 'error', function (data) {
    debug$6('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);

    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  }); // emit `connect_timeout`

  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug$6('connect attempt will timeout after %d', timeout); // set timer

    var timer = setTimeout(function () {
      debug$6('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);
  return this;
};
/**
 * Called upon transport open.
 *
 * @api private
 */


Manager.prototype.onopen = function () {
  debug$6('open'); // clear old subs

  this.cleanup(); // mark as open

  this.readyState = 'open';
  this.emit('open'); // add new subs

  var socket = this.engine;
  this.subs.push(on_1(socket, 'data', componentBind(this, 'ondata')));
  this.subs.push(on_1(socket, 'ping', componentBind(this, 'onping')));
  this.subs.push(on_1(socket, 'pong', componentBind(this, 'onpong')));
  this.subs.push(on_1(socket, 'error', componentBind(this, 'onerror')));
  this.subs.push(on_1(socket, 'close', componentBind(this, 'onclose')));
  this.subs.push(on_1(this.decoder, 'decoded', componentBind(this, 'ondecoded')));
};
/**
 * Called upon a ping.
 *
 * @api private
 */


Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};
/**
 * Called upon a packet.
 *
 * @api private
 */


Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};
/**
 * Called with data.
 *
 * @api private
 */


Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};
/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */


Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon socket error.
 *
 * @api private
 */


Manager.prototype.onerror = function (err) {
  debug$6('error', err);
  this.emitAll('error', err);
};
/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */


Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];

  if (!socket) {
    socket = new socket$1(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexof(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};
/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */


Manager.prototype.destroy = function (socket) {
  var index = indexof(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;
  this.close();
};
/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */


Manager.prototype.packet = function (packet) {
  debug$6('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }

      self.encoding = false;
      self.processPacketQueue();
    });
  } else {
    // add packet to the queue
    self.packetBuffer.push(packet);
  }
};
/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */


Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};
/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */


Manager.prototype.cleanup = function () {
  debug$6('cleanup');
  var subsLength = this.subs.length;

  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;
  this.decoder.destroy();
};
/**
 * Close the current socket.
 *
 * @api private
 */


Manager.prototype.close = Manager.prototype.disconnect = function () {
  debug$6('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;

  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }

  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};
/**
 * Called upon engine close.
 *
 * @api private
 */


Manager.prototype.onclose = function (reason) {
  debug$6('onclose');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};
/**
 * Attempt a reconnection.
 *
 * @api private
 */


Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;
  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug$6('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug$6('will wait %dms before reconnect attempt', delay);
    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;
      debug$6('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events

      if (self.skipReconnect) return;
      self.open(function (err) {
        if (err) {
          debug$6('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug$6('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};
/**
 * Called upon successful reconnect.
 *
 * @api private
 */


Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

var lib$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client');
  /**
   * Module exports.
   */

  module.exports = exports = lookup;
  /**
   * Managers cache.
   */

  var cache = exports.managers = {};
  /**
   * Looks up an existing `Manager` for multiplexing.
   * If the user summons:
   *
   *   `io('http://localhost/a');`
   *   `io('http://localhost/b');`
   *
   * We reuse the existing instance based on same scheme/port/host,
   * and we initialize sockets for each namespace.
   *
   * @api public
   */

  function lookup(uri, opts) {
    if (typeof uri === 'object') {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    var parsed = url_1(uri);
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] && path in cache[id].nsps;
    var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
    var io;

    if (newConnection) {
      debug('ignoring socket cache for %s', source);
      io = manager(source, opts);
    } else {
      if (!cache[id]) {
        debug('new io instance for %s', source);
        cache[id] = manager(source, opts);
      }

      io = cache[id];
    }

    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }

    return io.socket(parsed.path, opts);
  }
  /**
   * Protocol version.
   *
   * @api public
   */


  exports.protocol = socket_ioParser.protocol;
  /**
   * `connect`.
   *
   * @param {String} uri
   * @api public
   */

  exports.connect = lookup;
  /**
   * Expose constructors for standalone build.
   *
   * @api public
   */

  exports.Manager = manager;
  exports.Socket = socket$1;
});
var lib_1 = lib$1.managers;
var lib_2 = lib$1.protocol;
var lib_3 = lib$1.connect;
var lib_4 = lib$1.Manager;
var lib_5 = lib$1.Socket;

var useSocket = function useSocket(_ref) {
  var username = _ref.username,
      _ref$route = _ref.route,
      route = _ref$route === void 0 ? '/anonymous' : _ref$route,
      serverUrl = _ref.serverUrl;

  var _useState = v(null),
      _useState2 = _slicedToArray(_useState, 2),
      socket = _useState2[0],
      setSocket = _useState2[1];

  var _useState3 = v(false),
      _useState4 = _slicedToArray(_useState3, 2),
      connected = _useState4[0],
      setConnected = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      socketError = _useState6[0],
      setSocketError = _useState6[1];

  p(function () {
    function fetchToken() {
      var response, data;
      return _regeneratorRuntime.async(function fetchToken$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return _regeneratorRuntime.awrap(fetch(route, {
                method: "POST",
                body: JSON.stringify({
                  username: username
                }),
                headers: {
                  "Content-Type": "application/json"
                }
              }));

            case 3:
              response = _context.sent;
              _context.next = 6;
              return _regeneratorRuntime.awrap(response.json());

            case 6:
              data = _context.sent;
              setSocket(lib$1(serverUrl, {
                query: "token=".concat(data.token)
              }));
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](0);
              setSocketError(_context.t0);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[0, 10]]);
    }

    fetchToken();
  }, []);
  p(function () {
    if (socket !== null) {
      socket.on("error", function (error) {
        setSocketError(error);
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("message", function () {});
    }
  }, [socket]);
  return {
    socket: socket,
    connected: connected,
    socketError: socketError
  };
};

var useSocketClient = function useSocketClient(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      route = _ref.route,
      serverUrl = _ref.serverUrl;

  var _useSocket = useSocket({
    username: name,
    route: route,
    serverUrl: serverUrl
  }),
      socket = _useSocket.socket,
      connected = _useSocket.connected,
      socketError = _useSocket.socketError;

  var _useSocketMessaging = useSocketMessaging({
    socket: socket,
    targetName: targetName
  }),
      errors = _useSocketMessaging.errors,
      handleMessageChange = _useSocketMessaging.handleMessageChange,
      messageRecieved = _useSocketMessaging.messageRecieved,
      messageSent = _useSocketMessaging.messageSent,
      messageText = _useSocketMessaging.messageText,
      sendMessage = _useSocketMessaging.sendMessage;

  var _useChatLog = useChatLog({
    name: name,
    messageRecieved: messageRecieved,
    messageSent: messageSent
  }),
      messages = _useChatLog.messages;

  return {
    messages: messages,
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    errors: errors,
    connected: connected,
    handleMessageChange: handleMessageChange
  };
};

var ChatRoom = function ChatRoom() {
  var _useState = v(0),
      _useState2 = _slicedToArray(_useState, 2),
      msgForMario = _useState2[0],
      setMsgForMario = _useState2[1];

  var _useState3 = v(0),
      _useState4 = _slicedToArray(_useState3, 2),
      msgForDragos = _useState4[0],
      setMsgForDragos = _useState4[1];

  var _useState5 = v(0),
      _useState6 = _slicedToArray(_useState5, 2),
      selectedItem = _useState6[0],
      setSelectedItem = _useState6[1];

  var _useSocketClient = useSocketClient({
    name: "mario",
    targetName: "dragos",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgMario = _useSocketClient.messages,
      msgRecMario = _useSocketClient.messageRecieved,
      msgSntMario = _useSocketClient.messageSent,
      msgTxtMario = _useSocketClient.messageText,
      sendMsgMario = _useSocketClient.sendMessage,
      errMario = _useSocketClient.errors,
      cntMario = _useSocketClient.connected,
      hdleMessageChageMario = _useSocketClient.handleMessageChange,
      marioSocket = _useSocketClient.socket;

  var _useSocketClient2 = useSocketClient({
    name: "dragos",
    targetName: "mario",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgDragos = _useSocketClient2.messages,
      msgRecDragos = _useSocketClient2.messageRecieved,
      msgSntDragos = _useSocketClient2.messageSent,
      msgTxtDragos = _useSocketClient2.messageText,
      sendMsgDragos = _useSocketClient2.sendMessage,
      errDragos = _useSocketClient2.errors,
      cntDragos = _useSocketClient2.connected,
      hdleMessageChageDragos = _useSocketClient2.handleMessageChange,
      dragosSocket = _useSocketClient2.socket;

  p(function () {
    if (msgForDragos !== null) setMsgForDragos(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecDragos]);
  p(function () {
    if (msgForMario !== null) setMsgForMario(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecMario]);
  p(function () {
    if (selectedItem === 0) {
      setMsgForMario(0);
    } else {
      setMsgForDragos(0);
    }
  }, [selectedItem]);
  return h("div", {
    style: {
      width: "100%",
      height: "100%"
    }
  }, h("div", {
    className: "tab-bar"
  }, h("div", null, h(TabBar, null, h(TabBar.Tab, {
    active: true,
    onClick: function onClick() {
      return setSelectedItem(0);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntMario ? "green" : "orange"
    }
  }, "mario"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForMario > 0 ? "green" : "darkgrey"
    }
  }, msgForMario)))), h(TabBar.Tab, {
    onClick: function onClick() {
      return setSelectedItem(1);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntDragos ? "green" : "orange"
    }
  }, "dragos"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForDragos > 0 ? "green" : "darkgrey"
    }
  }, msgForDragos))))))), selectedItem === 0 && h(ChatUser, {
    handleMessageChange: hdleMessageChageMario,
    connected: cntMario,
    errors: errMario,
    messageSent: msgSntMario,
    messageText: msgTxtMario,
    messages: msgMario,
    sendMessage: sendMsgMario,
    messageRecieved: msgRecMario,
    socket: dragosSocket,
    name: "mario",
    targetName: "dragos"
  }), selectedItem === 1 && h(ChatUser, {
    handleMessageChange: hdleMessageChageDragos,
    connected: cntDragos,
    errors: errDragos,
    messageSent: msgSntDragos,
    messageText: msgTxtDragos,
    messages: msgDragos,
    sendMessage: sendMsgDragos,
    messageRecieved: msgRecDragos,
    socket: dragosSocket,
    name: "dragos",
    targetName: "mario"
  }));
};

var SocketIOMessaging = function SocketIOMessaging() {
  return h(ChatRoom, null);
};

var WebRTCMessaging = function WebRTCMessaging() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTC Messaging");
};

var WebRTCVideoChat = function WebRTCVideoChat() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTCVideoChat");
};

export { SocketIOMessaging as a, WebRTCMessaging as b, WebRTCVideoChat as c };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmstYzUwZThlY2QuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3IvYWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3IvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9zbGlkaW5nLWZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3IvZmFkaW5nLWZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9hZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvYWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL3J0bC1zY3JvbGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL3J0bC1kZWZhdWx0LXNjcm9sbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLW5lZ2F0aXZlLXNjcm9sbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLXJldmVyc2Utc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvdXRpbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItYmFyL2FkYXB0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItYmFyL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJlYWN0LW1hdGVyaWFsLWNvbXBvbmVudHMvVGFiQmFyL2luZGV4LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvZGF0ZS1saW5lYnJlYWsuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1vYmplY3QtbWFwcGVyL21lc3NhZ2UtYWxpZ25lci5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1vYmplY3QtbWFwcGVyL21lc3NhZ2Utdmlldy5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1vYmplY3QtbWFwcGVyL3N1YnNlcXVlbnQtbWVzc2FnZS5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1vYmplY3QtbWFwcGVyL21lc3NhZ2UtYXZhdGFyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvZmlyc3QtbWVzc2FnZS5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1vYmplY3QtbWFwcGVyL21lc3NhZ2Utb2JqZWN0LW1hcHBlci5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvdXNlTWVzc2FnZVNvcnRlci5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvdXNlTWVzc2FnZU1hcHBlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2UtY29sbGVjdGlvbi12aWV3LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlcy12aWV3LXNjcm9sbGVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZS1lZGl0b3ItZGlzcGxheWVyL2luZGV4LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlcy1kaXNwbGF5ZXIuanMiLCIuLi9tb2R1bGVzL3NvY2tldC1pby1tZXNzYWdpbmcvQ2hhdFVzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS1ob29rcy9zb2NrZXQtaW8tbWVzc2FnaW5nL3VzZVNvY2tldE1lc3NhZ2luZy5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLWhvb2tzL3VzZUNoYXRMb2cuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9iYXNlNjQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9pZWVlNzU0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvaXNBcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi91dGY4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXJlc29sdmUvc3JjL2VtcHR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtaG9va3Mvc29ja2V0LWlvLW1lc3NhZ2luZy91c2VTb2NrZXQuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS1ob29rcy9zb2NrZXQtaW8tbWVzc2FnaW5nL3VzZVNvY2tldENsaWVudC5qcyIsIi4uL21vZHVsZXMvc29ja2V0LWlvLW1lc3NhZ2luZy9DaGF0Um9vbS5qcyIsIi4uL21vZHVsZXMvc29ja2V0LWlvLW1lc3NhZ2luZy9pbmRleC5qcyIsIi4uL21vZHVsZXMvd2VicnRjLW1lc3NhZ2luZy9pbmRleC5qcyIsIi4uL21vZHVsZXMvd2VicnRjLXZpZGVvLWNoYXQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBGXG4gKi9cbmNsYXNzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENDb21wb25lbnR9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIC8vIFN1YmNsYXNzZXMgd2hpY2ggZXh0ZW5kIE1EQ0Jhc2Ugc2hvdWxkIHByb3ZpZGUgYW4gYXR0YWNoVG8oKSBtZXRob2QgdGhhdCB0YWtlcyBhIHJvb3QgZWxlbWVudCBhbmRcbiAgICAvLyByZXR1cm5zIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQgd2l0aCBpdHMgcm9vdCBzZXQgdG8gdGhhdCBlbGVtZW50LiBBbHNvIG5vdGUgdGhhdCBpbiB0aGUgY2FzZXMgb2ZcbiAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgIC8vIGZyb20gZ2V0RGVmYXVsdEZvdW5kYXRpb24oKS5cbiAgICByZXR1cm4gbmV3IE1EQ0NvbXBvbmVudChyb290LCBuZXcgTURDRm91bmRhdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7Rj19IGZvdW5kYXRpb25cbiAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBmb3VuZGF0aW9uID0gdW5kZWZpbmVkLCAuLi5hcmdzKSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSguLi5hcmdzKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3MgZGVmYXVsdCBwYXJhbSBzbyB0aGF0XG4gICAgLy8gdGhpcy5yb290XyBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFGfSAqL1xuICAgIHRoaXMuZm91bmRhdGlvbl8gPSBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgIHRoaXMuZm91bmRhdGlvbl8uaW5pdCgpO1xuICAgIHRoaXMuaW5pdGlhbFN5bmNXaXRoRE9NKCk7XG4gIH1cblxuICBpbml0aWFsaXplKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgIC8vIFwiY29uc3RydWN0b3JcIi4gRXNzZW50aWFsbHksIGl0IGlzIGEgaG9vayBpbnRvIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHRoZSBmb3VuZGF0aW9uIGlzXG4gICAgLy8gaW5pdGlhbGl6ZWQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBiZXNpZGVzIHJvb3QgYW5kIGZvdW5kYXRpb24gd2lsbCBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRn0gZm91bmRhdGlvblxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgLy8gY29tcG9uZW50LlxuICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldERlZmF1bHRGb3VuZGF0aW9uIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgJyArXG4gICAgICAnZm91bmRhdGlvbiBjbGFzcycpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgbmVlZCB0byBwZXJmb3JtIHdvcmsgdG8gc3luY2hyb25pemUgd2l0aCBhIGhvc3QgRE9NXG4gICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIHNvbWUgcHJvcGVydHkgb3IgYXR0cmlidXRlIG9mIHRoZSBob3N0IERPTS4gUGxlYXNlIG5vdGU6IHRoaXMgaXMgKm5vdCogdGhlIHBsYWNlIHRvIHBlcmZvcm0gRE9NXG4gICAgLy8gcmVhZHMvd3JpdGVzIHRoYXQgd291bGQgY2F1c2UgbGF5b3V0IC8gcGFpbnQsIGFzIHRoaXMgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlciBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZVxuICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogbGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiB1bmxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBjcm9zcy1icm93c2VyLWNvbXBhdGlibGUgY3VzdG9tIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudCByb290IG9mIHRoZSBnaXZlbiB0eXBlLFxuICAgKiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFPYmplY3R9IGV2dERhdGFcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQnViYmxlXG4gICAqL1xuICBlbWl0KGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGV2dDtcbiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5yb290Xy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ29tcG9uZW50O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBGXG4gKi9cbmNsYXNzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENDb21wb25lbnR9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIC8vIFN1YmNsYXNzZXMgd2hpY2ggZXh0ZW5kIE1EQ0Jhc2Ugc2hvdWxkIHByb3ZpZGUgYW4gYXR0YWNoVG8oKSBtZXRob2QgdGhhdCB0YWtlcyBhIHJvb3QgZWxlbWVudCBhbmRcbiAgICAvLyByZXR1cm5zIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQgd2l0aCBpdHMgcm9vdCBzZXQgdG8gdGhhdCBlbGVtZW50LiBBbHNvIG5vdGUgdGhhdCBpbiB0aGUgY2FzZXMgb2ZcbiAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgIC8vIGZyb20gZ2V0RGVmYXVsdEZvdW5kYXRpb24oKS5cbiAgICByZXR1cm4gbmV3IE1EQ0NvbXBvbmVudChyb290LCBuZXcgTURDRm91bmRhdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7Rj19IGZvdW5kYXRpb25cbiAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBmb3VuZGF0aW9uID0gdW5kZWZpbmVkLCAuLi5hcmdzKSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSguLi5hcmdzKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3MgZGVmYXVsdCBwYXJhbSBzbyB0aGF0XG4gICAgLy8gdGhpcy5yb290XyBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFGfSAqL1xuICAgIHRoaXMuZm91bmRhdGlvbl8gPSBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgIHRoaXMuZm91bmRhdGlvbl8uaW5pdCgpO1xuICAgIHRoaXMuaW5pdGlhbFN5bmNXaXRoRE9NKCk7XG4gIH1cblxuICBpbml0aWFsaXplKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgIC8vIFwiY29uc3RydWN0b3JcIi4gRXNzZW50aWFsbHksIGl0IGlzIGEgaG9vayBpbnRvIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHRoZSBmb3VuZGF0aW9uIGlzXG4gICAgLy8gaW5pdGlhbGl6ZWQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBiZXNpZGVzIHJvb3QgYW5kIGZvdW5kYXRpb24gd2lsbCBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRn0gZm91bmRhdGlvblxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgLy8gY29tcG9uZW50LlxuICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldERlZmF1bHRGb3VuZGF0aW9uIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgJyArXG4gICAgICAnZm91bmRhdGlvbiBjbGFzcycpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgbmVlZCB0byBwZXJmb3JtIHdvcmsgdG8gc3luY2hyb25pemUgd2l0aCBhIGhvc3QgRE9NXG4gICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIHNvbWUgcHJvcGVydHkgb3IgYXR0cmlidXRlIG9mIHRoZSBob3N0IERPTS4gUGxlYXNlIG5vdGU6IHRoaXMgaXMgKm5vdCogdGhlIHBsYWNlIHRvIHBlcmZvcm0gRE9NXG4gICAgLy8gcmVhZHMvd3JpdGVzIHRoYXQgd291bGQgY2F1c2UgbGF5b3V0IC8gcGFpbnQsIGFzIHRoaXMgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlciBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZVxuICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogbGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiB1bmxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBjcm9zcy1icm93c2VyLWNvbXBhdGlibGUgY3VzdG9tIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudCByb290IG9mIHRoZSBnaXZlbiB0eXBlLFxuICAgKiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFPYmplY3R9IGV2dERhdGFcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQnViYmxlXG4gICAqL1xuICBlbWl0KGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGV2dDtcbiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5yb290Xy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ29tcG9uZW50O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBGXG4gKi9cbmNsYXNzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENDb21wb25lbnR9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIC8vIFN1YmNsYXNzZXMgd2hpY2ggZXh0ZW5kIE1EQ0Jhc2Ugc2hvdWxkIHByb3ZpZGUgYW4gYXR0YWNoVG8oKSBtZXRob2QgdGhhdCB0YWtlcyBhIHJvb3QgZWxlbWVudCBhbmRcbiAgICAvLyByZXR1cm5zIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQgd2l0aCBpdHMgcm9vdCBzZXQgdG8gdGhhdCBlbGVtZW50LiBBbHNvIG5vdGUgdGhhdCBpbiB0aGUgY2FzZXMgb2ZcbiAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgIC8vIGZyb20gZ2V0RGVmYXVsdEZvdW5kYXRpb24oKS5cbiAgICByZXR1cm4gbmV3IE1EQ0NvbXBvbmVudChyb290LCBuZXcgTURDRm91bmRhdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7Rj19IGZvdW5kYXRpb25cbiAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBmb3VuZGF0aW9uID0gdW5kZWZpbmVkLCAuLi5hcmdzKSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSguLi5hcmdzKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3MgZGVmYXVsdCBwYXJhbSBzbyB0aGF0XG4gICAgLy8gdGhpcy5yb290XyBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFGfSAqL1xuICAgIHRoaXMuZm91bmRhdGlvbl8gPSBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgIHRoaXMuZm91bmRhdGlvbl8uaW5pdCgpO1xuICAgIHRoaXMuaW5pdGlhbFN5bmNXaXRoRE9NKCk7XG4gIH1cblxuICBpbml0aWFsaXplKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgIC8vIFwiY29uc3RydWN0b3JcIi4gRXNzZW50aWFsbHksIGl0IGlzIGEgaG9vayBpbnRvIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHRoZSBmb3VuZGF0aW9uIGlzXG4gICAgLy8gaW5pdGlhbGl6ZWQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBiZXNpZGVzIHJvb3QgYW5kIGZvdW5kYXRpb24gd2lsbCBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRn0gZm91bmRhdGlvblxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgLy8gY29tcG9uZW50LlxuICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldERlZmF1bHRGb3VuZGF0aW9uIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgJyArXG4gICAgICAnZm91bmRhdGlvbiBjbGFzcycpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgbmVlZCB0byBwZXJmb3JtIHdvcmsgdG8gc3luY2hyb25pemUgd2l0aCBhIGhvc3QgRE9NXG4gICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIHNvbWUgcHJvcGVydHkgb3IgYXR0cmlidXRlIG9mIHRoZSBob3N0IERPTS4gUGxlYXNlIG5vdGU6IHRoaXMgaXMgKm5vdCogdGhlIHBsYWNlIHRvIHBlcmZvcm0gRE9NXG4gICAgLy8gcmVhZHMvd3JpdGVzIHRoYXQgd291bGQgY2F1c2UgbGF5b3V0IC8gcGFpbnQsIGFzIHRoaXMgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlciBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZVxuICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogbGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiB1bmxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBjcm9zcy1icm93c2VyLWNvbXBhdGlibGUgY3VzdG9tIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudCByb290IG9mIHRoZSBnaXZlbiB0eXBlLFxuICAgKiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFPYmplY3R9IGV2dERhdGFcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQnViYmxlXG4gICAqL1xuICBlbWl0KGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGV2dDtcbiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5yb290Xy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ29tcG9uZW50O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUYWIgSW5kaWNhdG9yLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRhYiBJbmRpY2F0b3IgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RhYkluZGljYXRvckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIHRvIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBhZGRcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIGZyb20gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgcmVjdCBvZiB0aGUgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgY29udGVudCBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFRoZSBzdHlsZSBwcm9wZXJ0eSBuYW1lIHRvIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0eWxlIHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBzZXRDb250ZW50U3R5bGVQcm9wZXJ0eShwcm9wTmFtZSwgdmFsdWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkluZGljYXRvckFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBQ1RJVkU6ICdtZGMtdGFiLWluZGljYXRvci0tYWN0aXZlJyxcbiAgRkFERTogJ21kYy10YWItaW5kaWNhdG9yLS1mYWRlJyxcbiAgTk9fVFJBTlNJVElPTjogJ21kYy10YWItaW5kaWNhdG9yLS1uby10cmFuc2l0aW9uJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ09OVEVOVF9TRUxFQ1RPUjogJy5tZGMtdGFiLWluZGljYXRvcl9fY29udGVudCcsXG59O1xuXG5leHBvcnQge1xuICBjc3NDbGFzc2VzLFxuICBzdHJpbmdzLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUYWJJbmRpY2F0b3JBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge1xuICBjc3NDbGFzc2VzLFxuICBzdHJpbmdzLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RhYkluZGljYXRvckFkYXB0ZXI+fVxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIE1EQ1RhYkluZGljYXRvckFkYXB0ZXIgZm9yIHR5cGluZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYkluZGljYXRvckFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBjb21wdXRlQ29udGVudENsaWVudFJlY3Q6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudFN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYkluZGljYXRvckFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFDbGllbnRSZWN0fSAqL1xuICBjb21wdXRlQ29udGVudENsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBpbmRpY2F0b3JcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdD19IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdFxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKiBAYWJzdHJhY3QgKi9cbiAgZGVhY3RpdmF0ZSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24ge1xuICAvKiogQHBhcmFtIHshQ2xpZW50UmVjdD19IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIGluZGljYXRvciBpcyBwcmVzZW50IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBhbiBpbmRpY2F0b3JcbiAgICAvLyBtYXkgYmUgYWN0aXZhdGVkIHdpdGhvdXQgYSBwcmlvciBpbmRpY2F0b3Igc3RhdGVcbiAgICBpZiAoIXByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGFuaW1hdGlvbiB1c2VzIHRoZSBGTElQIGFwcHJvYWNoLiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBpdCBhdCB0aGUgbGluayBiZWxvdzpcbiAgICAvLyBodHRwczovL2Flcm90d2lzdC5jb20vYmxvZy9mbGlwLXlvdXItYW5pbWF0aW9ucy9cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJldmlvdXMgaW5kaWNhdG9yXG4gICAgY29uc3QgY3VycmVudENsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHdpZHRoRGVsdGEgPSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3Qud2lkdGggLyBjdXJyZW50Q2xpZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCB4UG9zaXRpb24gPSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QubGVmdCAtIGN1cnJlbnRDbGllbnRSZWN0LmxlZnQ7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTk9fVFJBTlNJVElPTik7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoJHt4UG9zaXRpb259cHgpIHNjYWxlWCgke3dpZHRoRGVsdGF9KWApO1xuXG4gICAgLy8gRm9yY2UgcmVwYWludCBiZWZvcmUgdXBkYXRpbmcgY2xhc3NlcyBhbmQgdHJhbnNmb3JtIHRvIGVuc3VyZSB0aGUgdHJhbnNmb3JtIHByb3Blcmx5IHRha2VzIGVmZmVjdFxuICAgIHRoaXMuY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5OT19UUkFOU0lUSU9OKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Q29udGVudFN0eWxlUHJvcGVydHkoJ3RyYW5zZm9ybScsICcnKTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24gZXh0ZW5kcyBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIHtcbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGYWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcblxuaW1wb3J0IE1EQ1RhYkluZGljYXRvckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbmltcG9ydCBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICcuL3NsaWRpbmctZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICcuL2ZhZGluZy1mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDQ29tcG9uZW50PCFNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJJbmRpY2F0b3IgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDVGFiSW5kaWNhdG9yfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYkluZGljYXRvcihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICAvKiogQHR5cGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuY29udGVudF87XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuY29udGVudF8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ1RhYkluZGljYXRvckFkYXB0ZXJ9ICovIChPYmplY3QuYXNzaWduKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdDogKCkgPT4gdGhpcy5jb250ZW50Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHNldENvbnRlbnRTdHlsZVByb3BlcnR5OiAocHJvcCwgdmFsdWUpID0+IHRoaXMuY29udGVudF8uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsdWUpLFxuICAgIH0pKTtcblxuICAgIGlmICh0aGlzLnJvb3RfLmNsYXNzTGlzdC5jb250YWlucyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkFERSkpIHtcbiAgICAgIHJldHVybiBuZXcgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHRoZSBzbGlkaW5nIGluZGljYXRvclxuICAgIHJldHVybiBuZXcgTURDU2xpZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24oYWRhcHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdD19IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdFxuICAgKi9cbiAgYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5hY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlYWN0aXZhdGUoKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYkluZGljYXRvciwgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiwgTURDU2xpZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24sIE1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb259O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIE1EQ1RhYkRpbWVuc2lvbnMgcHJvdmlkZXMgZGV0YWlscyBhYm91dCB0aGUgbGVmdCBhbmQgcmlnaHQgZWRnZXMgb2YgdGhlIFRhYlxuICogcm9vdCBlbGVtZW50IGFuZCB0aGUgVGFiIGNvbnRlbnQgZWxlbWVudC4gVGhlc2UgdmFsdWVzIGFyZSB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgVGFiIHdpdGggcmVzcGVjdCBpdCdzIHBhcmVudCBjb250YWluZXIuXG4gKiBAdHlwZWRlZiB7e3Jvb3RMZWZ0OiBudW1iZXIsIHJvb3RSaWdodDogbnVtYmVyLCBjb250ZW50TGVmdDogbnVtYmVyLCBjb250ZW50UmlnaHQ6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJEaW1lbnNpb25zO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUYWIuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGFiICBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGFiQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzc05hbWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcm9vdCBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGF0dHJOYW1lIG9mIHRoZSByb290IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgc28gZ2l2ZSB0aGUgYXR0cmlidXRlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGluZGljYXRvciBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0IFRoZSBjbGllbnQgcmVjdCBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmF0ZWQgaW5kaWNhdG9yXG4gICAqL1xuICBhY3RpdmF0ZUluZGljYXRvcihwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHt9XG5cbiAgLyoqIERlYWN0aXZhdGVzIHRoZSBpbmRpY2F0b3IuICovXG4gIGRlYWN0aXZhdGVJbmRpY2F0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgTURDVGFiOmludGVyYWN0ZWQgZXZlbnQgZm9yIHVzZSBieSBwYXJlbnQgY29tcG9uZW50c1xuICAgKi9cbiAgbm90aWZ5SW50ZXJhY3RlZCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldExlZnQgdmFsdWUgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0TGVmdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpZHRoIHZhbHVlIG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldE9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0TGVmdCBvZiB0aGUgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRDb250ZW50T2Zmc2V0TGVmdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpZHRoIG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbnRlbnRPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZm9jdXMgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgKi9cbiAgZm9jdXMoKSB7fVxufVxuXG5leHBvcnQge01EQ1RhYkRpbWVuc2lvbnMsIE1EQ1RhYkFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9TRUxFQ1RFRDogJ2FyaWEtc2VsZWN0ZWQnLFxuICBSSVBQTEVfU0VMRUNUT1I6ICcubWRjLXRhYl9fcmlwcGxlJyxcbiAgQ09OVEVOVF9TRUxFQ1RPUjogJy5tZGMtdGFiX19jb250ZW50JyxcbiAgVEFCX0lORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWluZGljYXRvcicsXG4gIFRBQklOREVYOiAndGFiSW5kZXgnLFxuICBJTlRFUkFDVEVEX0VWRU5UOiAnTURDVGFiOmludGVyYWN0ZWQnLFxufTtcblxuZXhwb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYkFkYXB0ZXIsIE1EQ1RhYkRpbWVuc2lvbnN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbmRpY2F0b3I6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUluZGljYXRvcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJbnRlcmFjdGVkOiAoKSA9PiB7fSxcbiAgICAgIGdldE9mZnNldExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29udGVudE9mZnNldExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENUYWJBZGFwdGVyfSBhZGFwdGVyICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaGFuZGxlQ2xpY2tfID0gKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIFwiY2xpY2tcIiBldmVudFxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBrZWVwIHRyYWNrIG9mIHRoZSBhY3RpdmUgVGFiIGFuZFxuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCBhY3RpdmF0ZSBhIFRhYiB0aGF0J3MgYWxyZWFkeSBhY3RpdmUuXG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnRlcmFjdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVGFiJ3MgYWN0aXZlIHN0YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBUYWJcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdD19IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdFxuICAgKi9cbiAgYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuQVJJQV9TRUxFQ1RFRCwgJ3RydWUnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5UQUJJTkRFWCwgJzAnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5kaWNhdG9yKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCk7XG4gICAgdGhpcy5hZGFwdGVyXy5mb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUYWJcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgLy8gRWFybHkgZXhpdFxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuQVJJQV9TRUxFQ1RFRCwgJ2ZhbHNlJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuVEFCSU5ERVgsICctMScpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZUluZGljYXRvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIFRhYlxuICAgKiBAcmV0dXJuIHshTURDVGFiRGltZW5zaW9uc31cbiAgICovXG4gIGNvbXB1dGVEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290TGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0TGVmdCgpO1xuICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29udGVudE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgY29udGVudExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldENvbnRlbnRPZmZzZXRMZWZ0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdExlZnQsXG4gICAgICByb290UmlnaHQ6IHJvb3RMZWZ0ICsgcm9vdFdpZHRoLFxuICAgICAgY29udGVudExlZnQ6IHJvb3RMZWZ0ICsgY29udGVudExlZnQsXG4gICAgICBjb250ZW50UmlnaHQ6IHJvb3RMZWZ0ICsgY29udGVudExlZnQgKyBjb250ZW50V2lkdGgsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDUmlwcGxlLCBNRENSaXBwbGVGb3VuZGF0aW9uLCBSaXBwbGVDYXBhYmxlU3VyZmFjZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG5pbXBvcnQge01EQ1RhYkluZGljYXRvciwgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3IvaW5kZXgnO1xuaW1wb3J0IHtNRENUYWJBZGFwdGVyLCBNRENUYWJEaW1lbnNpb25zfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5pbXBvcnQgTURDVGFiRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYkZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYiBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICAvKiogQHByaXZhdGUgez9NRENSaXBwbGV9ICovXG4gICAgdGhpcy5yaXBwbGVfO1xuICAgIC8qKiBAcHJpdmF0ZSB7P01EQ1RhYkluZGljYXRvcn0gKi9cbiAgICB0aGlzLnRhYkluZGljYXRvcl87XG4gICAgLyoqIEBwcml2YXRlIHs/RWxlbWVudH0gKi9cbiAgICB0aGlzLmNvbnRlbnRfO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVDbGlja187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDVGFifVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYihyb290KTtcbiAgfVxuXG4gIGluaXRpYWxpemUoXG4gICAgcmlwcGxlRmFjdG9yeSA9IChlbCwgZm91bmRhdGlvbikgPT4gbmV3IE1EQ1JpcHBsZShlbCwgZm91bmRhdGlvbiksXG4gICAgdGFiSW5kaWNhdG9yRmFjdG9yeSA9IChlbCkgPT4gbmV3IE1EQ1RhYkluZGljYXRvcihlbCkpIHtcbiAgICBjb25zdCByaXBwbGVTdXJmYWNlID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5SSVBQTEVfU0VMRUNUT1IpO1xuICAgIGNvbnN0IHJpcHBsZUFkYXB0ZXIgPSBPYmplY3QuYXNzaWduKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKC8qKiBAdHlwZSB7IVJpcHBsZUNhcGFibGVTdXJmYWNlfSAqLyAodGhpcykpLCB7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gcmlwcGxlU3VyZmFjZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gcmlwcGxlU3VyZmFjZS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiByaXBwbGVTdXJmYWNlLnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKSxcbiAgICB9KTtcbiAgICBjb25zdCByaXBwbGVGb3VuZGF0aW9uID0gbmV3IE1EQ1JpcHBsZUZvdW5kYXRpb24ocmlwcGxlQWRhcHRlcik7XG4gICAgdGhpcy5yaXBwbGVfID0gcmlwcGxlRmFjdG9yeSh0aGlzLnJvb3RfLCByaXBwbGVGb3VuZGF0aW9uKTtcblxuICAgIGNvbnN0IHRhYkluZGljYXRvckVsZW1lbnQgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9JTkRJQ0FUT1JfU0VMRUNUT1IpO1xuICAgIHRoaXMudGFiSW5kaWNhdG9yXyA9IHRhYkluZGljYXRvckZhY3RvcnkodGFiSW5kaWNhdG9yRWxlbWVudCk7XG5cbiAgICB0aGlzLmNvbnRlbnRfID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5DT05URU5UX1NFTEVDVE9SKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLmhhbmRsZUNsaWNrXyA9IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlQ2xpY2suYmluZCh0aGlzLmZvdW5kYXRpb25fKTtcbiAgICB0aGlzLmxpc3RlbignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5saXN0ZW4oJ2NsaWNrJywgLyoqIEB0eXBlIHshRnVuY3Rpb259ICovICh0aGlzLmhhbmRsZUNsaWNrXykpO1xuICAgIHRoaXMucmlwcGxlXy5kZXN0cm95KCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENUYWJGb3VuZGF0aW9uKFxuICAgICAgLyoqIEB0eXBlIHshTURDVGFiQWRhcHRlcn0gKi8gKHtcbiAgICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLnJvb3RfLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXG4gICAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgICAgYWN0aXZhdGVJbmRpY2F0b3I6IChwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpID0+IHRoaXMudGFiSW5kaWNhdG9yXy5hY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpLFxuICAgICAgICBkZWFjdGl2YXRlSW5kaWNhdG9yOiAoKSA9PiB0aGlzLnRhYkluZGljYXRvcl8uZGVhY3RpdmF0ZSgpLFxuICAgICAgICBub3RpZnlJbnRlcmFjdGVkOiAoKSA9PiB0aGlzLmVtaXQoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNURURfRVZFTlQsIHt0YWI6IHRoaXN9LCB0cnVlIC8qIGJ1YmJsZSAqLyksXG4gICAgICAgIGdldE9mZnNldExlZnQ6ICgpID0+IHRoaXMucm9vdF8ub2Zmc2V0TGVmdCxcbiAgICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMucm9vdF8ub2Zmc2V0V2lkdGgsXG4gICAgICAgIGdldENvbnRlbnRPZmZzZXRMZWZ0OiAoKSA9PiB0aGlzLmNvbnRlbnRfLm9mZnNldExlZnQsXG4gICAgICAgIGdldENvbnRlbnRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy5jb250ZW50Xy5vZmZzZXRXaWR0aCxcbiAgICAgICAgZm9jdXM6ICgpID0+IHRoaXMucm9vdF8uZm9jdXMoKSxcbiAgICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHRhYlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5pc0FjdGl2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGFiXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdFxuICAgKi9cbiAgYWN0aXZhdGUoY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKGNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgdGFiXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGljYXRvcidzIGNsaWVudCByZWN0XG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFiSW5kaWNhdG9yXy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiRGltZW5zaW9uc31cbiAgICovXG4gIGNvbXB1dGVEaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmNvbXB1dGVEaW1lbnNpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgdGFiXG4gICAqL1xuICBmb2N1cygpIHtcbiAgICB0aGlzLnJvb3RfLmZvY3VzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENUYWIsIE1EQ1RhYkZvdW5kYXRpb259O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBGXG4gKi9cbmNsYXNzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENDb21wb25lbnR9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIC8vIFN1YmNsYXNzZXMgd2hpY2ggZXh0ZW5kIE1EQ0Jhc2Ugc2hvdWxkIHByb3ZpZGUgYW4gYXR0YWNoVG8oKSBtZXRob2QgdGhhdCB0YWtlcyBhIHJvb3QgZWxlbWVudCBhbmRcbiAgICAvLyByZXR1cm5zIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQgd2l0aCBpdHMgcm9vdCBzZXQgdG8gdGhhdCBlbGVtZW50LiBBbHNvIG5vdGUgdGhhdCBpbiB0aGUgY2FzZXMgb2ZcbiAgICAvLyBzdWJjbGFzc2VzLCBhbiBleHBsaWNpdCBmb3VuZGF0aW9uIGNsYXNzIHdpbGwgbm90IGhhdmUgdG8gYmUgcGFzc2VkIGluOyBpdCB3aWxsIHNpbXBseSBiZSBpbml0aWFsaXplZFxuICAgIC8vIGZyb20gZ2V0RGVmYXVsdEZvdW5kYXRpb24oKS5cbiAgICByZXR1cm4gbmV3IE1EQ0NvbXBvbmVudChyb290LCBuZXcgTURDRm91bmRhdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7Rj19IGZvdW5kYXRpb25cbiAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCBmb3VuZGF0aW9uID0gdW5kZWZpbmVkLCAuLi5hcmdzKSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFFbGVtZW50fSAqL1xuICAgIHRoaXMucm9vdF8gPSByb290O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSguLi5hcmdzKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgaW5pdGlhbGl6ZSBmb3VuZGF0aW9uIGhlcmUgYW5kIG5vdCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yJ3MgZGVmYXVsdCBwYXJhbSBzbyB0aGF0XG4gICAgLy8gdGhpcy5yb290XyBpcyBkZWZpbmVkIGFuZCBjYW4gYmUgdXNlZCB3aXRoaW4gdGhlIGZvdW5kYXRpb24gY2xhc3MuXG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFGfSAqL1xuICAgIHRoaXMuZm91bmRhdGlvbl8gPSBmb3VuZGF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLmdldERlZmF1bHRGb3VuZGF0aW9uKCkgOiBmb3VuZGF0aW9uO1xuICAgIHRoaXMuZm91bmRhdGlvbl8uaW5pdCgpO1xuICAgIHRoaXMuaW5pdGlhbFN5bmNXaXRoRE9NKCk7XG4gIH1cblxuICBpbml0aWFsaXplKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGRvIGFueSBhZGRpdGlvbmFsIHNldHVwIHdvcmsgdGhhdCB3b3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2YgYVxuICAgIC8vIFwiY29uc3RydWN0b3JcIi4gRXNzZW50aWFsbHksIGl0IGlzIGEgaG9vayBpbnRvIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHRoZSBmb3VuZGF0aW9uIGlzXG4gICAgLy8gaW5pdGlhbGl6ZWQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBiZXNpZGVzIHJvb3QgYW5kIGZvdW5kYXRpb24gd2lsbCBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRn0gZm91bmRhdGlvblxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgZm91bmRhdGlvbiBjbGFzcyBmb3IgdGhlXG4gICAgLy8gY29tcG9uZW50LlxuICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldERlZmF1bHRGb3VuZGF0aW9uIHRvIHJldHVybiBhIHByb3Blcmx5IGNvbmZpZ3VyZWQgJyArXG4gICAgICAnZm91bmRhdGlvbiBjbGFzcycpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgbmVlZCB0byBwZXJmb3JtIHdvcmsgdG8gc3luY2hyb25pemUgd2l0aCBhIGhvc3QgRE9NXG4gICAgLy8gb2JqZWN0LiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgYSBmb3JtIGNvbnRyb2wgd3JhcHBlciB0aGF0IG5lZWRzIHRvIHN5bmNocm9uaXplIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIHNvbWUgcHJvcGVydHkgb3IgYXR0cmlidXRlIG9mIHRoZSBob3N0IERPTS4gUGxlYXNlIG5vdGU6IHRoaXMgaXMgKm5vdCogdGhlIHBsYWNlIHRvIHBlcmZvcm0gRE9NXG4gICAgLy8gcmVhZHMvd3JpdGVzIHRoYXQgd291bGQgY2F1c2UgbGF5b3V0IC8gcGFpbnQsIGFzIHRoaXMgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG1heSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzIC8gZGVyZWdpc3RlciBhbnkgbGlzdGVuZXJzIHRoZXkgaGF2ZVxuICAgIC8vIGF0dGFjaGVkLiBBbiBleGFtcGxlIG9mIHRoaXMgbWlnaHQgYmUgZGVyZWdpc3RlcmluZyBhIHJlc2l6ZSBldmVudCBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogbGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgbGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiB1bmxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHVubGlzdGVuKGV2dFR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBjcm9zcy1icm93c2VyLWNvbXBhdGlibGUgY3VzdG9tIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudCByb290IG9mIHRoZSBnaXZlbiB0eXBlLFxuICAgKiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFPYmplY3R9IGV2dERhdGFcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQnViYmxlXG4gICAqL1xuICBlbWl0KGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGV2dDtcbiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5yb290Xy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ29tcG9uZW50O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uIGNvbnRhaW5zIHRoZSB2YWx1ZXMgcmVxdWlyZWQgZm9yIGFuaW1hdGluZyBmcm9tIHRoZVxuICogY3VycmVudCBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIG5ldyBzY3JvbGwgcG9zaXRpb24uIFRoZSBcImZpbmFsU2Nyb2xsUG9zaXRpb25cIlxuICogdmFsdWUgcmVwcmVzZW50cyB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvbiB3aGlsZSB0aGUgXCJzY3JvbGxEZWx0YVwiIHZhbHVlIGlzIHRoZVxuICogY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1hdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHNjcm9sbCBjb250ZW50LiBUb2dldGhlcixcbiAqIHRoZXkgY3JlYXRlIHRoZSBhbmltYXRpb24gYnkgZmlyc3QgdXBkYXRpbmcgdGhlIHNjcm9sbCB2YWx1ZSB0aGVuIGFwcGx5aW5nXG4gKiB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIGFuaW1hdGluZyB0aGUgdHJhbnNpdGlvbi4gQm90aCBwaWVjZXMgYXJlIG5lY2Vzc2FyeVxuICogZm9yIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHRvIHdvcmsuIFRoZSB2YWx1ZXMgYXJlIHVzZWQgYXMtaXMgYnkgdGhlIHRhYlxuICogc2Nyb2xsZXIgYW5pbWF0aW9uIG1ldGhvZCwgZW5zdXJpbmcgdGhhdCBhbGwgbG9naWMgZm9yIGRldGVybWluaW5nIHNjcm9sbFxuICogcG9zaXRpb24gb3IgdHJhbnNmb3JtYXRpb24gaXMgYWJzdHJhY3RlZCBhd2F5IGZyb20gdGhlIGFuaW1hdGlvbiBtZXRob2QuXG4gKiBAdHlwZWRlZiB7e2ZpbmFsU2Nyb2xsUG9zaXRpb246IG51bWJlciwgc2Nyb2xsRGVsdGE6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJTY3JvbGxlckFuaW1hdGlvbjtcblxuLyoqXG4gKiBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcyByZXByZXNlbnRzIHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlcyBvZiB0aGVcbiAqIHNjcm9sbCBjb250ZW50LiBUaGVzZSB2YWx1ZXMgdmFyeSBkZXBlbmRpbmcgb24gaG93IHNjcm9sbGluZyBpbiBSVEwgaXNcbiAqIGltcGxlbWVudGVkIGJ5IHRoZSBicm93c2VyLiBPbmUgdmFsdWUgaXMgYWx3YXlzIDAgYW5kIG9uZSB2YWx1ZSBpcyBhbHdheXNcbiAqIHRoZSBtYXggc2Nyb2xsYWJsZSB2YWx1ZSBhcyBlaXRoZXIgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyLlxuICogQHR5cGVkZWYge3tsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fVxuICovXG5sZXQgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXM7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYiBTY3JvbGxlci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIHRvIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBhZGRcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIGZyb20gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBhZGRcbiAgICovXG4gIGFkZFNjcm9sbEFyZWFDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZXZlbnQgdGFyZ2V0IG1hdGNoZXMgZ2l2ZW4gY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcihldnRUYXJnZXQsIHNlbGVjdG9yKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGFyZWEgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBjb250ZW50IGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFRoZSBzdHlsZSBwcm9wZXJ0eSBuYW1lIHRvIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0eWxlIHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBzZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eShwcm9wTmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQncyBjb21wdXRlZCBzdHlsZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3NzIHByb3BlcnR5IGBwcm9wZXJ0eU5hbWVgLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBnZXRDb21wdXRlZFN0eWxlKC4uLikuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbExlZnQgVGhlIG5ldyBzY3JvbGxMZWZ0IHZhbHVlXG4gICAqL1xuICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChzY3JvbGxMZWZ0KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBzY3JvbGwgYXJlYSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpZHRoIG9mIHRoZSBzY3JvbGwgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXRXaXRkdGggb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzY3JvbGwgYXJlYSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzY3JvbGwgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVTY3JvbGxDb250ZW50Q2xpZW50UmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgYnJvd3NlcidzIGhvcml6b250YWwgc2Nyb2xsYmFycyAoaW4gcHgpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzLCBNRENUYWJTY3JvbGxlckFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQU5JTUFUSU5HOiAnbWRjLXRhYi1zY3JvbGxlci0tYW5pbWF0aW5nJyxcbiAgU0NST0xMX1RFU1Q6ICdtZGMtdGFiLXNjcm9sbGVyX190ZXN0JyxcbiAgU0NST0xMX0FSRUFfU0NST0xMOiAnbWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEtLXNjcm9sbCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSRUFfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEnLFxuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1jb250ZW50Jyxcbn07XG5cbmV4cG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFkYXB0ZXIsIE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTCB7XG4gIC8qKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYIFRoZSBjdXJyZW50IHRyYW5zbGF0ZVggcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBjdXJyZW50IHNjcm9sbFggcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVEw7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJTY3JvbGxlclJUTH1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQgZXh0ZW5kcyBNRENUYWJTY3JvbGxlclJUTCB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvblJUTCgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCB7cmlnaHR9ID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICAvLyBTY3JvbGwgdmFsdWVzIG9uIG1vc3QgYnJvd3NlcnMgYXJlIGludHMgaW5zdGVhZCBvZiBmbG9hdHMgc28gd2Ugcm91bmRcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyaWdodCAtIGN1cnJlbnRTY3JvbGxMZWZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhlZGdlcy5yaWdodCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCBjbGFtcGVkU2Nyb2xsTGVmdCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oY3VycmVudFNjcm9sbExlZnQgLSBzY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjbGFtcGVkU2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uKHNjcm9sbFgpIHtcbiAgICByZXR1cm4gc2Nyb2xsWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogY29udGVudFdpZHRoIC0gcm9vdFdpZHRoLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGVkZ2VzLmxlZnQsIHNjcm9sbFgpLCBlZGdlcy5yaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExEZWZhdWx0O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDVGFiU2Nyb2xsZXJSVEx9XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZSBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYIFRoZSBjdXJyZW50IHRyYW5zbGF0ZVggcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRyYW5zbGF0ZVggLSBjdXJyZW50U2Nyb2xsTGVmdCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgc2Nyb2xsVG9SVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXygtc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge1xuICAgIHJldHVybiBzY3JvbGxYIC0gdHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IHJvb3RXaWR0aCAtIGNvbnRlbnRXaWR0aCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGVkZ2VzLnJpZ2h0LCBzY3JvbGxYKSwgZWRnZXMubGVmdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVEwgZnJvbSAnLi9ydGwtc2Nyb2xsZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYlNjcm9sbGVyUlRMfVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICAvLyBTY3JvbGwgdmFsdWVzIG9uIG1vc3QgYnJvd3NlcnMgYXJlIGludHMgaW5zdGVhZCBvZiBmbG9hdHMgc28gd2Ugcm91bmRcbiAgICByZXR1cm4gTWF0aC5yb3VuZChjdXJyZW50U2Nyb2xsTGVmdCAtIHRyYW5zbGF0ZVgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCBjbGFtcGVkU2Nyb2xsTGVmdCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY3VycmVudFNjcm9sbExlZnQgLSBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCArIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGN1cnJlbnRTY3JvbGxMZWZ0IC0gY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge1xuICAgIHJldHVybiBzY3JvbGxYICsgdHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IGNvbnRlbnRXaWR0aCAtIHJvb3RXaWR0aCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGVkZ2VzLnJpZ2h0LCBzY3JvbGxYKSwgZWRnZXMubGVmdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXMsIE1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExEZWZhdWx0IGZyb20gJy4vcnRsLWRlZmF1bHQtc2Nyb2xsZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMTmVnYXRpdmUgZnJvbSAnLi9ydGwtbmVnYXRpdmUtc2Nyb2xsZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSBmcm9tICcuL3J0bC1yZXZlcnNlLXNjcm9sbGVyJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiU2Nyb2xsZXJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIE1EQ1RhYlNjcm9sbGVyQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9ICovICh7XG4gICAgICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcjogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBhZGRTY3JvbGxBcmVhQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWU6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3Q6ICgpID0+IHt9LFxuICAgICAgY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJvb2xlYW4gY29udHJvbHMgd2hldGhlciB3ZSBzaG91bGQgaGFuZGxlIHRoZSB0cmFuc2l0aW9uZW5kIGFuZCBpbnRlcmFjdGlvbiBldmVudHMgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBNRENUYWJTY3JvbGxlclJUTCBpbnN0YW5jZSB2YXJpZXMgcGVyIGJyb3dzZXIgYW5kIGFsbG93cyB1cyB0byBlbmNhcHN1bGF0ZSB0aGUgcGVjdWxpYXIgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIG9mIFJUTCBzY3JvbGxpbmcgaW4gaXQncyBvd24gY2xhc3MuXG4gICAgICogQHByaXZhdGUgez9NRENUYWJTY3JvbGxlclJUTH1cbiAgICAgKi9cbiAgICB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBDb21wdXRlIGhvcml6b250YWwgc2Nyb2xsYmFyIGhlaWdodCBvbiBzY3JvbGxlciB3aXRoIG92ZXJmbG93IGluaXRpYWxseSBoaWRkZW4sIHRoZW4gdXBkYXRlIG92ZXJmbG93IHRvIHNjcm9sbFxuICAgIC8vIGFuZCBpbW1lZGlhdGVseSBhZGp1c3QgYm90dG9tIG1hcmdpbiB0byBhdm9pZCB0aGUgc2Nyb2xsYmFyIGluaXRpYWxseSBhcHBlYXJpbmcgYmVmb3JlIEpTIHJ1bnMuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5KCdtYXJnaW4tYm90dG9tJywgLWhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgKyAncHgnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZFNjcm9sbEFyZWFDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5TQ1JPTExfQVJFQV9TQ1JPTEwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBjdXJyZW50IHZpc3VhbCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVDdXJyZW50U2Nyb2xsUG9zaXRpb25SVExfKCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgcmV0dXJuIHNjcm9sbExlZnQgLSBjdXJyZW50VHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGludGVyYWN0aW9uIGV2ZW50cyB0aGF0IG9jY3VyIGR1cmluZyB0cmFuc2l0aW9uXG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbigpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHdlIGFyZW4ndCBhbmltYXRpbmdcbiAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmdfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBvdGhlciBldmVudCBsaXN0ZW5lcnMgZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG4gICAgdGhpcy5zdG9wU2Nyb2xsQW5pbWF0aW9uXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHdlIGFyZW4ndCBhbmltYXRpbmcgb3IgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBkaWZmZXJlbnQgZWxlbWVudC5cbiAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmdfXG4gICAgICB8fCAhdGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcihldnQudGFyZ2V0LCBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uc3RyaW5ncy5DT05URU5UX1NFTEVDVE9SKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgc2Nyb2xsIHZhbHVlIGJ5IHRoZSBzY3JvbGxYSW5jcmVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYSW5jcmVtZW50IFRoZSB2YWx1ZSBieSB3aGljaCB0byBpbmNyZW1lbnQgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpIHtcbiAgICAvLyBFYXJseSBleGl0IGZvciBub24tb3BlcmF0aW9uYWwgaW5jcmVtZW50IHZhbHVlc1xuICAgIGlmIChzY3JvbGxYSW5jcmVtZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudFNjcm9sbFJUTF8oc2Nyb2xsWEluY3JlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbmNyZW1lbnRTY3JvbGxfKHNjcm9sbFhJbmNyZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdG8gdGhlIGdpdmVuIHNjcm9sbFggdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICovXG4gIHNjcm9sbFRvKHNjcm9sbFgpIHtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9SVExfKHNjcm9sbFgpO1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsVG9fKHNjcm9sbFgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIHZlcnNpb24gb2YgdGhlIE1EQ1RhYlNjcm9sbGVyUlRMXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlclJUTH1cbiAgICovXG4gIGdldFJUTFNjcm9sbGVyKCkge1xuICAgIGlmICghdGhpcy5ydGxTY3JvbGxlckluc3RhbmNlXykge1xuICAgICAgdGhpcy5ydGxTY3JvbGxlckluc3RhbmNlXyA9IHRoaXMucnRsU2Nyb2xsZXJGYWN0b3J5XygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRyYW5zbGF0ZVggdmFsdWUgZnJvbSBhIENTUyBtYXRyaXggdHJhbnNmb3JtIGZ1bmN0aW9uIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVDdXJyZW50VHJhbnNsYXRlWF8oKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtVmFsdWUgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKCd0cmFuc2Zvcm0nKTtcbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIHRyYW5zZm9ybSBpcyBwcmVzZW50XG4gICAgaWYgKHRyYW5zZm9ybVZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFRoZSB0cmFuc2Zvcm0gdmFsdWUgY29tZXMgYmFjayBhcyBhIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBpbiB0aGUgZm9ybVxuICAgIC8vIG9mIGBtYXRyaXgoYSwgYiwgYywgZCwgdHgsIHR5KWAuIFdlIG9ubHkgY2FyZSBhYm91dCB0eCAodHJhbnNsYXRlWCkgc29cbiAgICAvLyB3ZSdyZSBnb2luZyB0byBncmFiIGFsbCB0aGUgcGFyZW50aGVzaXplZCB2YWx1ZXMsIHN0cmlwIG91dCB0eCwgYW5kXG4gICAgLy8gcGFyc2UgaXQuXG4gICAgY29uc3QgcmVzdWx0cyA9IC9cXCgoLispXFwpLy5leGVjKHRyYW5zZm9ybVZhbHVlKVsxXTtcbiAgICBjb25zdCBwYXJ0cyA9IHJlc3VsdHMuc3BsaXQoJywnKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJ0c1s0XSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhIHNhZmUgc2Nyb2xsIHZhbHVlIHRoYXQgaXMgPiAwIGFuZCA8IHRoZSBtYXggc2Nyb2xsIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBkaXN0YW5jZSB0byBzY3JvbGxcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMubGVmdCwgc2Nyb2xsWCksIGVkZ2VzLnJpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlQ3VycmVudFNjcm9sbFBvc2l0aW9uUlRMXygpIHtcbiAgICBjb25zdCB0cmFuc2xhdGVYID0gdGhpcy5jYWxjdWxhdGVDdXJyZW50VHJhbnNsYXRlWF8oKTtcbiAgICByZXR1cm4gdGhpcy5nZXRSVExTY3JvbGxlcigpLmdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBjb250ZW50V2lkdGggLSByb290V2lkdGgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsVG9fKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsWCA9IHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBzYWZlU2Nyb2xsWCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCk7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBzYWZlU2Nyb2xsWCAtIGN1cnJlbnRTY3JvbGxYO1xuICAgIHRoaXMuYW5pbWF0ZV8oLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBzYWZlU2Nyb2xsWCxcbiAgICAgIHNjcm9sbERlbHRhOiBzY3JvbGxEZWx0YSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgUlRMIHNjcm9sbCBtZXRob2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIG5ldyBzY3JvbGwgcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNjcm9sbFRvUlRMXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5nZXRSVExTY3JvbGxlcigpLnNjcm9sbFRvUlRMKHNjcm9sbFgpO1xuICAgIHRoaXMuYW5pbWF0ZV8oYW5pbWF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBpbmNyZW1lbnQgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvbiBpbmNyZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluY3JlbWVudFNjcm9sbF8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxYID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbFggPSBzY3JvbGxYICsgY3VycmVudFNjcm9sbFg7XG4gICAgY29uc3Qgc2FmZVNjcm9sbFggPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKHRhcmdldFNjcm9sbFgpO1xuICAgIGNvbnN0IHNjcm9sbERlbHRhID0gc2FmZVNjcm9sbFggLSBjdXJyZW50U2Nyb2xsWDtcbiAgICB0aGlzLmFuaW1hdGVfKC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogc2FmZVNjcm9sbFgsXG4gICAgICBzY3JvbGxEZWx0YTogc2Nyb2xsRGVsdGEsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGluY3JlbWVuZXQgc2Nyb2xsIFJUTCBtZXRob2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIG5ldyBzY3JvbGwgcG9zaXRpb24gUlRMIGluY3JlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5nZXRSVExTY3JvbGxlcigpLmluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKTtcbiAgICB0aGlzLmFuaW1hdGVfKGFuaW1hdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIHRhYiBzY3JvbGxpbmdcbiAgICogQHBhcmFtIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIGFwcGx5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlXyhhbmltYXRpb24pIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHRyYW5zbGF0ZVggaXMgMCwgd2hpY2ggbWVhbnMgdGhlcmUncyBubyBhbmltYXRpb24gdG8gcGVyZm9ybVxuICAgIGlmIChhbmltYXRpb24uc2Nyb2xsRGVsdGEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BTY3JvbGxBbmltYXRpb25fKCk7XG4gICAgLy8gVGhpcyBhbmltYXRpb24gdXNlcyB0aGUgRkxJUCBhcHByb2FjaC5cbiAgICAvLyBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChhbmltYXRpb24uZmluYWxTY3JvbGxQb3NpdGlvbik7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoJHthbmltYXRpb24uc2Nyb2xsRGVsdGF9cHgpYCk7XG4gICAgLy8gRm9yY2UgcmVwYWludFxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0KCk7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJ25vbmUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBzY3JvbGwgYW5pbWF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdG9wU2Nyb2xsQW5pbWF0aW9uXygpIHtcbiAgICB0aGlzLmlzQW5pbWF0aW5nXyA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb25fKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHkoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVYKDBweCknKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KGN1cnJlbnRTY3JvbGxQb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8oKSB7XG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJUTFNjcm9sbGVyKCkuZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsTGVmdCwgY3VycmVudFRyYW5zbGF0ZVgpO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JvbGxMZWZ0IC0gY3VycmVudFRyYW5zbGF0ZVg7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgUlRMIFNjcm9sbGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJSVEx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydGxTY3JvbGxlckZhY3RvcnlfKCkge1xuICAgIC8vIEJyb3dzZXJzIGhhdmUgdGhyZWUgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBvZiBzY3JvbGxMZWZ0IGluIFJUTCBtb2RlLFxuICAgIC8vIGRlcGVuZGVudCBvbiB0aGUgYnJvd3Nlci4gVGhlIGJlaGF2aW9yIGlzIGJhc2VkIG9mZiB0aGUgbWF4IExUUlxuICAgIC8vIHNjcm9sbGxlZnQgdmFsdWUgYW5kIDAuXG4gICAgLy9cbiAgICAvLyAqIERlZmF1bHQgc2Nyb2xsaW5nIGluIFJUTCAqXG4gICAgLy8gICAgLSBMZWZ0LW1vc3QgdmFsdWU6IDBcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IE1heCBMVFIgc2Nyb2xsTGVmdCB2YWx1ZVxuICAgIC8vXG4gICAgLy8gKiBOZWdhdGl2ZSBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogTmVnYXRlZCBtYXggTFRSIHNjcm9sbExlZnQgdmFsdWVcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IDBcbiAgICAvL1xuICAgIC8vICogUmV2ZXJzZSBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogTWF4IExUUiBzY3JvbGxMZWZ0IHZhbHVlXG4gICAgLy8gICAgLSBSaWdodC1tb3N0IHZhbHVlOiAwXG4gICAgLy9cbiAgICAvLyBXZSB1c2UgdGhvc2UgcHJpbmNpcGxlcyBiZWxvdyB0byBkZXRlcm1pbmUgd2hpY2ggUlRMIHNjcm9sbExlZnRcbiAgICAvLyBiZWhhdmlvciBpcyBpbXBsZW1lbnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgIGNvbnN0IGluaXRpYWxTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQgLSAxKTtcbiAgICBjb25zdCBuZXdTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuXG4gICAgLy8gSWYgdGhlIG5ld1Njcm9sbExlZnQgdmFsdWUgaXMgbmVnYXRpdmUsdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGJyb3dzZXIgaGFzXG4gICAgLy8gaW1wbGVtZW50ZWQgbmVnYXRpdmUgUlRMIHNjcm9sbGluZywgc2luY2UgYWxsIG90aGVyIGltcGxlbWVudGF0aW9ucyBoYXZlXG4gICAgLy8gb25seSBwb3NpdGl2ZSB2YWx1ZXMuXG4gICAgaWYgKG5ld1Njcm9sbExlZnQgPCAwKSB7XG4gICAgICAvLyBVbmRvIHRoZSBzY3JvbGxMZWZ0IHRlc3QgY2hlY2tcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQpO1xuICAgICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlKHRoaXMuYWRhcHRlcl8pO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RDbGllbnRSZWN0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250ZW50Q2xpZW50UmVjdCA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmlnaHRFZGdlRGVsdGEgPSBNYXRoLnJvdW5kKGNvbnRlbnRDbGllbnRSZWN0LnJpZ2h0IC0gcm9vdENsaWVudFJlY3QucmlnaHQpO1xuICAgIC8vIFVuZG8gdGhlIHNjcm9sbExlZnQgdGVzdCBjaGVja1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQpO1xuXG4gICAgLy8gQnkgY2FsY3VsYXRpbmcgdGhlIGNsaWVudFJlY3Qgb2YgdGhlIHJvb3QgZWxlbWVudCBhbmQgdGhlIGNsaWVudFJlY3Qgb2ZcbiAgICAvLyB0aGUgY29udGVudCBlbGVtZW50LCB3ZSBjYW4gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBzY3JvbGwgdmFsdWUgY2hhbmdlZFxuICAgIC8vIHdoZW4gd2UgcGVyZm9ybWVkIHRoZSBzY3JvbGxMZWZ0IHN1YnRyYWN0aW9uIGFib3ZlLlxuICAgIGlmIChyaWdodEVkZ2VEZWx0YSA9PT0gbmV3U2Nyb2xsTGVmdCkge1xuICAgICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTFJldmVyc2UodGhpcy5hZGFwdGVyXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQodGhpcy5hZGFwdGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzUlRMXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcuXG4gKiBAcHJpdmF0ZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAqL1xubGV0IGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBoZWlnaHQgb2YgYnJvd3Nlci1yZW5kZXJlZCBob3Jpem9udGFsIHNjcm9sbGJhcnMgdXNpbmcgYSBzZWxmLWNyZWF0ZWQgdGVzdCBlbGVtZW50LlxuICogTWF5IHJldHVybiAwIChlLmcuIG9uIE9TIFggYnJvd3NlcnMgdW5kZXIgZGVmYXVsdCBjb25maWd1cmF0aW9uKS5cbiAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQ2FjaGVSZXN1bHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoZG9jdW1lbnRPYmosIHNob3VsZENhY2hlUmVzdWx0ID0gdHJ1ZSkge1xuICBpZiAoc2hvdWxkQ2FjaGVSZXN1bHQgJiYgdHlwZW9mIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XztcbiAgfVxuXG4gIGNvbnN0IGVsID0gZG9jdW1lbnRPYmouY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsLmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5TQ1JPTExfVEVTVCk7XG4gIGRvY3VtZW50T2JqLmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gIGNvbnN0IGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gIGRvY3VtZW50T2JqLmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gIGlmIChzaG91bGRDYWNoZVJlc3VsdCkge1xuICAgIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfID0gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ21hdGNoZXMnLFxuICBdLmZpbHRlcigocCkgPT4gcCBpbiBIVE1MRWxlbWVudFByb3RvdHlwZSkucG9wKCk7XG59XG5cbmV4cG9ydCB7Y29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQsIGdldE1hdGNoZXNQcm9wZXJ0eX07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDQ29tcG9uZW50PCFNRENUYWJTY3JvbGxlckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyKHJvb3QpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RWxlbWVudH0gKi9cbiAgICB0aGlzLmNvbnRlbnRfO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RWxlbWVudH0gKi9cbiAgICB0aGlzLmFyZWFfO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/ZnVuY3Rpb24oP0V2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF87XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuYXJlYV8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uLnN0cmluZ3MuQVJFQV9TRUxFQ1RPUik7XG4gICAgdGhpcy5jb250ZW50XyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uc3RyaW5ncy5DT05URU5UX1NFTEVDVE9SKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyA9ICgpID0+IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfID0gKGV2dCkgPT4gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCk7XG5cbiAgICB0aGlzLmFyZWFfLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmNvbnRlbnRfLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5hcmVhXy5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5jb250ZW50Xy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9ICovICh7XG4gICAgICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcjogKGV2dFRhcmdldCwgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgY29uc3QgTUFUQ0hFUyA9IHV0aWwuZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBldnRUYXJnZXRbTUFUQ0hFU10oc2VsZWN0b3IpO1xuICAgICAgfSxcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGFkZFNjcm9sbEFyZWFDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5hcmVhXy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICBzZXRTY3JvbGxBcmVhU3R5bGVQcm9wZXJ0eTogKHByb3AsIHZhbHVlKSA9PiB0aGlzLmFyZWFfLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlKSxcbiAgICAgIHNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5OiAocHJvcCwgdmFsdWUpID0+IHRoaXMuY29udGVudF8uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsdWUpLFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWU6IChwcm9wTmFtZSkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5jb250ZW50XykuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSksXG4gICAgICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKHNjcm9sbFgpID0+IHRoaXMuYXJlYV8uc2Nyb2xsTGVmdCA9IHNjcm9sbFgsXG4gICAgICBnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKCkgPT4gdGhpcy5hcmVhXy5zY3JvbGxMZWZ0LFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLmNvbnRlbnRfLm9mZnNldFdpZHRoLFxuICAgICAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLmFyZWFfLm9mZnNldFdpZHRoLFxuICAgICAgY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0OiAoKSA9PiB0aGlzLmFyZWFfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB0aGlzLmNvbnRlbnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQ6ICgpID0+IHV0aWwuY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoZG9jdW1lbnQpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24oYWRhcHRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2aXN1YWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Xy5vZmZzZXRXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBzY3JvbGwgdmFsdWUgYnkgdGhlIGdpdmVuIGFtb3VudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWEluY3JlbWVudCBUaGUgcGl4ZWwgdmFsdWUgYnkgd2hpY2ggdG8gaW5jcmVtZW50IHRoZSBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIHBpeGVsIHZhbHVlIHRvIHNjcm9sbCB0b1xuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsWCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2Nyb2xsVG8oc2Nyb2xsWCk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENUYWJTY3JvbGxlciwgTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uLCB1dGlsfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiRGltZW5zaW9uc30gZnJvbSAnQG1hdGVyaWFsL3RhYi9hZGFwdGVyJztcbmltcG9ydCB7TURDVGFifSBmcm9tICdAbWF0ZXJpYWwvdGFiL2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGFiIEJhci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgQmFyIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJCYXJBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFNjcm9sbHMgdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBwb3NpdGlvbiB0byBzY3JvbGwgdG9cbiAgICovXG4gIHNjcm9sbFRvKHNjcm9sbFgpIHt9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGJ5IHRoZSBnaXZlbiBhbW91bnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhJbmNyZW1lbnQgVGhlIGFtb3VudCB0byBpbmNyZW1lbnQgc2Nyb2xsXG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsQ29udGVudFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50J3Mgb2Zmc2V0V2lkdGhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBUYWIgQmFyIGxhbmd1YWdlIGRpcmVjdGlvbiBpcyBSVExcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUlRMKCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB0byBiZSBhY3RpdmF0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIGFjdGl2YXRlXG4gICAqL1xuICBzZXRBY3RpdmVUYWIoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIHRoZSBnaXZlbiBjbGllbnQgcmVjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gYWN0aXZhdGVcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdCBUaGUgY2xpZW50IHJlY3Qgb2YgdGhlIHByZXZpb3VzbHkgYWN0aXZlIFRhYiBJbmRpY2F0b3JcbiAgICovXG4gIGFjdGl2YXRlVGFiQXRJbmRleChpbmRleCwgY2xpZW50UmVjdCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIGRlYWN0aXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGVUYWJBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBmb2N1c1xuICAgKi9cbiAgZm9jdXNUYWJBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgcmVjdCBvZiB0aGUgdGFiJ3MgaW5kaWNhdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGdldFRhYkluZGljYXRvckNsaWVudFJlY3RBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YWIgZGltZW5zaW9ucyBvZiB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHJldHVybiB7IU1EQ1RhYkRpbWVuc2lvbnN9XG4gICAqL1xuICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleChpbmRleCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB0YWIgbGlzdFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJMaXN0TGVuZ3RoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzbHkgYWN0aXZlIHRhYlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvY3VzZWQgdGFiXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEZvY3VzZWRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiB0YWJcbiAgICogQHBhcmFtIHshTURDVGFifSB0YWIgVGhlIHRhYiB3aG9zZSBpbmRleCB0byBkZXRlcm1pblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRJbmRleE9mVGFiKHRhYikge31cblxuICAvKipcbiAgICogRW1pdHMgdGhlIE1EQ1RhYkJhcjphY3RpdmF0ZWQgZXZlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgYWN0aXZhdGVkIHRhYlxuICAgKi9cbiAgbm90aWZ5VGFiQWN0aXZhdGVkKGluZGV4KSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJCYXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEFCX0FDVElWQVRFRF9FVkVOVDogJ01EQ1RhYkJhcjphY3RpdmF0ZWQnLFxuICBUQUJfU0NST0xMRVJfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcicsXG4gIFRBQl9TRUxFQ1RPUjogJy5tZGMtdGFiJyxcbiAgQVJST1dfTEVGVF9LRVk6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVF9LRVk6ICdBcnJvd1JpZ2h0JyxcbiAgRU5EX0tFWTogJ0VuZCcsXG4gIEhPTUVfS0VZOiAnSG9tZScsXG4gIEVOVEVSX0tFWTogJ0VudGVyJyxcbiAgU1BBQ0VfS0VZOiAnU3BhY2UnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBFWFRSQV9TQ1JPTExfQU1PVU5UOiAyMCxcbiAgQVJST1dfTEVGVF9LRVlDT0RFOiAzNyxcbiAgQVJST1dfUklHSFRfS0VZQ09ERTogMzksXG4gIEVORF9LRVlDT0RFOiAzNSxcbiAgSE9NRV9LRVlDT0RFOiAzNixcbiAgRU5URVJfS0VZQ09ERTogMTMsXG4gIFNQQUNFX0tFWUNPREU6IDMyLFxufTtcblxuZXhwb3J0IHtcbiAgbnVtYmVycyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5cbmltcG9ydCB7c3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1RhYkJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiRGltZW5zaW9uc30gZnJvbSAnQG1hdGVyaWFsL3RhYi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gKi9cbmNvbnN0IEFDQ0VQVEFCTEVfS0VZUyA9IG5ldyBTZXQoKTtcbi8vIElFMTEgaGFzIG5vIHN1cHBvcnQgZm9yIG5ldyBTZXQgd2l0aCBpdGVyYWJsZSBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgdGhpcyBieSBoYW5kXG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuQVJST1dfTEVGVF9LRVkpO1xuQUNDRVBUQUJMRV9LRVlTLmFkZChzdHJpbmdzLkFSUk9XX1JJR0hUX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuRU5EX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuSE9NRV9LRVkpO1xuQUNDRVBUQUJMRV9LRVlTLmFkZChzdHJpbmdzLkVOVEVSX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuU1BBQ0VfS0VZKTtcblxuLyoqXG4gKiBAdHlwZSB7TWFwPG51bWJlciwgc3RyaW5nPn1cbiAqL1xuY29uc3QgS0VZQ09ERV9NQVAgPSBuZXcgTWFwKCk7XG4vLyBJRTExIGhhcyBubyBzdXBwb3J0IGZvciBuZXcgTWFwIHdpdGggaXRlcmFibGUgc28gd2UgbmVlZCB0byBpbml0aWFsaXplIHRoaXMgYnkgaGFuZFxuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuQVJST1dfTEVGVF9LRVlDT0RFLCBzdHJpbmdzLkFSUk9XX0xFRlRfS0VZKTtcbktFWUNPREVfTUFQLnNldChudW1iZXJzLkFSUk9XX1JJR0hUX0tFWUNPREUsIHN0cmluZ3MuQVJST1dfUklHSFRfS0VZKTtcbktFWUNPREVfTUFQLnNldChudW1iZXJzLkVORF9LRVlDT0RFLCBzdHJpbmdzLkVORF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuSE9NRV9LRVlDT0RFLCBzdHJpbmdzLkhPTUVfS0VZKTtcbktFWUNPREVfTUFQLnNldChudW1iZXJzLkVOVEVSX0tFWUNPREUsIHN0cmluZ3MuRU5URVJfS0VZKTtcbktFWUNPREVfTUFQLnNldChudW1iZXJzLlNQQUNFX0tFWUNPREUsIHN0cmluZ3MuU1BBQ0VfS0VZKTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiQmFyQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiQmFyQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJCYXJBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiQmFyQWRhcHRlcn0gKi8gKHtcbiAgICAgIHNjcm9sbFRvOiAoKSA9PiB7fSxcbiAgICAgIGluY3JlbWVudFNjcm9sbDogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbjogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxDb250ZW50V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IHt9LFxuICAgICAgc2V0QWN0aXZlVGFiOiAoKSA9PiB7fSxcbiAgICAgIGFjdGl2YXRlVGFiQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlVGFiQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBmb2N1c1RhYkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRGb2N1c2VkVGFiSW5kZXg6ICgpID0+IHt9LFxuICAgICAgZ2V0SW5kZXhPZlRhYjogKCkgPT4ge30sXG4gICAgICBnZXRUYWJMaXN0TGVuZ3RoOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeVRhYkFjdGl2YXRlZDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGFiQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKiAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJCYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51c2VBdXRvbWF0aWNBY3RpdmF0aW9uXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gYXV0b21hdGljIGFuZCBtYW51YWwgYWN0aXZhdGlvbiBtb2Rlcy5cbiAgICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvI3RhYnBhbmVsIGZvciBleGFtcGxlcy5cbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBdXRvbWF0aWNBY3RpdmF0aW9uXG4gICAqL1xuICBzZXRVc2VBdXRvbWF0aWNBY3RpdmF0aW9uKHVzZUF1dG9tYXRpY0FjdGl2YXRpb24pIHtcbiAgICB0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fID0gdXNlQXV0b21hdGljQWN0aXZhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBhY3RpdmF0ZVRhYihpbmRleCkge1xuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZlSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXgoKTtcbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKGluZGV4KSB8fCBpbmRleCA9PT0gcHJldmlvdXNBY3RpdmVJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZVRhYkF0SW5kZXgocHJldmlvdXNBY3RpdmVJbmRleCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZVRhYkF0SW5kZXgoaW5kZXgsIHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXgocHJldmlvdXNBY3RpdmVJbmRleCkpO1xuICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoaW5kZXgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlUYWJBY3RpdmF0ZWQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5RG93bihldnQpIHtcbiAgICAvLyBHZXQgdGhlIGtleSBmcm9tIHRoZSBldmVudFxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5RnJvbUV2ZW50XyhldnQpO1xuXG4gICAgLy8gRWFybHkgZXhpdCBpZiB0aGUgZXZlbnQga2V5IGlzbid0IG9uZSBvZiB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBrZXlzXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBtb3ZlbWVudCBrZXlzLCBidXQgbm90IGZvciBhY3RpdmF0aW9uIGtleXMsIHNpbmNlIDphY3RpdmUgaXMgdXNlZCB0byBhcHBseSByaXBwbGVcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmF0aW9uS2V5XyhrZXkpKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VBdXRvbWF0aWNBY3RpdmF0aW9uXykge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmF0aW9uS2V5XyhrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRldGVybWluZVRhcmdldEZyb21LZXlfKHRoaXMuYWRhcHRlcl8uZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCgpLCBrZXkpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIoaW5kZXgpO1xuICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvY3VzZWRUYWJJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNlZFRhYkluZGV4KCk7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIoZm9jdXNlZFRhYkluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZXRlcm1pbmVUYXJnZXRGcm9tS2V5Xyhmb2N1c2VkVGFiSW5kZXgsIGtleSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNUYWJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIE1EQ1RhYjppbnRlcmFjdGVkIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRhYkludGVyYWN0aW9uKGV2dCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aXZlVGFiKHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhPZlRhYihldnQuZGV0YWlsLnRhYikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW50byB2aWV3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGFiIGluZGV4IHRvIG1ha2UgdmlzaWJsZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXcoaW5kZXgpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2VcbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKGluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBzY3JvbGwgdG8gMCBpZiBzY3JvbGxpbmcgdG8gdGhlIDB0aCBpbmRleFxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uc2Nyb2xsVG8oMCk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHNjcm9sbCB0byB0aGUgbWF4IHZhbHVlIGlmIHNjcm9sbGluZyB0byB0aGUgTnRoIGluZGV4XG4gICAgLy8gTURDVGFiU2Nyb2xsZXIuc2Nyb2xsVG8oKSB3aWxsIG5ldmVyIHNjcm9sbCBwYXN0IHRoZSBtYXggcG9zc2libGUgdmFsdWVcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWRhcHRlcl8uZ2V0VGFiTGlzdExlbmd0aCgpIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uc2Nyb2xsVG8odGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50V2lkdGgoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbEludG9WaWV3UlRMXyhpbmRleCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxJbnRvVmlld18oaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kIGZvciBkZXRlcm1pbmluZyB0aGUgaW5kZXggb2YgdGhlIGRlc3RpbmF0aW9uIHRhYiBiYXNlZCBvbiB3aGF0IGtleSB3YXMgcHJlc3NlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luIFRoZSBvcmlnaW5hbCBpbmRleCBmcm9tIHdoaWNoIHRvIGRldGVybWluZSB0aGUgZGVzdGluYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUga2V5XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZVRhcmdldEZyb21LZXlfKG9yaWdpbiwga2V5KSB7XG4gICAgY29uc3QgaXNSVEwgPSB0aGlzLmlzUlRMXygpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCkgLSAxO1xuICAgIGNvbnN0IHNob3VsZEdvVG9FbmQgPSBrZXkgPT09IHN0cmluZ3MuRU5EX0tFWTtcbiAgICBjb25zdCBzaG91bGREZWNyZW1lbnQgPSBrZXkgPT09IHN0cmluZ3MuQVJST1dfTEVGVF9LRVkgJiYgIWlzUlRMIHx8IGtleSA9PT0gc3RyaW5ncy5BUlJPV19SSUdIVF9LRVkgJiYgaXNSVEw7XG4gICAgY29uc3Qgc2hvdWxkSW5jcmVtZW50ID0ga2V5ID09PSBzdHJpbmdzLkFSUk9XX1JJR0hUX0tFWSAmJiAhaXNSVEwgfHwga2V5ID09PSBzdHJpbmdzLkFSUk9XX0xFRlRfS0VZICYmIGlzUlRMO1xuICAgIGxldCBpbmRleCA9IG9yaWdpbjtcblxuICAgIGlmIChzaG91bGRHb1RvRW5kKSB7XG4gICAgICBpbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkRGVjcmVtZW50KSB7XG4gICAgICBpbmRleCAtPSAxO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSW5jcmVtZW50KSB7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIGluY3JlbWVudCB0aGF0IHdpbGwgbWFrZSB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB2aXNpYmxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV4dEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbmV4dCB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBUYWIgQmFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKSB7XG4gICAgY29uc3QgbmV4dFRhYkRpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkRpbWVuc2lvbnNBdEluZGV4KG5leHRJbmRleCk7XG4gICAgY29uc3QgcmVsYXRpdmVDb250ZW50TGVmdCA9IG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRMZWZ0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRSaWdodCA9IG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRSaWdodCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IGxlZnRJbmNyZW1lbnQgPSByZWxhdGl2ZUNvbnRlbnRSaWdodCAtIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcbiAgICBjb25zdCByaWdodEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudExlZnQgKyBudW1iZXJzLkVYVFJBX1NDUk9MTF9BTU9VTlQ7XG5cbiAgICBpZiAobmV4dEluZGV4IDwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihsZWZ0SW5jcmVtZW50LCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgocmlnaHRJbmNyZW1lbnQsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBpbmNyZW1lbnQgdGhhdCB3aWxsIG1ha2UgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggdmlzaWJsZSBpbiBSVExcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBuZXh0IHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIFRhYiBCYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbENvbnRlbnRXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudFJUTF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxDb250ZW50V2lkdGgpIHtcbiAgICBjb25zdCBuZXh0VGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgobmV4dEluZGV4KTtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRMZWZ0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudExlZnQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRSaWdodCA9IHNjcm9sbENvbnRlbnRXaWR0aCAtIG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRSaWdodCAtIHNjcm9sbFBvc2l0aW9uIC0gYmFyV2lkdGg7XG4gICAgY29uc3QgbGVmdEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudFJpZ2h0ICsgbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuICAgIGNvbnN0IHJpZ2h0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50TGVmdCAtIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcblxuICAgIGlmIChuZXh0SW5kZXggPiBpbmRleCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxlZnRJbmNyZW1lbnQsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1pbihyaWdodEluY3JlbWVudCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5kZXggb2YgdGhlIGFkamFjZW50IHRhYiBjbG9zZXN0IHRvIGVpdGhlciBlZGdlIG9mIHRoZSBUYWIgQmFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJEaW1lbnNpb25zfSB0YWJEaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSB0YWIgYmFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZV8oaW5kZXgsIHRhYkRpbWVuc2lvbnMsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCkge1xuICAgIC8qKlxuICAgICAqIFRhYnMgYXJlIGxhaWQgb3V0IGluIHRoZSBUYWIgU2Nyb2xsZXIgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogICAgU2Nyb2xsIFBvc2l0aW9uXG4gICAgICogICAgKy0tLStcbiAgICAgKiAgICB8ICAgfCAgIEJhciBXaWR0aFxuICAgICAqICAgIHwgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgfCAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICB8ICAgViAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuICAgICAqICAgIHwgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgViAgIHwgICAgICAgICAgICAgVGFiIFNjcm9sbGVyICAgICAgICAgIHxcbiAgICAgKiAgICArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgfCAgICBUYWIgICAgIHwgICAgICBUYWIgICAgIHwgICAgICAgIFRhYiAgICAgICAgfFxuICAgICAqICAgICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICpcbiAgICAgKiBUbyBkZXRlcm1pbmUgdGhlIG5leHQgYWRqYWNlbnQgaW5kZXgsIHdlIGxvb2sgYXQgdGhlIFRhYiByb290IGxlZnQgYW5kXG4gICAgICogVGFiIHJvb3QgcmlnaHQsIGJvdGggcmVsYXRpdmUgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbi4gSWYgdGhlIFRhYiByb290XG4gICAgICogbGVmdCBpcyBsZXNzIHRoYW4gMCwgdGhlbiB3ZSBrbm93IGl0J3Mgb3V0IG9mIHZpZXcgdG8gdGhlIGxlZnQuIElmIHRoZVxuICAgICAqIFRhYiByb290IHJpZ2h0IG1pbnVzIHRoZSBiYXIgd2lkdGggaXMgZ3JlYXRlciB0aGFuIDAsIHdlIGtub3cgdGhlIFRhYiBpc1xuICAgICAqIG91dCBvZiB2aWV3IHRvIHRoZSByaWdodC4gRnJvbSB0aGVyZSwgd2UgZWl0aGVyIGluY3JlbWVudCBvciBkZWNyZW1lbnRcbiAgICAgKiB0aGUgaW5kZXguXG4gICAgICovXG4gICAgY29uc3QgcmVsYXRpdmVSb290TGVmdCA9IHRhYkRpbWVuc2lvbnMucm9vdExlZnQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByZWxhdGl2ZVJvb3RSaWdodCA9IHRhYkRpbWVuc2lvbnMucm9vdFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCByZWxhdGl2ZVJvb3REZWx0YSA9IHJlbGF0aXZlUm9vdExlZnQgKyByZWxhdGl2ZVJvb3RSaWdodDtcbiAgICBjb25zdCBsZWZ0RWRnZUlzQ2xvc2VyID0gcmVsYXRpdmVSb290TGVmdCA8IDAgfHwgcmVsYXRpdmVSb290RGVsdGEgPCAwO1xuICAgIGNvbnN0IHJpZ2h0RWRnZUlzQ2xvc2VyID0gcmVsYXRpdmVSb290UmlnaHQgPiAwIHx8IHJlbGF0aXZlUm9vdERlbHRhID4gMDtcblxuICAgIGlmIChsZWZ0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgIH1cblxuICAgIGlmIChyaWdodEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5kZXggb2YgdGhlIGFkamFjZW50IHRhYiBjbG9zZXN0IHRvIGVpdGhlciBlZGdlIG9mIHRoZSBUYWIgQmFyIGluIFJUTFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHshTURDVGFiRGltZW5zaW9uc30gdGFiRGltZW5zaW9ucyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhcldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgdGFiIGJhclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsQ29udGVudFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsZXIgY29udGVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VSVExfKGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbENvbnRlbnRXaWR0aCkge1xuICAgIGNvbnN0IHJvb3RMZWZ0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gdGFiRGltZW5zaW9ucy5yb290TGVmdCAtIGJhcldpZHRoIC0gc2Nyb2xsUG9zaXRpb247XG4gICAgY29uc3Qgcm9vdFJpZ2h0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gdGFiRGltZW5zaW9ucy5yb290UmlnaHQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByb290RGVsdGEgPSByb290TGVmdCArIHJvb3RSaWdodDtcbiAgICBjb25zdCBsZWZ0RWRnZUlzQ2xvc2VyID0gcm9vdExlZnQgPiAwIHx8IHJvb3REZWx0YSA+IDA7XG4gICAgY29uc3QgcmlnaHRFZGdlSXNDbG9zZXIgPSByb290UmlnaHQgPCAwIHx8IHJvb3REZWx0YSA8IDA7XG5cbiAgICBpZiAobGVmdEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRFZGdlSXNDbG9zZXIpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggYSBrZXlkb3duIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnQgVGhlIGtleWRvd24gZXZlbnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0S2V5RnJvbUV2ZW50XyhldnQpIHtcbiAgICBpZiAoQUNDRVBUQUJMRV9LRVlTLmhhcyhldnQua2V5KSkge1xuICAgICAgcmV0dXJuIGV2dC5rZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEtFWUNPREVfTUFQLmdldChldnQua2V5Q29kZSk7XG4gIH1cblxuICBpc0FjdGl2YXRpb25LZXlfKGtleSkge1xuICAgIHJldHVybiBrZXkgPT09IHN0cmluZ3MuU1BBQ0VfS0VZIHx8IGtleSA9PT0gc3RyaW5ncy5FTlRFUl9LRVk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgZ2l2ZW4gaW5kZXggaXMgaW5jbHVzaXZlbHkgYmV0d2VlbiB0aGUgZW5kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHRlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluZGV4SXNJblJhbmdlXyhpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlldydzIFJUTCBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNSVExfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzUlRMKCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXcgZm9yIGxlZnQtdG8tcmlnaHQgdXNlcmFnZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gc2Nyb2xsIGludG8gdmlld1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXdfKGluZGV4KSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgdGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlXyhpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKTtcblxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8obmV4dEluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbEluY3JlbWVudCA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50XyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpO1xuICAgIHRoaXMuYWRhcHRlcl8uaW5jcmVtZW50U2Nyb2xsKHNjcm9sbEluY3JlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXcgaW4gUlRMXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGFiIGluZGV4IHRvIG1ha2UgdmlzaWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXdSVExfKGluZGV4KSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgdGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IHNjcm9sbFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50V2lkdGgoKTtcbiAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZVJUTF8oXG4gICAgICBpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxXaWR0aCk7XG5cbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKG5leHRJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxJbmNyZW1lbnQgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudFJUTF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxXaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsSW5jcmVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJCYXJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcblxuaW1wb3J0IHtNRENUYWIsIE1EQ1RhYkZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC90YWIvaW5kZXgnO1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlcn0gZnJvbSAnQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9pbmRleCc7XG5cbmltcG9ydCBNRENUYWJCYXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQgTURDVGFiQmFyRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYkJhckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYkJhciBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFycmF5PCFNRENUYWI+fSAqL1xuICAgIHRoaXMudGFiTGlzdF87XG5cbiAgICAvKiogQHR5cGUgeyhmdW5jdGlvbighRWxlbWVudCk6ICFNRENUYWIpfSAqL1xuICAgIHRoaXMudGFiRmFjdG9yeV87XG5cbiAgICAvKiogQHByaXZhdGUgez9NRENUYWJTY3JvbGxlcn0gKi9cbiAgICB0aGlzLnRhYlNjcm9sbGVyXztcblxuICAgIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYlNjcm9sbGVyKX0gKi9cbiAgICB0aGlzLnRhYlNjcm9sbGVyRmFjdG9yeV87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVUYWJJbnRlcmFjdGlvbl87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVLZXlEb3duXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENUYWJCYXJ9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiQmFyKHJvb3QpO1xuICB9XG5cbiAgc2V0IHVzZUF1dG9tYXRpY0FjdGl2YXRpb24odXNlQXV0b21hdGljQWN0aXZhdGlvbikge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VXNlQXV0b21hdGljQWN0aXZhdGlvbih1c2VBdXRvbWF0aWNBY3RpdmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhmdW5jdGlvbighRWxlbWVudCk6ICFNRENUYWIpPX0gdGFiRmFjdG9yeSBBIGZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgTURDVGFiXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYlNjcm9sbGVyKT19IHRhYlNjcm9sbGVyRmFjdG9yeSBBIGZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgTURDVGFiU2Nyb2xsZXJcbiAgICovXG4gIGluaXRpYWxpemUoXG4gICAgdGFiRmFjdG9yeSA9IChlbCkgPT4gbmV3IE1EQ1RhYihlbCksXG4gICAgdGFiU2Nyb2xsZXJGYWN0b3J5ID0gKGVsKSA9PiBuZXcgTURDVGFiU2Nyb2xsZXIoZWwpLFxuICApIHtcbiAgICB0aGlzLnRhYkZhY3RvcnlfID0gdGFiRmFjdG9yeTtcbiAgICB0aGlzLnRhYlNjcm9sbGVyRmFjdG9yeV8gPSB0YWJTY3JvbGxlckZhY3Rvcnk7XG5cbiAgICB0aGlzLnRhYkxpc3RfID0gdGhpcy5nZXRUYWJFbGVtZW50c18oKS5tYXAoKGVsKSA9PiB0aGlzLnRhYkZhY3RvcnlfKGVsKSk7XG5cbiAgICBjb25zdCB0YWJTY3JvbGxlckVsZW1lbnQgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiQmFyRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9TQ1JPTExFUl9TRUxFQ1RPUik7XG4gICAgaWYgKHRhYlNjcm9sbGVyRWxlbWVudCkge1xuICAgICAgdGhpcy50YWJTY3JvbGxlcl8gPSB0aGlzLnRhYlNjcm9sbGVyRmFjdG9yeV8odGFiU2Nyb2xsZXJFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy5oYW5kbGVUYWJJbnRlcmFjdGlvbl8gPSAoZXZ0KSA9PiB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZVRhYkludGVyYWN0aW9uKGV2dCk7XG4gICAgdGhpcy5oYW5kbGVLZXlEb3duXyA9IChldnQpID0+IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlS2V5RG93bihldnQpO1xuXG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5JTlRFUkFDVEVEX0VWRU5ULCB0aGlzLmhhbmRsZVRhYkludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duXyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFiTGlzdF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRhYkxpc3RfW2ldLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3KGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNURURfRVZFTlQsIHRoaXMuaGFuZGxlVGFiSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25fKTtcbiAgICB0aGlzLnRhYkxpc3RfLmZvckVhY2goKHRhYikgPT4gdGFiLmRlc3Ryb3koKSk7XG4gICAgdGhpcy50YWJTY3JvbGxlcl8uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJCYXJGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENUYWJCYXJGb3VuZGF0aW9uKFxuICAgICAgLyoqIEB0eXBlIHshTURDVGFiQmFyQWRhcHRlcn0gKi8gKHtcbiAgICAgICAgc2Nyb2xsVG86IChzY3JvbGxYKSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5zY3JvbGxUbyhzY3JvbGxYKSxcbiAgICAgICAgaW5jcmVtZW50U2Nyb2xsOiAoc2Nyb2xsWEluY3JlbWVudCkgPT4gdGhpcy50YWJTY3JvbGxlcl8uaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpLFxuICAgICAgICBnZXRTY3JvbGxQb3NpdGlvbjogKCkgPT4gdGhpcy50YWJTY3JvbGxlcl8uZ2V0U2Nyb2xsUG9zaXRpb24oKSxcbiAgICAgICAgZ2V0U2Nyb2xsQ29udGVudFdpZHRoOiAoKSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5nZXRTY3JvbGxDb250ZW50V2lkdGgoKSxcbiAgICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMucm9vdF8ub2Zmc2V0V2lkdGgsXG4gICAgICAgIGlzUlRMOiAoKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnJvb3RfKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICAgIHNldEFjdGl2ZVRhYjogKGluZGV4KSA9PiB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlVGFiKGluZGV4KSxcbiAgICAgICAgYWN0aXZhdGVUYWJBdEluZGV4OiAoaW5kZXgsIGNsaWVudFJlY3QpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmFjdGl2YXRlKGNsaWVudFJlY3QpLFxuICAgICAgICBkZWFjdGl2YXRlVGFiQXRJbmRleDogKGluZGV4KSA9PiB0aGlzLnRhYkxpc3RfW2luZGV4XS5kZWFjdGl2YXRlKCksXG4gICAgICAgIGZvY3VzVGFiQXRJbmRleDogKGluZGV4KSA9PiB0aGlzLnRhYkxpc3RfW2luZGV4XS5mb2N1cygpLFxuICAgICAgICBnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleDogKGluZGV4KSA9PiB0aGlzLnRhYkxpc3RfW2luZGV4XS5jb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCgpLFxuICAgICAgICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleDogKGluZGV4KSA9PiB0aGlzLnRhYkxpc3RfW2luZGV4XS5jb21wdXRlRGltZW5zaW9ucygpLFxuICAgICAgICBnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4OiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhYkxpc3RfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJMaXN0X1tpXS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rm9jdXNlZFRhYkluZGV4OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFiRWxlbWVudHMgPSB0aGlzLmdldFRhYkVsZW1lbnRzXygpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgIHJldHVybiB0YWJFbGVtZW50cy5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbmRleE9mVGFiOiAodGFiVG9GaW5kKSA9PiB0aGlzLnRhYkxpc3RfLmluZGV4T2YodGFiVG9GaW5kKSxcbiAgICAgICAgZ2V0VGFiTGlzdExlbmd0aDogKCkgPT4gdGhpcy50YWJMaXN0Xy5sZW5ndGgsXG4gICAgICAgIG5vdGlmeVRhYkFjdGl2YXRlZDogKGluZGV4KSA9PiB0aGlzLmVtaXQoTURDVGFiQmFyRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9BQ1RJVkFURURfRVZFTlQsIHtpbmRleH0sIHRydWUpLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICovXG4gIGFjdGl2YXRlVGFiKGluZGV4KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5hY3RpdmF0ZVRhYihpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRIZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqL1xuICBzY3JvbGxJbnRvVmlldyhpbmRleCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2Nyb2xsSW50b1ZpZXcoaW5kZXgpO1xuICB9XG5cbiAgZ2V0VGFiRWxlbWVudHNfKCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvckFsbChNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX1NFTEVDVE9SKSk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENUYWJCYXIsIE1EQ1RhYkJhckZvdW5kYXRpb259O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5UYWJCYXIgPSBleHBvcnRzLlRhYiA9IGV4cG9ydHMuVGFiSWNvbiA9IGV4cG9ydHMuVGFiTGFiZWwgPSB2b2lkIDA7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfdGFiQmFyID0gcmVxdWlyZShcIkBtYXRlcmlhbC90YWItYmFyXCIpO1xuXG52YXIgX3ByZWFjdCA9IHJlcXVpcmUoXCJwcmVhY3RcIik7XG5cbnZhciBfTWF0ZXJpYWxDb21wb25lbnQ1ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vQmFzZS9NYXRlcmlhbENvbXBvbmVudFwiKSk7XG5cbnZhciBUYWJMYWJlbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hdGVyaWFsQ29tcG9uZW50KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRhYkxhYmVsLCBfTWF0ZXJpYWxDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRhYkxhYmVsKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRhYkxhYmVsKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVGFiTGFiZWwpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzLmNvbXBvbmVudE5hbWUgPSAndGFiX190ZXh0LWxhYmVsJztcbiAgICBfdGhpcy5tZGNQcm9wcyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRhYkxhYmVsLCBbe1xuICAgIGtleTogXCJtYXRlcmlhbERvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRlcmlhbERvbShwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhYkxhYmVsO1xufShfTWF0ZXJpYWxDb21wb25lbnQ1LmRlZmF1bHQpO1xuXG5leHBvcnRzLlRhYkxhYmVsID0gVGFiTGFiZWw7XG5cbnZhciBUYWJJY29uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWF0ZXJpYWxDb21wb25lbnQyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRhYkljb24sIF9NYXRlcmlhbENvbXBvbmVudDIpO1xuXG4gIGZ1bmN0aW9uIFRhYkljb24oKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRhYkljb24pO1xuICAgIF90aGlzMiA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVGFiSWNvbikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMyLmNvbXBvbmVudE5hbWUgPSAndGFiX19pY29uJztcbiAgICBfdGhpczIubWRjUHJvcHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGFiSWNvbiwgW3tcbiAgICBrZXk6IFwibWF0ZXJpYWxEb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0ZXJpYWxEb20ocHJvcHMpIHtcbiAgICAgIHJldHVybiAoMCwgX3ByZWFjdC5oKShcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJtYXRlcmlhbC1pY29uc1wiXG4gICAgICB9LCBwcm9wcyksIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhYkljb247XG59KF9NYXRlcmlhbENvbXBvbmVudDUuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVGFiSWNvbiA9IFRhYkljb247XG5cbnZhciBUYWIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXRlcmlhbENvbXBvbmVudDMpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiLCBfTWF0ZXJpYWxDb21wb25lbnQzKTtcblxuICBmdW5jdGlvbiBUYWIoKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRhYik7XG4gICAgX3RoaXMzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzMy5jb21wb25lbnROYW1lID0gJ3RhYic7XG4gICAgX3RoaXMzLm1kY1Byb3BzID0gWydhY3RpdmUnXTtcbiAgICBfdGhpczMubWRjTm90aWZ5UHJvcHMgPSBbJ2FjdGl2ZSddO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWIsIFt7XG4gICAga2V5OiBcIm1hdGVyaWFsRG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGVyaWFsRG9tKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9wcmVhY3QuaCkoXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWJcIixcbiAgICAgICAgcm9sZTogXCJ0YWJcIixcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiXG4gICAgICB9LCBwcm9wcyksICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWJfX2NvbnRlbnRcIlxuICAgICAgfSwgcHJvcHMuY2hpbGRyZW4pLCAoMCwgX3ByZWFjdC5oKShcInNwYW5cIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiLWluZGljYXRvciBcIi5jb25jYXQocHJvcHMuYWN0aXZlID8gJ21kYy10YWItaW5kaWNhdG9yLS1hY3RpdmUnIDogJycpXG4gICAgICB9LCAoMCwgX3ByZWFjdC5oKShcInNwYW5cIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiLWluZGljYXRvcl9fY29udGVudCBtZGMtdGFiLWluZGljYXRvcl9fY29udGVudC0tdW5kZXJsaW5lXCJcbiAgICAgIH0pKSwgKDAsIF9wcmVhY3QuaCkoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYl9fcmlwcGxlXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhYjtcbn0oX01hdGVyaWFsQ29tcG9uZW50NS5kZWZhdWx0KTtcblxuZXhwb3J0cy5UYWIgPSBUYWI7XG5cbnZhciBUYWJCYXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXRlcmlhbENvbXBvbmVudDQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiQmFyLCBfTWF0ZXJpYWxDb21wb25lbnQ0KTtcblxuICBmdW5jdGlvbiBUYWJCYXIoKSB7XG4gICAgdmFyIF90aGlzNDtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRhYkJhcik7XG4gICAgX3RoaXM0ID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJCYXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzNC5jb21wb25lbnROYW1lID0gJ3RhYi1iYXInO1xuICAgIF90aGlzNC5tZGNQcm9wcyA9IFtdO1xuICAgIF90aGlzNC5tZGNOb3RpZnlQcm9wcyA9IFsnYWN0aXZlVGFiSW5kZXgnXTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGFiQmFyLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJCYXIucHJvdG90eXBlKSwgXCJjb21wb25lbnREaWRNb3VudFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICAgIHRoaXMuTURDb21wb25lbnQgPSBuZXcgX3RhYkJhci5NRENUYWJCYXIodGhpcy5jb250cm9sKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZnRlckNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYkJhci5wcm90b3R5cGUpLCBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLk1EQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuTURDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRlcmlhbERvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRlcmlhbERvbShwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfcHJlYWN0LmgpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYi1iYXJcIixcbiAgICAgICAgcm9sZTogXCJ0YWJsaXN0XCIsXG4gICAgICAgIHJlZjogdGhpcy5zZXRDb250cm9sUmVmXG4gICAgICB9LCAoMCwgX3ByZWFjdC5oKShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItc2Nyb2xsZXJcIlxuICAgICAgfSwgKDAsIF9wcmVhY3QuaCkoXCJkaXZcIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYVwiXG4gICAgICB9LCAoMCwgX3ByZWFjdC5oKShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1jb250ZW50XCJcbiAgICAgIH0sIHByb3BzLmNoaWxkcmVuKSkpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhYkJhcjtcbn0oX01hdGVyaWFsQ29tcG9uZW50NS5kZWZhdWx0KTtcblxuZXhwb3J0cy5UYWJCYXIgPSBUYWJCYXI7XG5cbnZhciBkZWZhdWx0XzEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9UYWJCYXIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoZGVmYXVsdF8xLCBfVGFiQmFyKTtcblxuICBmdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgZGVmYXVsdF8xKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShkZWZhdWx0XzEpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRfMTtcbn0oVGFiQmFyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuZGVmYXVsdF8xLlRhYiA9IFRhYjtcbmRlZmF1bHRfMS5UYWJMYWJlbCA9IFRhYkxhYmVsO1xuZGVmYXVsdF8xLlRhYkljb24gPSBUYWJJY29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXHJcblxyXG5pbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuXHJcbmNvbnN0IERhdGVMaW5lYnJlYWsgPSh7ZGF0ZXRpbWV9KT0+e1xyXG4gICAgcmV0dXJuIChcclxuPGRpdiBzdHlsZT17e2Rpc3BsYXk6XCJmbGV4XCJ9fT5cclxuPGRpdiBzdHlsZT17e2ZsZXg6XCIxXCJ9fT48aHIgLz48L2Rpdj5cclxuPGRpdj57bmV3IERhdGUoZGF0ZXRpbWUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfTwvZGl2PlxyXG48ZGl2IHN0eWxlPXt7ZmxleDoxfX0+PGhyIC8+PC9kaXY+XHJcbjwvZGl2PlxyXG4pXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGVMaW5lYnJlYWsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcblxyXG5jb25zdCBNZXNzYWdlQWxpZ25lciA9ICh7IGNoaWxkcmVuLCBzaWRlLCBzdHlsZSB9KSA9PiB7XHJcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBzaWRlID09PSBcImxlZnRcIiA/IFwiZmxleC1zdGFydFwiIDogXCJmbGV4LWVuZFwiXHJcbiAgICByZXR1cm4gPGRpdiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwganVzdGlmeUNvbnRlbnQ6IGFsaWdubWVudCwgLi4uc3R5bGUgfX0+e2NoaWxkcmVufTwvZGl2PlxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUFsaWduZXIiLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcclxuXHJcblxyXG5jb25zdCBNZXNzYWdlVmlldyA9ICh7IG1lc3NhZ2UsIGJhY2tncm91bmRDb2xvciwgZGF0ZXRpbWUgfSkgPT4gKFxyXG48ZGl2IHN0eWxlPXt7XHJcbiAgYmFja2dyb3VuZENvbG9yLFxyXG4gIHBhZGRpbmc6IDUsXHJcbiAgbWFyZ2luOiAyLFxyXG4gIGJvcmRlclJhZGl1czogMTUsXHJcbiAgYm9yZGVyQ29sb3I6ICcjOUU5RTlFJyxcclxuICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcclxuICBib3JkZXJXaWR0aDogMixcclxuICBtYXhXaWR0aDogJzEwMCUnLFxyXG4gIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXHJcbiAgd29yZEJyZWFrOiAnYnJlYWstYWxsJyxcclxuICBtaW5XaWR0aDogJzMwJScsXHJcbn19XHJcbj5cclxuICAgIDxkaXY+e21lc3NhZ2V9PC9kaXY+XHJcbiAgICA8ZGl2IHN0eWxlPXt7XHJcbiAgICAgIGZvbnRTaXplOiAxMCxcclxuICAgICAgcGFkZGluZ1RvcDogMixcclxuICAgICAgdGV4dEFsaWduOiAnZW5kJyxcclxuICAgIH19XHJcbiAgICA+XHJcbjxpIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogJyNlZmViZTknIH19PntuZXcgRGF0ZShkYXRldGltZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9PC9pPlxyXG5cclxuICAgIDwvZGl2PlxyXG48L2Rpdj5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VWaWV3O1xyXG4iLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9tZXNzYWdlLXZpZXcnXHJcblxyXG5jb25zdCBTdWJzZXF1ZW50TWVzc2FnZSA9ICh7IG1lc3NhZ2UsIGRhdGV0aW1lIH0pID0+IHtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBtYXJnaW5MZWZ0OjQ1IH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVzc2FnZSBtZXNzYWdlPXttZXNzYWdlfSBkYXRldGltZT17ZGF0ZXRpbWV9IGJhY2tncm91bmRDb2xvcj1cIiNGRkVDQjNcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3Vic2VxdWVudE1lc3NhZ2UiLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcclxuXHJcbmNvbnN0IHN0eWxlID0ge1xyXG4gIGhlaWdodDogMzAsXHJcbiAgd2lkdGg6IDQwLFxyXG4gIHBhZGRpbmc6IDMsXHJcbiAgYm9yZGVyUmFkaXVzOiAzMCxcclxuICBiYWNrZ3JvdW5kQ29sb3I6ICdkYXJrU21va2UnLFxyXG4gIGJvcmRlclN0eWxlOiAnc29saWQnLFxyXG4gIGJvcmRlcldpZHRoOiAyLFxyXG4gIGRpc3BsYXk6ICdmbGV4JyxcclxuICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgY29sb3I6ICcjMDA5Njg4JyxcclxuICBib3JkZXJDb2xvcjogJyM4MGNiYzQnLFxyXG59O1xyXG5cclxuXHJcbmNvbnN0IE1lc3NhZ2VBdmF0YXIgPSAoeyBsZXR0ZXIgPSAnVScgfSkgPT4gKDxkaXYgc3R5bGU9e3N0eWxlfT48ZGl2PntsZXR0ZXIudG9VcHBlckNhc2UoKX08L2Rpdj48L2Rpdj4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUF2YXRhcjtcclxuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCBNZXNzYWdlIGZyb20gJy4vbWVzc2FnZS12aWV3J1xyXG5pbXBvcnQgTWVzc2FnZUF2YXRhciBmcm9tICcuL21lc3NhZ2UtYXZhdGFyJ1xyXG5cclxuY29uc3QgRmlyc3RNZXNzYWdlID0gKHsgbWVzc2FnZSwgZGF0ZXRpbWUsbGV0dGVyLGxvY2FsIH0pID0+IHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG5cclxuICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH19PlxyXG4gICAgICAgICAgICB7IWxvY2FsICYmPE1lc3NhZ2VBdmF0YXIgbGV0dGVyPXtsZXR0ZXJ9IC8+fVxyXG4gICAgICAgICAgICA8TWVzc2FnZSBtZXNzYWdlPXttZXNzYWdlfSBkYXRldGltZT17ZGF0ZXRpbWV9IGJhY2tncm91bmRDb2xvcj1cIiNGRkVDQjNcIiAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmlyc3RNZXNzYWdlIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvanN4LXByb3BzLW5vLXNwcmVhZGluZyAqL1xyXG5pbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcclxuaW1wb3J0IE1lc3NhZ2VBbGlnbmVyIGZyb20gJy4vbWVzc2FnZS1hbGlnbmVyJztcclxuaW1wb3J0IEZpcnN0TWVzc2FnZSBmcm9tICcuL2ZpcnN0LW1lc3NhZ2UnO1xyXG5pbXBvcnQgU3Vic2VxdWVudE1lc3NhZ2UgZnJvbSAnLi9zdWJzZXF1ZW50LW1lc3NhZ2UnO1xyXG5pbXBvcnQgRGF0ZUxpbmVicmVhayBmcm9tICcuL2RhdGUtbGluZWJyZWFrJztcclxuXHJcbmNvbnN0IE1lc3NhZ2VPYmplY3RNYXBwdGVyID0gKHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCB7IG9yZGVyLCBkYXRlU3BhY2UgfSA9IHByb3BzO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICB7ZGF0ZVNwYWNlICYmIDxEYXRlTGluZWJyZWFrIHsuLi5wcm9wc30gLz59XHJcbiAgICAgICAgICAgIDxNZXNzYWdlQWxpZ25lciB7Li4ucHJvcHN9PlxyXG4gICAgICAgICAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvcmRlciA9PT0gJ0YnID8gPEZpcnN0TWVzc2FnZSB7Li4ucHJvcHN9IC8+IDogPFN1YnNlcXVlbnRNZXNzYWdlIHsuLi5wcm9wc30gLz5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIDwvTWVzc2FnZUFsaWduZXI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZU9iamVjdE1hcHB0ZXI7XHJcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQge3VzZUVmZmVjdCx1c2VTdGF0ZX0gZnJvbSAncHJlYWN0L2hvb2tzJ1xyXG5cclxuY29uc3QgdXNlTWVzc2FnZVNvcnRlciA9KG1lc3NhZ2VzKT0+e1xyXG5jb25zdCBbc29ydGVkTWVzc2FnZXMsc2V0U29ydGVkTWVzc2FnZXNdPXVzZVN0YXRlKG1lc3NhZ2VzKVxyXG51c2VFZmZlY3QoKCk9PntcclxuXHJcbiAgICBzZXRTb3J0ZWRNZXNzYWdlcyhtZXNzYWdlcy5zb3J0KChhLCBiKT0+IGEuZGF0ZXRpbWUgLSBiLmRhdGV0aW1lKSlcclxufSxbbWVzc2FnZXNdKVxyXG5cclxucmV0dXJue3NvcnRlZE1lc3NhZ2VzfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB1c2VNZXNzYWdlU29ydGVyXHJcblxyXG4iLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IHt1c2VTdGF0ZSx1c2VFZmZlY3R9IGZyb20gJ3ByZWFjdC9ob29rcydcclxuXHJcbmNvbnN0IHVzZU1lc3NhZ2VzTWFwcGVyID0obWVzc2FnZXMpPT57XHJcbiAgY29uc3QgW21hcHBlZE1lc3NhZ2VzLHNldE1hcHBlZE1lc3NhZ2VzXT11c2VTdGF0ZShtZXNzYWdlcylcclxuICBjb25zdCBtYXBNZXNzYWdlcyA9KCk9PntcclxuICAgIGNvbnN0IGxvY2FsU2lkZSA9XCJyaWdodFwiXHJcbiAgICBjb25zdCByZW1vdGVTaWRlPVwibGVmdFwiXHJcbiAgICBpZihtZXNzYWdlcy5sZW5ndGg9PT0wKXtcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgICAgIGxldCBlbWFpbCA9IG1lc3NhZ2VzWzBdLmZyb21cclxuICAgICAgbGV0IGxhc3REYXRldGltZSA9IG1lc3NhZ2VzWzBdLmRhdGV0aW1lXHJcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKChtLCBpKSA9PiB7XHJcbiAgXHJcbiAgICAgIGlmIChpID09PSAwICYmIG0ubG9jYWwpIHtcclxuICAgICAgXHJcbiAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiB0cnVlIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaSA9PT0gMCAmJiAhbS5sb2NhbCkge1xyXG4gICAgIFxyXG4gICAgICAgIGNvbnN0IGxldHRlciA9IG0uZnJvbVswXSAhPT11bmRlZmluZWQgPyBtLmZyb21bMF06XCJcIlxyXG4gICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IHRydWUsbGV0dGVyIH1cclxuICAgICAgfVxyXG4gICBcclxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsID09PSBtLmZyb20gJiYgbS5sb2NhbCkge1xyXG4gICAgICAgICAgaWYgKG5ldyBEYXRlKGxhc3REYXRldGltZSkuZ2V0RGF0ZSgpICE9PSBuZXcgRGF0ZShtLmRhdGV0aW1lKS5nZXREYXRlKCkpIHtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGVtYWlsID0gbS5mcm9tXHJcbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxyXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IGxvY2FsU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IHRydWUgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogbG9jYWxTaWRlLCBvcmRlcjogXCJTXCIsIGRhdGVTcGFjZTogZmFsc2UgfVxyXG4gICAgICAgICAgXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsICE9PSBtLmZyb20gJiYgbS5sb2NhbCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgaWYgKG5ldyBEYXRlKGxhc3REYXRldGltZSkuZ2V0RGF0ZSgpID09PSBuZXcgRGF0ZShtLmRhdGV0aW1lKS5nZXREYXRlKCkpIHtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogbG9jYWxTaWRlLCBvcmRlcjogXCJGXCIsIGRhdGVTcGFjZTogZmFsc2UgfVxyXG4gICAgICAgICAgfSBcclxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiB0cnVlIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsID09PSBtLmZyb20gJiYgIW0ubG9jYWwpIHtcclxuICAgICAgICBcclxuICAgICAgICAgIGlmIChuZXcgRGF0ZShsYXN0RGF0ZXRpbWUpLmdldERhdGUoKSAhPT0gbmV3IERhdGUobS5kYXRldGltZSkuZ2V0RGF0ZSgpKSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICBjb25zdCBsZXR0ZXIgPSBtLmZyb21bMF0gIT09dW5kZWZpbmVkID8gbS5mcm9tWzBdOlwiXCJcclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IHRydWUsbGV0dGVyIH1cclxuICAgICAgICAgIH0gXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXHJcbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxyXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IHJlbW90ZVNpZGUsIG9yZGVyOiBcIlNcIiwgZGF0ZVNwYWNlOiBmYWxzZSxsZXR0ZXIgfVxyXG4gICAgICAgICAgXHJcbiAgICAgIH1cclxuICAgICAgaWYgKGkgPiAwICYmIGVtYWlsICE9PSBtLmZyb20gJiYgIW0ubG9jYWwpIHtcclxuICAgICAgICBcclxuICAgICAgICAgIGlmIChuZXcgRGF0ZShsYXN0RGF0ZXRpbWUpLmdldERhdGUoKSA9PT0gbmV3IERhdGUobS5kYXRldGltZSkuZ2V0RGF0ZSgpKSB7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXHJcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IGZhbHNlLGxldHRlciB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBjb25zdCBsZXR0ZXIgPSBtLmZyb21bMF0gIT09dW5kZWZpbmVkID8gbS5mcm9tWzBdOlwiXCJcclxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiByZW1vdGVTaWRlLCBvcmRlcjogXCJGXCIsIGRhdGVTcGFjZTogdHJ1ZSxsZXR0ZXIgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgfSlcclxuICB9XHJcblxyXG4gIHVzZUVmZmVjdCgoKT0+e1xyXG4gICAgc2V0TWFwcGVkTWVzc2FnZXMobWFwTWVzc2FnZXMoKSlcclxuICB9LFttZXNzYWdlc10pXHJcbnJldHVybiB7bWFwcGVkTWVzc2FnZXN9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHVzZU1lc3NhZ2VzTWFwcGVyXHJcbiIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kczsiLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXkgKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvanN4LXByb3BzLW5vLXNwcmVhZGluZyAqL1xyXG5pbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IE1lc3NhZ2VPYmplY3RNYXBwZXIgZnJvbSAnLi9tZXNzYWdlLW9iamVjdC1tYXBwZXInXHJcblxyXG5jb25zdCBNZXNzYWdlQ29sbGVjdGlvblZpZXcgPSAoeyBtZXNzYWdlcyB9KSA9PntcclxuXHJcbiAgICBpZihtZXNzYWdlcy5sZW5ndGg+MCl7XHJcbiAgICAgICBcclxuICAgICAgICByZXR1cm4gIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgaSkgPT4gPE1lc3NhZ2VPYmplY3RNYXBwZXIgey4uLm1lc3NhZ2V9IGtleT17aX0gLz4pXHJcbiAgICB9XHJcbiAgICAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUNvbGxlY3Rpb25WaWV3IiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tZGVwcmVjYXRlZCAqL1xyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5cclxuY29uc3QgTWVzc2FnZVZpZXdTY3JvbGxlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXZcclxuICAgICAgc3R5bGU9e3tcclxuICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDE4MGRlZylcIixcclxuICAgICAgICBoZWlnaHQ6IFwiODUlXCIsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZGVmZjJcIixcclxuICAgICAgICBvdmVyZmxvdzogXCJzY3JvbGxcIixcclxuICAgICAgICB3aWR0aDpcIjEwMCVcIlxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICA8ZGl2IHN0eWxlPXt7IHRyYW5zZm9ybTogXCJyb3RhdGUoMTgwZGVnKVwiIH19PlxyXG4gICAgICAgIHsgY2hpbGRyZW59XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VWaWV3U2Nyb2xsZXI7XHJcblxyXG5cclxuIiwiXHJcbmltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xyXG5cclxuY29uc3QgTWVzc2FnZUVkaXRvckRpc3BsYXllciA9ICh7XHJcbiAgb25NZXNzYWdlQ2hhbmdlLCBtZXNzYWdlLCBzZW5kTWVzc2FnZSwgaWQgPSAwLCBkaXNhYmxlZCxcclxufSkgPT4gKFxyXG4gIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnIH19PlxyXG4gICAgPGlucHV0IHN0eWxlPXt7IGZsZXg6IDEgfX0gZGF0YS10ZXN0aWQ9e2BtZXNzYWdlJHtpZH1gfSBvbklucHV0PXtvbk1lc3NhZ2VDaGFuZ2V9IHZhbHVlPXttZXNzYWdlfSBuYW1lPVwibWVzc2FnZVwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJFbnRlciBtZXNzYWdlIHRleHRcIiAvPlxyXG4gICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcgfX0+XHJcbiAgICAgICAgICA8YnV0dG9uIGRhdGEtdGVzdGlkPXtgc2VuZE1lc3NhZ2Uke2lkfWB9IGRpc2FibGVkPXttZXNzYWdlID09PSAnJyB8fCBkaXNhYmxlZH0gc3R5bGU9e3sgbWFyZ2luTGVmdDogMiwgd2lkdGg6ICcxMDAlJyB9fSBvbkNsaWNrPXtzZW5kTWVzc2FnZX0+XHJcblxyXG4gICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMi4wMSAyMUwyMyAxMiAyLjAxIDMgMiAxMGwxNSAyLTE1IDJ6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgPC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuKTtcclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUVkaXRvckRpc3BsYXllcjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tc2hhZG93ICovXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB1c2VNZXNzYWdlU29ydGVyIGZyb20gXCIuL3VzZU1lc3NhZ2VTb3J0ZXJcIjtcclxuaW1wb3J0IHVzZU1lc3NhZ2VNYXBwZXIgZnJvbSBcIi4vdXNlTWVzc2FnZU1hcHBlclwiO1xyXG5pbXBvcnQgTWVzc2FnZUNvbGxlY3Rpb25WaWV3IGZyb20gXCIuL21lc3NhZ2UtY29sbGVjdGlvbi12aWV3XCI7XHJcbmltcG9ydCBNZXNzYWdlVmlld1Njcm9sbGVyIGZyb20gXCIuL21lc3NhZ2VzLXZpZXctc2Nyb2xsZXJcIjtcclxuaW1wb3J0IE1lc3NhZ2VFZGl0b3JEaXNwbGF5ZXIgZnJvbSBcIi4uLy4uL21lc3NhZ2UtZWRpdG9yLWRpc3BsYXllclwiO1xyXG5cclxuY29uc3QgTWVzc2FnZXNEaXNwbGF5ZXIgPSAoe1xyXG4gIG1lc3NhZ2VzLFxyXG4gIHNvY2tldCxcclxuICBpZCxcclxuICBtZXNzYWdlVGV4dCxcclxuICBzZW5kTWVzc2FnZSxcclxuICBoYW5kbGVNZXNzYWdlQ2hhbmdlXHJcbn0pID0+IHtcclxuICBjb25zdCB7IHNvcnRlZE1lc3NhZ2VzIH0gPSB1c2VNZXNzYWdlU29ydGVyKG1lc3NhZ2VzKTtcclxuICBjb25zdCB7IG1hcHBlZE1lc3NhZ2VzIH0gPSB1c2VNZXNzYWdlTWFwcGVyKHNvcnRlZE1lc3NhZ2VzKTtcclxuICByZXR1cm4gW1xyXG5cclxuICAgICAgPE1lc3NhZ2VWaWV3U2Nyb2xsZXI+XHJcbiAgICAgICAgPE1lc3NhZ2VDb2xsZWN0aW9uVmlldyBtZXNzYWdlcz17bWFwcGVkTWVzc2FnZXN9IC8+XHJcbiAgICAgIDwvTWVzc2FnZVZpZXdTY3JvbGxlcj4sXHJcbiAgICAgIDxNZXNzYWdlRWRpdG9yRGlzcGxheWVyXHJcbiAgICAgICAgZGlzYWJsZWQ9e3NvY2tldCA9PT0gbnVsbH1cclxuICAgICAgICBpZD17aWR9XHJcbiAgICAgICAgbWVzc2FnZT17bWVzc2FnZVRleHR9XHJcbiAgICAgICAgc2VuZE1lc3NhZ2U9e3NlbmRNZXNzYWdlfVxyXG4gICAgICAgIG9uTWVzc2FnZUNoYW5nZT17aGFuZGxlTWVzc2FnZUNoYW5nZX1cclxuICAgICAgLz5cclxuXHJcbiAgXTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VzRGlzcGxheWVyO1xyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgTWVzc2FnZURpc3BsYXllciBmcm9tIFwiLi4vLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyXCI7XHJcbmltcG9ydCAnLi9zdHlsZS5jc3MnXHJcbmNvbnN0IENoYXRVc2VyID0gKHtcclxuICBuYW1lLFxyXG4gIHRhcmdldE5hbWUsXHJcbiAgc29ja2V0LFxyXG4gIGVycm9ycyxcclxuICBtZXNzYWdlcyxcclxuICBoYW5kbGVNZXNzYWdlQ2hhbmdlLFxyXG4gIG1lc3NhZ2VUZXh0LFxyXG4gIHNlbmRNZXNzYWdlXHJcbn0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyb290XCIgc3R5bGU9e3sgaGVpZ2h0OiBcIjk3JVwiLCB3aWR0aDpcIjUwJVwiIH19PlxyXG4gICAgICA8TWVzc2FnZURpc3BsYXllclxyXG4gICAgICAgIGVycm9ycz17ZXJyb3JzfVxyXG4gICAgICAgIHNvY2tldD17c29ja2V0fVxyXG4gICAgICAgIG1lc3NhZ2VzPXttZXNzYWdlc31cclxuICAgICAgICBoYW5kbGVNZXNzYWdlQ2hhbmdlPXtoYW5kbGVNZXNzYWdlQ2hhbmdlfVxyXG4gICAgICAgIG1lc3NhZ2VUZXh0PXttZXNzYWdlVGV4dH1cclxuICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1lc3NhZ2V9XHJcbiAgICAgIC8+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hhdFVzZXI7XHJcbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJpbXBvcnQge2gsIENvbXBvbmVudH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQge3VzZVN0YXRlLCB1c2VFZmZlY3R9IGZyb20gJ3ByZWFjdC9ob29rcydcclxuXHJcbmNvbnN0IHVzZVNvY2tldE1lc3NhZ2luZyA9KHtzb2NrZXQsdGFyZ2V0TmFtZX0pPT57XHJcbmNvbnN0IFttZXNzYWdlVGV4dCxzZXRNZXNzYWdlVGV4dF09dXNlU3RhdGUoJycpXHJcbmNvbnN0IFttZXNzYWdlUmVjaWV2ZWQsc2V0TWVzc2FnZVJlY2lldmVkXT11c2VTdGF0ZShudWxsKVxyXG5jb25zdCBbbWVzc2FnZVNlbnQsc2V0TWVzc2FnZVNlbnRdPXVzZVN0YXRlKG51bGwpXHJcbmNvbnN0IFtjb25uZWN0ZWQsc2V0Q29ubmVjdGVkXT11c2VTdGF0ZShmYWxzZSlcclxuY29uc3QgW2Vycm9ycyxzZXRFcnJvcl09dXNlU3RhdGUoW10pXHJcbiAgY29uc3QgICBzZW5kTWVzc2FnZSA9ICgpID0+IHtcclxuICBjb25zdCBkYXRldGltZSA9ICBuZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gIHNvY2tldC5lbWl0KFwidGV4dF9tZXNzYWdlXCIse1xyXG4gICAgcmVjaWV2ZXI6dGFyZ2V0TmFtZSxcclxuICAgIG1lc3NhZ2U6IG1lc3NhZ2VUZXh0LFxyXG4gICAgZGF0ZXRpbWV9KTtcclxuICBzZXRNZXNzYWdlU2VudCh7cmVjaWV2ZXI6dGFyZ2V0TmFtZSxkYXRldGltZSxtZXNzYWdlOm1lc3NhZ2VUZXh0fSlcclxuICBzZXRNZXNzYWdlVGV4dCgnJylcclxufVxyXG5cclxuY29uc3QgaGFuZGxlTWVzc2FnZUNoYW5nZSA9KGUpPT57XHJcblxyXG5zZXRNZXNzYWdlVGV4dChlLnRhcmdldC52YWx1ZSlcclxuXHJcbn1cclxuXHJcbiAgdXNlRWZmZWN0KCgpPT57XHJcbiAgICBpZihzb2NrZXQgIT09bnVsbCl7XHJcblxyXG4gICAgIFxyXG4gICAgICBzb2NrZXQub24oXCJ0ZXh0X21lc3NhZ2VcIiwgZGF0YSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzZW5kZXIgLCBtZXNzYWdlLCBkYXRldGltZSB9ID0gZGF0YTtcclxuICAgICAgIFxyXG4gICAgICBzZXRNZXNzYWdlUmVjaWV2ZWQoe3NlbmRlcixtZXNzYWdlLGRhdGV0aW1lfSlcclxuICAgICAgfSk7XHJcbiAgICAgIHNvY2tldC5vbihcImNvbm5lY3RcIiwoKT0+e1xyXG4gICAgICAgXHJcbiAgICAgICAgc2V0Q29ubmVjdGVkKHRydWUpXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwoKT0+e1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNldENvbm5lY3RlZChmYWxzZSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHNvY2tldC5vbignZXJyb3InLChlcnJvcik9PntcclxuICAgICAgICBzZXRFcnJvcihbLi4uZXJyb3JzLGVycm9yXSlcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgfSlcclxuXHJcblxyXG5cclxucmV0dXJuIHttZXNzYWdlUmVjaWV2ZWQsbWVzc2FnZVNlbnQsbWVzc2FnZVRleHQsc2VuZE1lc3NhZ2UsaGFuZGxlTWVzc2FnZUNoYW5nZSxlcnJvcnMsY29ubmVjdGVkfVxyXG5cclxufVxyXG5leHBvcnQgZGVmYXVsdCB1c2VTb2NrZXRNZXNzYWdpbmdcclxuXHJcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQge3VzZVN0YXRlLHVzZUVmZmVjdH0gZnJvbSAncHJlYWN0L2hvb2tzJ1xyXG5cclxuY29uc3QgdXNlQ2hhdExvZyA9KHtuYW1lLG1lc3NhZ2VSZWNpZXZlZCxtZXNzYWdlU2VudH0pPT57XHJcbiAgY29uc3QgW21lc3NhZ2VzLHNldE1lc3NhZ2VzXT11c2VTdGF0ZShbXSlcclxuICBcclxuICBjb25zdCBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSAobSwga2V5KSA9PiB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZWRNZXNzYWdlcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkgPT09IG51bGwgPyBbbV0gOiBbLi4uSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKSwgbV1cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkocGVyc2lzdGVkTWVzc2FnZXMpKTtcclxuICAgIHJldHVybiBwZXJzaXN0ZWRNZXNzYWdlc1xyXG59XHJcbiAgLy8gY29tcG9uZW50RGlkTW91bnRcclxuICB1c2VFZmZlY3QoKCk9PntcclxuICAgIHNldE1lc3NhZ2VzKEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkpID09PSBudWxsID9cclxuICAgICBbXSA6IFsuLi5KU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpKV0pXHJcbiAgICAgXHJcbiAgfSxbXSlcclxuICAvLyBzYXZlUmVtb3RlTWVzc2FnZVxyXG4gdXNlRWZmZWN0KCgpPT57XHJcbiAgIGlmKG1lc3NhZ2VSZWNpZXZlZCE9PW51bGwpXHJcbiAgIHtcclxuICAgIGNvbnN0IHsgZGF0ZXRpbWUsIG1lc3NhZ2UsIHNlbmRlciB9ID0gbWVzc2FnZVJlY2lldmVkXHJcbiAgICBjb25zdCBsb2NhbCA9IGZhbHNlXHJcbiAgc2V0TWVzc2FnZXMoc2F2ZVRvTG9jYWxTdG9yYWdlKCB7IG1lc3NhZ2UsIGZyb206IHNlbmRlciwgbG9jYWwsIGRhdGV0aW1lLCB0bzogbmFtZSB9LG5hbWUpKVxyXG4gICB9XHJcbiAgXHJcbiB9LFttZXNzYWdlUmVjaWV2ZWRdKVxyXG5cclxuICAvLyBzYXZlTG9jYWxNZXNzYWdlXHJcbiAgdXNlRWZmZWN0KCgpPT57XHJcbiAgICBpZihtZXNzYWdlU2VudCE9PW51bGwpe1xyXG4gICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGV0aW1lLCBtZXNzYWdlLCByZWNpZXZlciB9ID0gbWVzc2FnZVNlbnRcclxuICAgICAgY29uc3QgbG9jYWwgPSB0cnVlXHJcbiAgICAgIGNvbnN0IGZyb20gPW5hbWVcclxuICAgIHNldE1lc3NhZ2VzKHNhdmVUb0xvY2FsU3RvcmFnZSggeyBtZXNzYWdlLCBmcm9tLCBsb2NhbCwgZGF0ZXRpbWUsIHRvOiByZWNpZXZlciB9LG5hbWUpKVxyXG5cclxuICAgIH1cclxufSxbbWVzc2FnZVNlbnRdKVxyXG4gXHJcbiAgcmV0dXJuIHttZXNzYWdlc31cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgdXNlQ2hhdExvZ1xyXG5cclxuIiwiLyoqXHJcbiAqIFBhcnNlcyBhbiBVUklcclxuICpcclxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcclxuXHJcbnZhciBwYXJ0cyA9IFtcclxuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcclxuICAgIHZhciBzcmMgPSBzdHIsXHJcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXHJcbiAgICAgICAgdXJpID0ge30sXHJcbiAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcclxuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVyaTtcclxufTtcclxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHQvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcblx0XHQvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG5cblx0XHQvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zdCBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuXHRcdFx0aW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdHJldHVybiB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcblx0XHRjb25zb2xlLmxvZyAmJlxuXHRcdGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uKTtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5leHBvcnQgZGVmYXVsdCBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuaW1wb3J0ICogYXMgaWVlZTc1NCBmcm9tICcuL2llZWU3NTQnXG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXknXG5cbmV4cG9ydCB2YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWVcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5leHBvcnQge19rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGh9O1xuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICByZXR1cm4gdHJ1ZTtcbiAgLy8gcm9sbHVwIGlzc3Vlc1xuICAvLyB0cnkge1xuICAvLyAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAvLyAgIGFyci5fX3Byb3RvX18gPSB7XG4gIC8vICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuICAvLyAgICAgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gIC8vICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIC8vICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICByZXR1cm4gZmFsc2VcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIC8vICAgdmFsdWU6IG51bGwsXG4gICAgLy8gICBjb25maWd1cmFibGU6IHRydWVcbiAgICAvLyB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbnZhciB3aXRoTmF0aXZlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IChvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKHdpdGhOYXRpdmVCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHNlbGZbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG4iLCIvKipcclxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcclxuICovXHJcblxyXG52YXIgQmxvYkJ1aWxkZXIgPSB0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJLaXRCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1vekJsb2JCdWlsZGVyIDogXHJcbiAgZmFsc2U7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xyXG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXHJcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcclxuICAgIHJldHVybiBiLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcclxuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XHJcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcclxuICByZXR1cm4gYXJ5Lm1hcChmdW5jdGlvbihjaHVuaykge1xyXG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XHJcblxyXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcclxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXHJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNodW5rO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICBiYi5hcHBlbmQocGFydCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJsb2IobWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLCBvcHRpb25zIHx8IHt9KTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBCbG9iQnVpbGRlckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG4gIEJsb2JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBCbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufSkoKTtcclxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGZyLnJlc3VsdCB9LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBidG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gb3B0cy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIHJlc3VsdHMgb2YgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uXG4gIHRoaXMuaXNSZWFjdE5hdGl2ZSA9IG9wdHMuaXNSZWFjdE5hdGl2ZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXHJcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcclxuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG5cclxuICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcclxuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHFzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xyXG4gIHZhciBxcnkgPSB7fTtcclxuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcclxuICB9XHJcbiAgcmV0dXJuIHFyeTtcclxufTtcclxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qIGdsb2JhbCBhdHRhY2hFdmVudCAqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSkgfHxcbiAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcbiAgb3B0cy53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gb3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnN1cHBvcnRzQmluYXJ5ICYmIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsgY2hhcnNldD1VVEYtOCcpIHtcbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09ICdudW1iZXInID8geGhyLnN0YXR1cyA6IDApO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsgY2hhcnNldD1VVEYtOCcpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIGF0dGFjaEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGVybWluYXRpb25FdmVudCA9ICdvbnBhZ2VoaWRlJyBpbiBzZWxmID8gJ3BhZ2VoaWRlJyA6ICd1bmxvYWQnO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodGVybWluYXRpb25FdmVudCwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIFVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbCBpcyBzaGlwcGVkLlxuICovXG5mdW5jdGlvbiBnbG9iICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbn1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICB2YXIgZ2xvYmFsID0gZ2xvYigpO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW8gPSAoZ2xvYmFsLl9fX2VpbyB8fCBbXSk7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge307XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbnZhciBCcm93c2VyV2ViU29ja2V0LCBOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldDtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldEltcGwgPSBCcm93c2VyV2ViU29ja2V0IHx8IE5vZGVXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPVxuICAgICAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIXRoaXMuaXNSZWFjdE5hdGl2ZVxuICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgID8gbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmkpXG4gICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0SW1wbCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldEltcGwgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmVcbiAgICA6ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbi5wb3J0XG4gICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgIDogKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlICE9PSBvcHRzLndpdGhDcmVkZW50aWFscztcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJyk7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBvciBSZWFjdE5hdGl2ZSBjbGllbnRcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmlzUmVhY3ROYXRpdmUpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCB0aGlzLndpdGhDcmVkZW50aWFscyxcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApLFxuICAgIGlzUmVhY3ROYXRpdmU6IHRoaXMuaXNSZWFjdE5hdGl2ZVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAoaW8sIG5zcCwgb3B0cykge1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZmxhZ3MgPSB7fTtcbiAgaWYgKG9wdHMgJiYgb3B0cy5xdWVyeSkge1xuICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB9XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6ICh0aGlzLmZsYWdzLmJpbmFyeSAhPT0gdW5kZWZpbmVkID8gdGhpcy5mbGFncy5iaW5hcnkgOiBoYXNCaW4oYXJncykpID8gcGFyc2VyLkJJTkFSWV9FVkVOVCA6IHBhcnNlci5FVkVOVCxcbiAgICBkYXRhOiBhcmdzXG4gIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICB0aGlzLmZsYWdzID0ge307XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnID8gcGFyc2Vxcy5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuICAgICAgZGVidWcoJ3NlbmRpbmcgY29ubmVjdCBwYWNrZXQgd2l0aCBxdWVyeSAlcycsIHF1ZXJ5KTtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVCwgcXVlcnk6IHF1ZXJ5fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IHBhY2tldC5uc3AgPT09IHRoaXMubnNwO1xuICB2YXIgcm9vdE5hbWVzcGFjZUVycm9yID0gcGFja2V0LnR5cGUgPT09IHBhcnNlci5FUlJPUiAmJiBwYWNrZXQubnNwID09PSAnLyc7XG5cbiAgaWYgKCFzYW1lTmFtZXNwYWNlICYmICFyb290TmFtZXNwYWNlRXJyb3IpIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChjb21wcmVzcykge1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBiaW5hcnkgZmxhZ1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0aGUgZW1pdHRlZCBkYXRhIGNvbnRhaW5zIGJpbmFyeVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuYmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICB0aGlzLmZsYWdzLmJpbmFyeSA9IGJpbmFyeTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCBpbyBmcm9tIFwic29ja2V0LmlvLWNsaWVudFwiO1xyXG5cclxuY29uc3QgdXNlU29ja2V0ID0gKHt1c2VybmFtZSxyb3V0ZT0nL2Fub255bW91cycsc2VydmVyVXJsfSkgPT4ge1xyXG4gIGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtzb2NrZXRFcnJvciwgc2V0U29ja2V0RXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaFRva2VuKCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocm91dGUsIHtcclxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJuYW1lIH0pLFxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgIHNldFNvY2tldChpbyhzZXJ2ZXJVcmwsIHsgcXVlcnk6IGB0b2tlbj0ke2RhdGEudG9rZW59YCB9KSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgc2V0U29ja2V0RXJyb3IoZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmZXRjaFRva2VuKCk7XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHNvY2tldCAhPT0gbnVsbCkge1xyXG4gICAgICBzb2NrZXQub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XHJcbiAgICAgICAgc2V0U29ja2V0RXJyb3IoZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgICAgc29ja2V0Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XHJcbiAgICAgICAgc2V0Q29ubmVjdGVkKHRydWUpO1xyXG4gICAgICB9KTtcclxuICAgICAgc29ja2V0Lm9uKFwibWVzc2FnZVwiLCgpPT57XHJcblxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH0sIFtzb2NrZXRdKTtcclxuICByZXR1cm4geyBzb2NrZXQsIGNvbm5lY3RlZCwgc29ja2V0RXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHVzZVNvY2tldDtcclxuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCB1c2VTb2NrZXRNZXNzYWdpbmcgZnJvbSBcIi4vdXNlU29ja2V0TWVzc2FnaW5nXCI7XHJcbmltcG9ydCB1c2VDaGF0TG9nIGZyb20gXCIuLi91c2VDaGF0TG9nXCI7XHJcbmltcG9ydCB1c2VTb2NrZXQgZnJvbSBcIi4vdXNlU29ja2V0XCJcclxuY29uc3QgdXNlU29ja2V0Q2xpZW50ID0oeyBuYW1lLCB0YXJnZXROYW1lLHJvdXRlLHNlcnZlclVybCB9KT0+e1xyXG4gICBjb25zdCB7c29ja2V0LCBjb25uZWN0ZWQsIHNvY2tldEVycm9yfSA9IHVzZVNvY2tldCh7dXNlcm5hbWU6bmFtZSxyb3V0ZSxzZXJ2ZXJVcmx9KVxyXG4gICAgY29uc3Qge1xyXG4gXHJcbiAgICAgICAgZXJyb3JzLFxyXG4gICAgICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2UsXHJcbiAgICAgICAgbWVzc2FnZVJlY2lldmVkLFxyXG4gICAgICAgIG1lc3NhZ2VTZW50LFxyXG4gICAgICAgIG1lc3NhZ2VUZXh0LFxyXG4gICAgICAgIHNlbmRNZXNzYWdlXHJcbiAgICAgIH0gPSB1c2VTb2NrZXRNZXNzYWdpbmcoeyBzb2NrZXQsIHRhcmdldE5hbWUgfSk7XHJcbiAgICAgIGNvbnN0IHsgbWVzc2FnZXMgfSA9IHVzZUNoYXRMb2coeyBuYW1lLCBtZXNzYWdlUmVjaWV2ZWQsIG1lc3NhZ2VTZW50IH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHttZXNzYWdlcyxtZXNzYWdlUmVjaWV2ZWQsbWVzc2FnZVNlbnQsbWVzc2FnZVRleHQsc2VuZE1lc3NhZ2UsZXJyb3JzLGNvbm5lY3RlZCxoYW5kbGVNZXNzYWdlQ2hhbmdlfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB1c2VTb2NrZXRDbGllbnQiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgVGFiQmFyIGZyb20gXCJwcmVhY3QtbWF0ZXJpYWwtY29tcG9uZW50cy9UYWJCYXJcIjtcclxuaW1wb3J0IFwicHJlYWN0LW1hdGVyaWFsLWNvbXBvbmVudHMvVGFiQmFyL3N0eWxlLmNzc1wiO1xyXG5pbXBvcnQgXCJwcmVhY3QtbWF0ZXJpYWwtY29tcG9uZW50cy9UYWJzL3N0eWxlLmNzc1wiO1xyXG5cclxuaW1wb3J0IENoYXRVc2VyIGZyb20gXCIuL0NoYXRVc2VyXCI7XHJcbmltcG9ydCBcIi4vc3R5bGUuY3NzXCI7XHJcbmltcG9ydCB1c2VTb2NrZXRDbGllbnQgZnJvbSBcInNvY2tldC1pby1tZXNzYWdpbmcvdXNlU29ja2V0Q2xpZW50XCI7XHJcblxyXG5jb25zdCBDaGF0Um9vbSA9ICgpID0+IHtcclxuICBjb25zdCBbbXNnRm9yTWFyaW8sIHNldE1zZ0Zvck1hcmlvXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFttc2dGb3JEcmFnb3MsIHNldE1zZ0ZvckRyYWdvc10gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbc2VsZWN0ZWRJdGVtLCBzZXRTZWxlY3RlZEl0ZW1dID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIGNvbnN0IHtcclxuICAgIG1lc3NhZ2VzOiBtc2dNYXJpbyxcclxuICAgIG1lc3NhZ2VSZWNpZXZlZDogbXNnUmVjTWFyaW8sXHJcbiAgICBtZXNzYWdlU2VudDogbXNnU250TWFyaW8sXHJcbiAgICBtZXNzYWdlVGV4dDogbXNnVHh0TWFyaW8sXHJcbiAgICBzZW5kTWVzc2FnZTogc2VuZE1zZ01hcmlvLFxyXG4gICAgZXJyb3JzOiBlcnJNYXJpbyxcclxuICAgIGNvbm5lY3RlZDogY250TWFyaW8sXHJcbiAgICBoYW5kbGVNZXNzYWdlQ2hhbmdlOiBoZGxlTWVzc2FnZUNoYWdlTWFyaW8sXHJcbiAgICBzb2NrZXQ6IG1hcmlvU29ja2V0XHJcbiAgfSA9IHVzZVNvY2tldENsaWVudCh7XHJcbiAgICBuYW1lOiBcIm1hcmlvXCIsXHJcbiAgICB0YXJnZXROYW1lOiBcImRyYWdvc1wiLFxyXG4gICAgc2VydmVyVXJsOlJFQUNUX0FQUF9TT0NLRVRfVVJMLFxyXG4gICAgcm91dGU6Jy9hbm9ueW1vdXMnXHJcbiAgXHJcbiAgfSk7XHJcbiAgY29uc3Qge1xyXG4gICAgbWVzc2FnZXM6IG1zZ0RyYWdvcyxcclxuICAgIG1lc3NhZ2VSZWNpZXZlZDogbXNnUmVjRHJhZ29zLFxyXG4gICAgbWVzc2FnZVNlbnQ6IG1zZ1NudERyYWdvcyxcclxuICAgIG1lc3NhZ2VUZXh0OiBtc2dUeHREcmFnb3MsXHJcbiAgICBzZW5kTWVzc2FnZTogc2VuZE1zZ0RyYWdvcyxcclxuICAgIGVycm9yczogZXJyRHJhZ29zLFxyXG4gICAgY29ubmVjdGVkOiBjbnREcmFnb3MsXHJcbiAgICBoYW5kbGVNZXNzYWdlQ2hhbmdlOiBoZGxlTWVzc2FnZUNoYWdlRHJhZ29zLFxyXG4gICAgc29ja2V0OiBkcmFnb3NTb2NrZXRcclxuICB9ID0gdXNlU29ja2V0Q2xpZW50KHtcclxuICAgIG5hbWU6IFwiZHJhZ29zXCIsXHJcbiAgICB0YXJnZXROYW1lOiBcIm1hcmlvXCIsXHJcbiAgICBzZXJ2ZXJVcmw6UkVBQ1RfQVBQX1NPQ0tFVF9VUkwsXHJcbiAgICByb3V0ZTonL2Fub255bW91cydcclxuICB9KTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmKG1zZ0ZvckRyYWdvcyAhPT1udWxsKVxyXG4gICAgc2V0TXNnRm9yRHJhZ29zKHByZXZTdGF0ZSA9PiBwcmV2U3RhdGUgKyAxKTtcclxuICB9LCBbbXNnUmVjRHJhZ29zXSk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmKG1zZ0Zvck1hcmlvICE9PW51bGwpXHJcbiAgICBzZXRNc2dGb3JNYXJpbyhwcmV2U3RhdGUgPT4gcHJldlN0YXRlICsgMSk7XHJcbiAgfSwgW21zZ1JlY01hcmlvXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc2VsZWN0ZWRJdGVtID09PSAwKSB7XHJcbiAgICAgIHNldE1zZ0Zvck1hcmlvKDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0TXNnRm9yRHJhZ29zKDApO1xyXG4gICAgfVxyXG4gIH0sIFtzZWxlY3RlZEl0ZW1dKTtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfX0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFiLWJhclwiPlxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgIDxUYWJCYXI+XHJcbiAgICAgICAgPFRhYkJhci5UYWIgYWN0aXZlIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkSXRlbSgwKX0+XHJcbiAgICAgICAgICA8VGFiQmFyLlRhYkxhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwifX0+XHJcbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBjb2xvcjogY250TWFyaW8gPyBcImdyZWVuXCIgOiBcIm9yYW5nZVwifX0+bWFyaW88L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjaGlwXCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbXNnRm9yTWFyaW8gPiAwID8gXCJncmVlblwiIDogXCJkYXJrZ3JleVwiXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHttc2dGb3JNYXJpb31cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L1RhYkJhci5UYWJMYWJlbD5cclxuICAgICAgICA8L1RhYkJhci5UYWI+XHJcbiAgICAgICAgPFRhYkJhci5UYWIgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRJdGVtKDEpfT5cclxuICAgICAgICAgIDxUYWJCYXIuVGFiTGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIgfX0+XHJcbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBjb2xvcjogY250RHJhZ29zID8gXCJncmVlblwiIDogXCJvcmFuZ2VcIiB9fT5cclxuICAgICAgICAgICAgICAgIGRyYWdvc1xyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNoaXBcIlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtc2dGb3JEcmFnb3MgPiAwID8gXCJncmVlblwiIDogXCJkYXJrZ3JleVwiXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHttc2dGb3JEcmFnb3N9XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9UYWJCYXIuVGFiTGFiZWw+XHJcbiAgICAgICAgPC9UYWJCYXIuVGFiPlxyXG4gICAgICA8L1RhYkJhcj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICB7c2VsZWN0ZWRJdGVtID09PSAwICYmIChcclxuICAgICAgICA8Q2hhdFVzZXJcclxuICAgICAgICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U9e2hkbGVNZXNzYWdlQ2hhZ2VNYXJpb31cclxuICAgICAgICAgIGNvbm5lY3RlZD17Y250TWFyaW99XHJcbiAgICAgICAgICBlcnJvcnM9e2Vyck1hcmlvfVxyXG4gICAgICAgICAgbWVzc2FnZVNlbnQ9e21zZ1NudE1hcmlvfVxyXG4gICAgICAgICAgbWVzc2FnZVRleHQ9e21zZ1R4dE1hcmlvfVxyXG4gICAgICAgICAgbWVzc2FnZXM9e21zZ01hcmlvfVxyXG4gICAgICAgICAgc2VuZE1lc3NhZ2U9e3NlbmRNc2dNYXJpb31cclxuICAgICAgICAgIG1lc3NhZ2VSZWNpZXZlZD17bXNnUmVjTWFyaW99XHJcbiAgICAgICAgICBzb2NrZXQ9e2RyYWdvc1NvY2tldH1cclxuICAgICAgICAgIG5hbWU9XCJtYXJpb1wiXHJcbiAgICAgICAgICB0YXJnZXROYW1lPVwiZHJhZ29zXCJcclxuICAgICAgICAvPlxyXG4gICAgICApfVxyXG4gICAgICB7c2VsZWN0ZWRJdGVtID09PSAxICYmIChcclxuICAgICAgICA8Q2hhdFVzZXJcclxuICAgICAgICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U9e2hkbGVNZXNzYWdlQ2hhZ2VEcmFnb3N9XHJcbiAgICAgICAgICBjb25uZWN0ZWQ9e2NudERyYWdvc31cclxuICAgICAgICAgIGVycm9ycz17ZXJyRHJhZ29zfVxyXG4gICAgICAgICAgbWVzc2FnZVNlbnQ9e21zZ1NudERyYWdvc31cclxuICAgICAgICAgIG1lc3NhZ2VUZXh0PXttc2dUeHREcmFnb3N9XHJcbiAgICAgICAgICBtZXNzYWdlcz17bXNnRHJhZ29zfVxyXG4gICAgICAgICAgc2VuZE1lc3NhZ2U9e3NlbmRNc2dEcmFnb3N9XHJcbiAgICAgICAgICBtZXNzYWdlUmVjaWV2ZWQ9e21zZ1JlY0RyYWdvc31cclxuICAgICAgICAgIHNvY2tldD17ZHJhZ29zU29ja2V0fVxyXG4gICAgICAgICAgbmFtZT1cImRyYWdvc1wiXHJcbiAgICAgICAgICB0YXJnZXROYW1lPVwibWFyaW9cIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICl9XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBDaGF0Um9vbTtcclxuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCBDaGF0Um9vbSBmcm9tICcuL0NoYXRSb29tJ1xyXG5cclxuY29uc3QgU29ja2V0SU9NZXNzYWdpbmcgPSgpPT57XHJcblxyXG4gICAgcmV0dXJuKFxyXG4gICAgICA8Q2hhdFJvb20gLz5cclxuICAgIClcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNvY2tldElPTWVzc2FnaW5nIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcblxyXG5jb25zdCBXZWJSVENNZXNzYWdpbmcgPSgpPT57XHJcblxyXG4gICAgcmV0dXJuKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW5Ub3A6MjAwfX0+V2ViUlRDIE1lc3NhZ2luZzwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViUlRDTWVzc2FnaW5nIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcblxyXG5jb25zdCBXZWJSVENWaWRlb0NoYXQgPSgpPT57XHJcblxyXG4gICAgcmV0dXJuKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW5Ub3A6MjAwfX0+XHJcbiAgICAgICAgICAgIFdlYlJUQ1ZpZGVvQ2hhdFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJSVENWaWRlb0NoYXQiXSwibmFtZXMiOlsiTURDRm91bmRhdGlvbiIsImNzc0NsYXNzZXMiLCJzdHJpbmdzIiwibnVtYmVycyIsImRlZmF1bHRBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJhZGFwdGVyIiwiYWRhcHRlcl8iLCJpbml0IiwiZGVzdHJveSIsIk1EQ0NvbXBvbmVudCIsImF0dGFjaFRvIiwicm9vdCIsImZvdW5kYXRpb24iLCJ1bmRlZmluZWQiLCJhcmdzIiwicm9vdF8iLCJpbml0aWFsaXplIiwiZm91bmRhdGlvbl8iLCJnZXREZWZhdWx0Rm91bmRhdGlvbiIsImluaXRpYWxTeW5jV2l0aERPTSIsIkVycm9yIiwibGlzdGVuIiwiZXZ0VHlwZSIsImhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwidW5saXN0ZW4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZW1pdCIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJldnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkFDVElWRSIsIkZBREUiLCJOT19UUkFOU0lUSU9OIiwiQ09OVEVOVF9TRUxFQ1RPUiIsIk1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24iLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0Iiwic2V0Q29udGVudFN0eWxlUHJvcGVydHkiLCJPYmplY3QiLCJhc3NpZ24iLCJhY3RpdmF0ZSIsInByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCIsImRlYWN0aXZhdGUiLCJNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiIsImN1cnJlbnRDbGllbnRSZWN0Iiwid2lkdGhEZWx0YSIsIndpZHRoIiwieFBvc2l0aW9uIiwibGVmdCIsIk1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24iLCJNRENUYWJJbmRpY2F0b3IiLCJjb250ZW50XyIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwcm9wIiwidmFsdWUiLCJzdHlsZSIsInNldFByb3BlcnR5IiwiY29udGFpbnMiLCJBUklBX1NFTEVDVEVEIiwiUklQUExFX1NFTEVDVE9SIiwiVEFCX0lORElDQVRPUl9TRUxFQ1RPUiIsIlRBQklOREVYIiwiSU5URVJBQ1RFRF9FVkVOVCIsIk1EQ1RhYkZvdW5kYXRpb24iLCJoYXNDbGFzcyIsInNldEF0dHIiLCJhY3RpdmF0ZUluZGljYXRvciIsImRlYWN0aXZhdGVJbmRpY2F0b3IiLCJub3RpZnlJbnRlcmFjdGVkIiwiZ2V0T2Zmc2V0TGVmdCIsImdldE9mZnNldFdpZHRoIiwiZ2V0Q29udGVudE9mZnNldExlZnQiLCJnZXRDb250ZW50T2Zmc2V0V2lkdGgiLCJmb2N1cyIsImhhbmRsZUNsaWNrXyIsImhhbmRsZUNsaWNrIiwiaXNBY3RpdmUiLCJjb21wdXRlRGltZW5zaW9ucyIsInJvb3RXaWR0aCIsInJvb3RMZWZ0IiwiY29udGVudFdpZHRoIiwiY29udGVudExlZnQiLCJyb290UmlnaHQiLCJjb250ZW50UmlnaHQiLCJNRENUYWIiLCJyaXBwbGVfIiwidGFiSW5kaWNhdG9yXyIsInJpcHBsZUZhY3RvcnkiLCJlbCIsIk1EQ1JpcHBsZSIsInRhYkluZGljYXRvckZhY3RvcnkiLCJyaXBwbGVTdXJmYWNlIiwicmlwcGxlQWRhcHRlciIsImNyZWF0ZUFkYXB0ZXIiLCJ1cGRhdGVDc3NWYXJpYWJsZSIsInZhck5hbWUiLCJyaXBwbGVGb3VuZGF0aW9uIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsInRhYkluZGljYXRvckVsZW1lbnQiLCJiaW5kIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsInRhYiIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsImFjdGl2ZSIsImNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0IiwiQU5JTUFUSU5HIiwiU0NST0xMX1RFU1QiLCJTQ1JPTExfQVJFQV9TQ1JPTEwiLCJBUkVBX1NFTEVDVE9SIiwiTURDVGFiU2Nyb2xsZXJSVEwiLCJnZXRTY3JvbGxQb3NpdGlvblJUTCIsInRyYW5zbGF0ZVgiLCJzY3JvbGxUb1JUTCIsInNjcm9sbFgiLCJpbmNyZW1lbnRTY3JvbGxSVEwiLCJnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbiIsIk1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCIsImN1cnJlbnRTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQiLCJyaWdodCIsImNhbGN1bGF0ZVNjcm9sbEVkZ2VzXyIsIk1hdGgiLCJyb3VuZCIsImVkZ2VzIiwiY2xhbXBlZFNjcm9sbExlZnQiLCJjbGFtcFNjcm9sbFZhbHVlXyIsImZpbmFsU2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxEZWx0YSIsImdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCIsImdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCIsIm1pbiIsIm1heCIsIk1EQ1RhYlNjcm9sbGVyUlRMTmVnYXRpdmUiLCJNRENUYWJTY3JvbGxlclJUTFJldmVyc2UiLCJNRENUYWJTY3JvbGxlckZvdW5kYXRpb24iLCJldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvciIsImFkZFNjcm9sbEFyZWFDbGFzcyIsInNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5Iiwic2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHkiLCJnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZSIsInNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0IiwiY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0IiwiY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0IiwiY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQiLCJpc0FuaW1hdGluZ18iLCJydGxTY3JvbGxlckluc3RhbmNlXyIsImhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImlzUlRMXyIsImNvbXB1dGVDdXJyZW50U2Nyb2xsUG9zaXRpb25SVExfIiwiY3VycmVudFRyYW5zbGF0ZVgiLCJjYWxjdWxhdGVDdXJyZW50VHJhbnNsYXRlWF8iLCJzY3JvbGxMZWZ0IiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJzdG9wU2Nyb2xsQW5pbWF0aW9uXyIsImhhbmRsZVRyYW5zaXRpb25FbmQiLCJ0YXJnZXQiLCJpbmNyZW1lbnRTY3JvbGwiLCJzY3JvbGxYSW5jcmVtZW50IiwiaW5jcmVtZW50U2Nyb2xsUlRMXyIsImluY3JlbWVudFNjcm9sbF8iLCJzY3JvbGxUbyIsInNjcm9sbFRvUlRMXyIsInNjcm9sbFRvXyIsImdldFJUTFNjcm9sbGVyIiwicnRsU2Nyb2xsZXJGYWN0b3J5XyIsInRyYW5zZm9ybVZhbHVlIiwicmVzdWx0cyIsImV4ZWMiLCJwYXJ0cyIsInNwbGl0IiwicGFyc2VGbG9hdCIsImN1cnJlbnRTY3JvbGxYIiwic2FmZVNjcm9sbFgiLCJhbmltYXRlXyIsImFuaW1hdGlvbiIsInRhcmdldFNjcm9sbFgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjdXJyZW50U2Nyb2xsUG9zaXRpb24iLCJnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8iLCJpbml0aWFsU2Nyb2xsTGVmdCIsIm5ld1Njcm9sbExlZnQiLCJyb290Q2xpZW50UmVjdCIsImNvbnRlbnRDbGllbnRSZWN0IiwicmlnaHRFZGdlRGVsdGEiLCJob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XyIsImRvY3VtZW50T2JqIiwic2hvdWxkQ2FjaGVSZXN1bHQiLCJjcmVhdGVFbGVtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwib2Zmc2V0SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwicmVtb3ZlQ2hpbGQiLCJnZXRNYXRjaGVzUHJvcGVydHkiLCJIVE1MRWxlbWVudFByb3RvdHlwZSIsImZpbHRlciIsInAiLCJwb3AiLCJNRENUYWJTY3JvbGxlciIsImFyZWFfIiwiaGFuZGxlSW50ZXJhY3Rpb25fIiwiaGFuZGxlVHJhbnNpdGlvbkVuZF8iLCJldnRUYXJnZXQiLCJzZWxlY3RvciIsIk1BVENIRVMiLCJ1dGlsIiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJwcm9wTmFtZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0U2Nyb2xsQ29udGVudFdpZHRoIiwiVEFCX0FDVElWQVRFRF9FVkVOVCIsIlRBQl9TQ1JPTExFUl9TRUxFQ1RPUiIsIlRBQl9TRUxFQ1RPUiIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiRU5EX0tFWSIsIkhPTUVfS0VZIiwiRU5URVJfS0VZIiwiU1BBQ0VfS0VZIiwiRVhUUkFfU0NST0xMX0FNT1VOVCIsIkFSUk9XX0xFRlRfS0VZQ09ERSIsIkFSUk9XX1JJR0hUX0tFWUNPREUiLCJFTkRfS0VZQ09ERSIsIkhPTUVfS0VZQ09ERSIsIkVOVEVSX0tFWUNPREUiLCJTUEFDRV9LRVlDT0RFIiwiQUNDRVBUQUJMRV9LRVlTIiwiU2V0IiwiS0VZQ09ERV9NQVAiLCJNYXAiLCJzZXQiLCJNRENUYWJCYXJGb3VuZGF0aW9uIiwiaXNSVEwiLCJzZXRBY3RpdmVUYWIiLCJhY3RpdmF0ZVRhYkF0SW5kZXgiLCJkZWFjdGl2YXRlVGFiQXRJbmRleCIsImZvY3VzVGFiQXRJbmRleCIsImdldFRhYkluZGljYXRvckNsaWVudFJlY3RBdEluZGV4IiwiZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgiLCJnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4IiwiZ2V0Rm9jdXNlZFRhYkluZGV4IiwiZ2V0SW5kZXhPZlRhYiIsImdldFRhYkxpc3RMZW5ndGgiLCJub3RpZnlUYWJBY3RpdmF0ZWQiLCJ1c2VBdXRvbWF0aWNBY3RpdmF0aW9uXyIsInNldFVzZUF1dG9tYXRpY0FjdGl2YXRpb24iLCJ1c2VBdXRvbWF0aWNBY3RpdmF0aW9uIiwiYWN0aXZhdGVUYWIiLCJpbmRleCIsInByZXZpb3VzQWN0aXZlSW5kZXgiLCJpbmRleElzSW5SYW5nZV8iLCJzY3JvbGxJbnRvVmlldyIsImhhbmRsZUtleURvd24iLCJrZXkiLCJnZXRLZXlGcm9tRXZlbnRfIiwiaXNBY3RpdmF0aW9uS2V5XyIsInByZXZlbnREZWZhdWx0IiwiZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8iLCJmb2N1c2VkVGFiSW5kZXgiLCJoYW5kbGVUYWJJbnRlcmFjdGlvbiIsInNjcm9sbEludG9WaWV3UlRMXyIsInNjcm9sbEludG9WaWV3XyIsIm9yaWdpbiIsIm1heEluZGV4Iiwic2hvdWxkR29Ub0VuZCIsInNob3VsZERlY3JlbWVudCIsInNob3VsZEluY3JlbWVudCIsImNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudF8iLCJuZXh0SW5kZXgiLCJzY3JvbGxQb3NpdGlvbiIsImJhcldpZHRoIiwibmV4dFRhYkRpbWVuc2lvbnMiLCJyZWxhdGl2ZUNvbnRlbnRMZWZ0IiwicmVsYXRpdmVDb250ZW50UmlnaHQiLCJsZWZ0SW5jcmVtZW50IiwicmlnaHRJbmNyZW1lbnQiLCJjYWxjdWxhdGVTY3JvbGxJbmNyZW1lbnRSVExfIiwic2Nyb2xsQ29udGVudFdpZHRoIiwiZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlXyIsInRhYkRpbWVuc2lvbnMiLCJyZWxhdGl2ZVJvb3RMZWZ0IiwicmVsYXRpdmVSb290UmlnaHQiLCJyZWxhdGl2ZVJvb3REZWx0YSIsImxlZnRFZGdlSXNDbG9zZXIiLCJyaWdodEVkZ2VJc0Nsb3NlciIsImZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZVJUTF8iLCJyb290RGVsdGEiLCJoYXMiLCJnZXQiLCJrZXlDb2RlIiwic2Nyb2xsSW5jcmVtZW50Iiwic2Nyb2xsV2lkdGgiLCJNRENUYWJCYXIiLCJ0YWJMaXN0XyIsInRhYkZhY3RvcnlfIiwidGFiU2Nyb2xsZXJfIiwidGFiU2Nyb2xsZXJGYWN0b3J5XyIsImhhbmRsZVRhYkludGVyYWN0aW9uXyIsImhhbmRsZUtleURvd25fIiwidGFiRmFjdG9yeSIsInRhYlNjcm9sbGVyRmFjdG9yeSIsImdldFRhYkVsZW1lbnRzXyIsIm1hcCIsInRhYlNjcm9sbGVyRWxlbWVudCIsImkiLCJsZW5ndGgiLCJmb3JFYWNoIiwiY2xpZW50UmVjdCIsInRhYkVsZW1lbnRzIiwiYWN0aXZlRWxlbWVudCIsImluZGV4T2YiLCJ0YWJUb0ZpbmQiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiVGFiIiwibWRjTm90aWZ5UHJvcHMiLCJjbGFzcyIsIkRhdGVMaW5lYnJlYWsiLCJkYXRldGltZSIsImRpc3BsYXkiLCJmbGV4IiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiTWVzc2FnZUFsaWduZXIiLCJjaGlsZHJlbiIsInNpZGUiLCJhbGlnbm1lbnQiLCJqdXN0aWZ5Q29udGVudCIsIk1lc3NhZ2VWaWV3IiwibWVzc2FnZSIsImJhY2tncm91bmRDb2xvciIsInBhZGRpbmciLCJtYXJnaW4iLCJib3JkZXJSYWRpdXMiLCJib3JkZXJDb2xvciIsImJvcmRlclN0eWxlIiwiYm9yZGVyV2lkdGgiLCJtYXhXaWR0aCIsIndvcmRXcmFwIiwid29yZEJyZWFrIiwibWluV2lkdGgiLCJmb250U2l6ZSIsInBhZGRpbmdUb3AiLCJ0ZXh0QWxpZ24iLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJTdWJzZXF1ZW50TWVzc2FnZSIsImFsaWduSXRlbXMiLCJtYXJnaW5MZWZ0IiwiTWVzc2FnZSIsImhlaWdodCIsImNvbG9yIiwiTWVzc2FnZUF2YXRhciIsImxldHRlciIsInRvVXBwZXJDYXNlIiwiRmlyc3RNZXNzYWdlIiwibG9jYWwiLCJNZXNzYWdlT2JqZWN0TWFwcHRlciIsInByb3BzIiwib3JkZXIiLCJkYXRlU3BhY2UiLCJ1c2VNZXNzYWdlU29ydGVyIiwibWVzc2FnZXMiLCJ1c2VTdGF0ZSIsInNvcnRlZE1lc3NhZ2VzIiwic2V0U29ydGVkTWVzc2FnZXMiLCJ1c2VFZmZlY3QiLCJzb3J0IiwiYSIsImIiLCJ1c2VNZXNzYWdlc01hcHBlciIsIm1hcHBlZE1lc3NhZ2VzIiwic2V0TWFwcGVkTWVzc2FnZXMiLCJtYXBNZXNzYWdlcyIsImxvY2FsU2lkZSIsInJlbW90ZVNpZGUiLCJlbWFpbCIsImZyb20iLCJsYXN0RGF0ZXRpbWUiLCJtIiwiZ2V0RGF0ZSIsIl9leHRlbmRzIiwibW9kdWxlIiwiYXJndW1lbnRzIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJhcHBseSIsIk1lc3NhZ2VDb2xsZWN0aW9uVmlldyIsIk1lc3NhZ2VPYmplY3RNYXBwZXIiLCJNZXNzYWdlVmlld1Njcm9sbGVyIiwidHJhbnNmb3JtIiwib3ZlcmZsb3ciLCJNZXNzYWdlRWRpdG9yRGlzcGxheWVyIiwib25NZXNzYWdlQ2hhbmdlIiwic2VuZE1lc3NhZ2UiLCJpZCIsImRpc2FibGVkIiwiTWVzc2FnZXNEaXNwbGF5ZXIiLCJzb2NrZXQiLCJtZXNzYWdlVGV4dCIsImhhbmRsZU1lc3NhZ2VDaGFuZ2UiLCJ1c2VNZXNzYWdlTWFwcGVyIiwiQ2hhdFVzZXIiLCJuYW1lIiwidGFyZ2V0TmFtZSIsImVycm9ycyIsIk1lc3NhZ2VEaXNwbGF5ZXIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJhcnIyIiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInRvU3RyaW5nIiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsInVzZVNvY2tldE1lc3NhZ2luZyIsInNldE1lc3NhZ2VUZXh0IiwibWVzc2FnZVJlY2lldmVkIiwic2V0TWVzc2FnZVJlY2lldmVkIiwibWVzc2FnZVNlbnQiLCJzZXRNZXNzYWdlU2VudCIsImNvbm5lY3RlZCIsInNldENvbm5lY3RlZCIsInNldEVycm9yIiwiZ2V0VGltZSIsInJlY2lldmVyIiwiZSIsIm9uIiwiZGF0YSIsInNlbmRlciIsImVycm9yIiwidXNlQ2hhdExvZyIsInNldE1lc3NhZ2VzIiwic2F2ZVRvTG9jYWxTdG9yYWdlIiwicGVyc2lzdGVkTWVzc2FnZXMiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInRvIiwicmUiLCJwYXJzZXVyaSIsInN0ciIsInNyYyIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJ1cmkiLCJob3N0IiwiYXV0aG9yaXR5IiwiaXB2NnVyaSIsInMiLCJoIiwiZCIsInciLCJ5IiwidmFsIiwib3B0aW9ucyIsInR5cGUiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsIm4iLCJ0b0xvd2VyQ2FzZSIsIm1zIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSQkMCIsImtleXMiLCJpbnN0YW5jZXMiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJwcmV2VGltZSIsInNlbGYiLCJjdXJyIiwiTnVtYmVyIiwiZGlmZiIsInByZXYiLCJ1bnNoaWZ0IiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwidXNlQ29sb3JzIiwiZXh0ZW5kIiwicHVzaCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwibmFtZXNwYWNlcyIsInNhdmUiLCJsZW4iLCJSZWdFeHAiLCJzdWJzdHIiLCJpbnN0YW5jZSIsInRvTmFtZXNwYWNlIiwiam9pbiIsInRlc3QiLCJyZWdleHAiLCJzdGFjayIsImxvYWQiLCJleHBvcnRzIiwibG9jYWxzdG9yYWdlIiwicHJvY2VzcyIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRvY3VtZW50RWxlbWVudCIsIldlYmtpdEFwcGVhcmFuY2UiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCIkMSIsImMiLCJsYXN0QyIsInN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiciIsIkRFQlVHIiwiaiIsInYiLCJ1cmwiLCJsb2MiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiY2hhckF0IiwicG9ydCIsInBhdGgiLCJpcHY2IiwiaHJlZiIsImlzTmFOIiwiZmxvb3IiLCJjZWlsIiwiY2hyb21lIiwiZXJyIiwiRnVuY3Rpb24iLCJFbWl0dGVyIiwibWl4aW4iLCJldmVudCIsImZuIiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImNhbGxiYWNrcyIsImNiIiwibGlzdGVuZXJzIiwiaGFzTGlzdGVuZXJzIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImluaXRlZCIsImNvZGUiLCJ0b0J5dGVBcnJheSIsImI2NCIsImwiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0IiwiZnJvbUJ5dGVBcnJheSIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJyZWFkIiwiYnVmZmVyIiwib2Zmc2V0IiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJJbmZpbml0eSIsInBvdyIsIndyaXRlIiwicnQiLCJMTjIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIkJ1ZmZlciIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJrTWF4TGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJfX3Byb3RvX18iLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImJ5dGVMZW5ndGgiLCJhY3R1YWwiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJieXRlT2Zmc2V0IiwiaW50ZXJuYWxJc0J1ZmZlciIsImNvcHkiLCJpc25hbiIsImlzQnVmZmVyIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIngiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsInRvSlNPTiIsIl9hcnIiLCJiYXNlNjQiLCJyZXMiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwiZnJvbUNoYXJDb2RlIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInN1YmFycmF5Iiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJpZWVlNzU0IiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsImRzdCIsImlzRmFzdEJ1ZmZlciIsImlzU2xvd0J1ZmZlciIsImlzQnVmIiwid2l0aE5hdGl2ZUJ1ZmZlciIsIndpdGhOYXRpdmVBcnJheUJ1ZmZlciIsIndpdGhOYXRpdmVCbG9iIiwiQmxvYiIsIndpdGhOYXRpdmVGaWxlIiwiRmlsZSIsInBhY2tldCIsImJ1ZmZlcnMiLCJwYWNrZXREYXRhIiwicGFjayIsIl9kZWNvbnN0cnVjdFBhY2tldCIsImF0dGFjaG1lbnRzIiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJuZXdEYXRhIiwiX3JlY29uc3RydWN0UGFja2V0IiwiY2FsbGJhY2siLCJfcmVtb3ZlQmxvYnMiLCJjdXJLZXkiLCJjb250YWluaW5nT2JqZWN0IiwicGVuZGluZ0Jsb2JzIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJibG9ibGVzc0RhdGEiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIkVuY29kZXIiLCJEZWNvZGVyIiwiRVJST1JfUEFDS0VUIiwiRVJST1IiLCJlbmNvZGUiLCJCSU5BUllfRVZFTlQiLCJCSU5BUllfQUNLIiwiZW5jb2RlQXNCaW5hcnkiLCJlbmNvZGVBc1N0cmluZyIsIm5zcCIsInBheWxvYWQiLCJ0cnlTdHJpbmdpZnkiLCJ3cml0ZUVuY29kaW5nIiwiZGVjb25zdHJ1Y3Rpb24iLCJiaW5hcnkiLCJkZWNvbnN0cnVjdFBhY2tldCIsInJlbW92ZUJsb2JzIiwicmVjb25zdHJ1Y3RvciIsImRlY29kZVN0cmluZyIsIkJpbmFyeVJlY29uc3RydWN0b3IiLCJyZWNvblBhY2siLCJ0YWtlQmluYXJ5RGF0YSIsInR5cGVzIiwibmV4dCIsInRyeVBhcnNlIiwiaXNQYXlsb2FkVmFsaWQiLCJmaW5pc2hlZFJlY29uc3RydWN0aW9uIiwiYmluRGF0YSIsInJlY29uc3RydWN0UGFja2V0IiwibXNnIiwiWE1MSHR0cFJlcXVlc3QiLCJvcHRzIiwieGRvbWFpbiIsInhzY2hlbWUiLCJlbmFibGVzWERSIiwiaGFzQ09SUyIsIlhEb21haW5SZXF1ZXN0IiwiaGFzQmluYXJ5IiwiYXJyYXlidWZmZXIiLCJhYnYiLCJpaSIsImFmdGVyIiwiY291bnQiLCJlcnJfY2IiLCJiYWlsIiwibm9vcCIsInByb3h5Iiwic3RyaW5nRnJvbUNoYXJDb2RlIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJjaGVja1NjYWxhclZhbHVlIiwic3RyaWN0IiwiY3JlYXRlQnl0ZSIsInNoaWZ0IiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwidXRmOGVuY29kZSIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInV0ZjhkZWNvZGUiLCJ2ZXJzaW9uIiwiZGVjb2RlIiwiY2hhcnMiLCJidWZmZXJMZW5ndGgiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJibG9iU3VwcG9ydGVkIiwiYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3IiwiYmxvYkJ1aWxkZXJTdXBwb3J0ZWQiLCJhcHBlbmQiLCJnZXRCbG9iIiwibWFwQXJyYXlCdWZmZXJWaWV3cyIsImFyeSIsImNodW5rIiwiQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvciIsImJiIiwicGFydCIsIkJsb2JDb25zdHJ1Y3RvciIsImJhc2U2NGVuY29kZXIiLCJpc0FuZHJvaWQiLCJpc1BoYW50b21KUyIsImRvbnRTZW5kQmxvYnMiLCJwYWNrZXRzIiwib3BlbiIsImNsb3NlIiwicGluZyIsInBvbmciLCJ1cGdyYWRlIiwicGFja2V0c2xpc3QiLCJzdXBwb3J0c0JpbmFyeSIsImVuY29kZUFycmF5QnVmZmVyIiwiZW5jb2RlQmxvYiIsImVuY29kZUJhc2U2NE9iamVjdCIsImVuY29kZWQiLCJ1dGY4IiwiZW5jb2RlQmFzZTY0UGFja2V0IiwiY29udGVudEFycmF5IiwicmVzdWx0QnVmZmVyIiwiZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIiLCJmciIsImVuY29kZVBhY2tldCIsImJsb2IiLCJyZWFkQXNEYXRhVVJMIiwiYjY0ZGF0YSIsInR5cGVkIiwiYmFzaWMiLCJidG9hIiwiYmluYXJ5VHlwZSIsImRlY29kZUJhc2U2NFBhY2tldCIsInRyeURlY29kZSIsImFzQXJyYXkiLCJyZXN0Iiwic2xpY2VCdWZmZXIiLCJpc0JpbmFyeSIsImVuY29kZVBheWxvYWRBc0Jsb2IiLCJlbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciIsInNldExlbmd0aEhlYWRlciIsImVuY29kZU9uZSIsImRvbmVDYWxsYmFjayIsImVhY2giLCJkb25lIiwiZWFjaFdpdGhJbmRleCIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsImNociIsImRlY29kZVBhY2tldCIsImVuY29kZWRQYWNrZXRzIiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHRBcnJheSIsImJ1ZmZlckluZGV4IiwiaXNTdHJpbmciLCJhYiIsInZpZXciLCJsZW5TdHIiLCJiaW5hcnlJZGVudGlmaWVyIiwibGVuZ3RoQXJ5IiwiYnVmZmVyVGFpbCIsInRhaWxBcnJheSIsIm1zZ0xlbmd0aCIsInRvdGFsIiwiVHJhbnNwb3J0IiwiaG9zdG5hbWUiLCJzZWN1cmUiLCJxdWVyeSIsInRpbWVzdGFtcFBhcmFtIiwidGltZXN0YW1wUmVxdWVzdHMiLCJyZWFkeVN0YXRlIiwiYWdlbnQiLCJ3aXRoQ3JlZGVudGlhbHMiLCJwZngiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImZvcmNlTm9kZSIsImlzUmVhY3ROYXRpdmUiLCJleHRyYUhlYWRlcnMiLCJsb2NhbEFkZHJlc3MiLCJvbkVycm9yIiwiZGVzYyIsImRlc2NyaXB0aW9uIiwiZG9PcGVuIiwiZG9DbG9zZSIsIm9uQ2xvc2UiLCJzZW5kIiwib25PcGVuIiwib25EYXRhIiwicGFyc2VyIiwib25QYWNrZXQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxcyIsInFyeSIsInBhaXJzIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImFscGhhYmV0Iiwic2VlZCIsImRlY29kZWQiLCJ5ZWFzdCIsIm5vdyIsIlBvbGxpbmciLCJoYXNYSFIyIiwicmVxdWlyZSQkMSIsInhociIsInJlc3BvbnNlVHlwZSIsImZvcmNlQmFzZTY0IiwiaW5oZXJpdCIsInBvbGwiLCJwYXVzZSIsIm9uUGF1c2UiLCJwb2xsaW5nIiwiZG9Qb2xsIiwiZGVjb2RlUGF5bG9hZCIsImNhbGxiYWNrZm4iLCJlbmNvZGVQYXlsb2FkIiwiZG9Xcml0ZSIsInNjaGVtYSIsInNpZCIsInBhcnNlcXMiLCJYSFIiLCJSZXF1ZXN0IiwiZW1wdHkiLCJyZXF1ZXN0VGltZW91dCIsImlzU1NMIiwieGQiLCJ4cyIsInJlcXVlc3QiLCJyZXEiLCJtZXRob2QiLCJzZW5kWGhyIiwicG9sbFhociIsImFzeW5jIiwiY3JlYXRlIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsInRpbWVvdXQiLCJoYXNYRFIiLCJvbkxvYWQiLCJvbmVycm9yIiwicmVzcG9uc2VUZXh0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiY29udGVudFR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsInN0YXR1cyIsInNldFRpbWVvdXQiLCJyZXF1ZXN0c0NvdW50IiwicmVxdWVzdHMiLCJvblN1Y2Nlc3MiLCJjbGVhbnVwIiwiZnJvbUVycm9yIiwiYWJvcnQiLCJyZXNwb25zZSIsImF0dGFjaEV2ZW50IiwidW5sb2FkSGFuZGxlciIsInRlcm1pbmF0aW9uRXZlbnQiLCJKU09OUFBvbGxpbmciLCJyTmV3bGluZSIsInJFc2NhcGVkTmV3bGluZSIsImdsb2IiLCJfX19laW8iLCJzY3JpcHQiLCJwYXJlbnROb2RlIiwiZm9ybSIsImlmcmFtZSIsImluc2VydEF0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJoZWFkIiwiaXNVQWdlY2tvIiwiYXJlYSIsImlmcmFtZUlkIiwicG9zaXRpb24iLCJ0b3AiLCJhY3Rpb24iLCJjb21wbGV0ZSIsImluaXRJZnJhbWUiLCJodG1sIiwic3VibWl0IiwiQnJvd3NlcldlYlNvY2tldCIsIk5vZGVXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXRJbXBsIiwiV1MiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsInVzaW5nQnJvd3NlcldlYlNvY2tldCIsInByb3RvY29scyIsImNoZWNrIiwiaGVhZGVycyIsIndzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ub3BlbiIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJldiIsImNvbXByZXNzIiwidGhyZXNob2xkIiwid2Vic29ja2V0IiwianNvbnAiLCJmb3JjZUpTT05QIiwiSlNPTlAiLCJTb2NrZXQiLCJ0cmFuc3BvcnRzIiwidHJhbnNwb3J0T3B0aW9ucyIsIndyaXRlQnVmZmVyIiwicHJldkJ1ZmZlckxlbiIsInBvbGljeVBvcnQiLCJyZW1lbWJlclVwZ3JhZGUiLCJvbmx5QmluYXJ5VXBncmFkZXMiLCJwcm9kdWN0IiwidXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbFRpbWVyIiwicGluZ1RpbWVvdXRUaW1lciIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsImNyZWF0ZVRyYW5zcG9ydCIsImNsb25lIiwiRUlPIiwidHJhbnNwb3J0IiwibyIsInNldFRyYW5zcG9ydCIsIm9uRHJhaW4iLCJwcm9iZSIsImZhaWxlZCIsIm9uVHJhbnNwb3J0T3BlbiIsInVwZ3JhZGVMb3Nlc0JpbmFyeSIsInVwZ3JhZGluZyIsImZsdXNoIiwiZnJlZXplVHJhbnNwb3J0Iiwib25UcmFuc3BvcnRDbG9zZSIsIm9udXBncmFkZSIsIm9uSGFuZHNoYWtlIiwic2V0UGluZyIsImZpbHRlclVwZ3JhZGVzIiwib25IZWFydGJlYXQiLCJjbGVhclRpbWVvdXQiLCJzZW5kUGFja2V0Iiwid2FpdEZvclVwZ3JhZGUiLCJjbGVhbnVwQW5kQ2xvc2UiLCJyZWFzb24iLCJmaWx0ZXJlZFVwZ3JhZGVzIiwidG9BcnJheSIsImV2ZW50cyIsImNvbm5lY3QiLCJjb25uZWN0X2Vycm9yIiwiY29ubmVjdF90aW1lb3V0IiwiY29ubmVjdGluZyIsImRpc2Nvbm5lY3QiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfYXR0ZW1wdCIsInJlY29ubmVjdF9mYWlsZWQiLCJyZWNvbm5lY3RfZXJyb3IiLCJyZWNvbm5lY3RpbmciLCJpbyIsImpzb24iLCJpZHMiLCJhY2tzIiwicmVjZWl2ZUJ1ZmZlciIsInNlbmRCdWZmZXIiLCJkaXNjb25uZWN0ZWQiLCJmbGFncyIsImF1dG9Db25uZWN0Iiwic3ViRXZlbnRzIiwic3VicyIsImhhc0JpbiIsIkVWRU5UIiwiQ09OTkVDVCIsIm9ucGFja2V0Iiwic2FtZU5hbWVzcGFjZSIsInJvb3ROYW1lc3BhY2VFcnJvciIsIm9uY29ubmVjdCIsIm9uZXZlbnQiLCJBQ0siLCJvbmFjayIsIkRJU0NPTk5FQ1QiLCJvbmRpc2Nvbm5lY3QiLCJhY2siLCJzZW50IiwiZW1pdEJ1ZmZlcmVkIiwiQmFja29mZiIsImZhY3RvciIsImppdHRlciIsImF0dGVtcHRzIiwiZHVyYXRpb24iLCJyYW5kIiwicmFuZG9tIiwiZGV2aWF0aW9uIiwicmVzZXQiLCJzZXRNaW4iLCJzZXRNYXgiLCJzZXRKaXR0ZXIiLCJNYW5hZ2VyIiwibnNwcyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJhbmRvbWl6YXRpb25GYWN0b3IiLCJiYWNrb2ZmIiwibGFzdFBpbmciLCJwYWNrZXRCdWZmZXIiLCJfcGFyc2VyIiwiZW5jb2RlciIsImRlY29kZXIiLCJlbWl0QWxsIiwidXBkYXRlU29ja2V0SWRzIiwiZ2VuZXJhdGVJZCIsImVuZ2luZSIsIl9yZWNvbm5lY3Rpb24iLCJfcmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJfcmVjb25uZWN0aW9uRGVsYXkiLCJfcmFuZG9taXphdGlvbkZhY3RvciIsIl9yZWNvbm5lY3Rpb25EZWxheU1heCIsIl90aW1lb3V0IiwibWF5YmVSZWNvbm5lY3RPbk9wZW4iLCJlaW8iLCJza2lwUmVjb25uZWN0Iiwib3BlblN1YiIsImVycm9yU3ViIiwidGltZXIiLCJvbnBpbmciLCJvbnBvbmciLCJvbmRhdGEiLCJvbmRlY29kZWQiLCJvbkNvbm5lY3RpbmciLCJwcm9jZXNzUGFja2V0UXVldWUiLCJzdWJzTGVuZ3RoIiwiZGVsYXkiLCJvbnJlY29ubmVjdCIsImF0dGVtcHQiLCJjYWNoZSIsIm5ld0Nvbm5lY3Rpb24iLCJmb3JjZU5ldyIsIm11bHRpcGxleCIsInVzZVNvY2tldCIsInVzZXJuYW1lIiwicm91dGUiLCJzZXJ2ZXJVcmwiLCJzZXRTb2NrZXQiLCJzb2NrZXRFcnJvciIsInNldFNvY2tldEVycm9yIiwiZmV0Y2hUb2tlbiIsImZldGNoIiwidG9rZW4iLCJ1c2VTb2NrZXRDbGllbnQiLCJDaGF0Um9vbSIsIm1zZ0Zvck1hcmlvIiwic2V0TXNnRm9yTWFyaW8iLCJtc2dGb3JEcmFnb3MiLCJzZXRNc2dGb3JEcmFnb3MiLCJzZWxlY3RlZEl0ZW0iLCJzZXRTZWxlY3RlZEl0ZW0iLCJtc2dNYXJpbyIsIm1zZ1JlY01hcmlvIiwibXNnU250TWFyaW8iLCJtc2dUeHRNYXJpbyIsInNlbmRNc2dNYXJpbyIsImVyck1hcmlvIiwiY250TWFyaW8iLCJoZGxlTWVzc2FnZUNoYWdlTWFyaW8iLCJtYXJpb1NvY2tldCIsIm1zZ0RyYWdvcyIsIm1zZ1JlY0RyYWdvcyIsIm1zZ1NudERyYWdvcyIsIm1zZ1R4dERyYWdvcyIsInNlbmRNc2dEcmFnb3MiLCJlcnJEcmFnb3MiLCJjbnREcmFnb3MiLCJoZGxlTWVzc2FnZUNoYWdlRHJhZ29zIiwiZHJhZ29zU29ja2V0IiwicHJldlN0YXRlIiwiU29ja2V0SU9NZXNzYWdpbmciLCJXZWJSVENNZXNzYWdpbmciLCJtYXJnaW5Ub3AiLCJXZWJSVENWaWRlb0NoYXQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsTUFBTUEsYUFBTixDQUFvQjs7YUFFUEMsVUFBWCxHQUF3Qjs7O1dBR2YsRUFBUDs7Ozs7YUFJU0MsT0FBWCxHQUFxQjs7O1dBR1osRUFBUDs7Ozs7YUFJU0MsT0FBWCxHQUFxQjs7O1dBR1osRUFBUDs7Ozs7YUFJU0MsY0FBWCxHQUE0Qjs7OztXQUluQixFQUFQOzs7Ozs7O0VBTUZDLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHLEVBQVgsRUFBZTs7U0FFbkJDLFFBQUwsR0FBZ0JELE9BQWhCOzs7RUFHRkUsSUFBSSxHQUFHOzs7RUFJUEMsT0FBTyxHQUFHOzs7OztBQ3BFWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxBQUVBOzs7O0FBR0EsTUFBTUMsWUFBTixDQUFtQjs7Ozs7U0FLVkMsUUFBUCxDQUFnQkMsSUFBaEIsRUFBc0I7Ozs7O1dBS2IsSUFBSUYsWUFBSixDQUFpQkUsSUFBakIsRUFBdUIsSUFBSVosYUFBSixFQUF2QixDQUFQOzs7Ozs7Ozs7RUFRRkssV0FBVyxDQUFDTyxJQUFELEVBQU9DLFVBQVUsR0FBR0MsU0FBcEIsRUFBK0IsR0FBR0MsSUFBbEMsRUFBd0M7O1NBRTVDQyxLQUFMLEdBQWFKLElBQWI7U0FDS0ssVUFBTCxDQUFnQixHQUFHRixJQUFuQixFQUhpRDs7Ozs7U0FPNUNHLFdBQUws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

import { a as createCommonjsModule, b as _interopRequireDefault, l as require$$0, c as require$$0$1, d as require$$1, e as require$$2, f as getPrototypeOf, g as require$$4, h as require$$5, j as _preact, k as unwrapExports, o as styleInject, p as h, u as v, v as _slicedToArray, y as p, t as commonjsGlobal } from './chunk-f15771b5.js';
import { a as process, b as global$1 } from './index-21088829.js';
import { a as _regeneratorRuntime } from './chunk-2b88e836.js';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent(root, new MDCFoundation());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$1 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$1 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$1(root, new MDCFoundation$1());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};
const strings = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};
const numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225,
  // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150,
  // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
let supportsCssVariables_;
/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */

let supportsPassive_;
/**
 * @param {!Window} windowObj
 * @return {boolean}
 */

function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  const document = windowObj.document;
  const node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

  const computedStyle = windowObj.getComputedStyle(node);
  const hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}
/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */


function supportsCssVariables(windowObj, forceRefresh = false) {
  let supportsCssVariables = supportsCssVariables_;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables;
  }

  const supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

  if (!supportsFunctionPresent) {
    return;
  }

  const explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari

  const weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables = false;
  }

  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVariables;
  }

  return supportsCssVariables;
} //

/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|{passive: boolean}}
 */


function applyPassive(globalObj = window, forceRefresh = false) {
  if (supportsPassive_ === undefined || forceRefresh) {
    let isSupported = false;

    try {
      globalObj.document.addEventListener('test', null, {
        get passive() {
          isSupported = true;
        }

      });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? {
    passive: true
  } : false;
}
/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */


function getMatchesProperty(HTMLElementPrototype) {
  return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(p$$1 => p$$1 in HTMLElementPrototype).pop();
}
/**
 * @param {!Event} ev
 * @param {{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {{x: number, y: number}}
 */


function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  const {
    x,
    y
  } = pageOffset;
  const documentX = x + clientRect.left;
  const documentY = y + clientRect.top;
  let normalizedX;
  let normalizedY; // Determine touch point relative to the ripple container.

  if (ev.type === 'touchstart') {
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return {
    x: normalizedX,
    y: normalizedY
  };
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

const POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

/** @type {!Array<!EventTarget>} */

let activatedTargets = [];
/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

class MDCRippleFoundation extends MDCFoundation$1 {
  static get cssClasses() {
    return cssClasses;
  }

  static get strings() {
    return strings;
  }

  static get numbers() {
    return numbers;
  }

  static get defaultAdapter() {
    return {
      browserSupportsCssVars: () =>
      /* boolean - cached */
      {},
      isUnbounded: () =>
      /* boolean */
      {},
      isSurfaceActive: () =>
      /* boolean */
      {},
      isSurfaceDisabled: () =>
      /* boolean */
      {},
      addClass: () =>
      /* className: string */
      {},
      removeClass: () =>
      /* className: string */
      {},
      containsEventTarget: () =>
      /* target: !EventTarget */
      {},
      registerInteractionHandler: () =>
      /* evtType: string, handler: EventListener */
      {},
      deregisterInteractionHandler: () =>
      /* evtType: string, handler: EventListener */
      {},
      registerDocumentInteractionHandler: () =>
      /* evtType: string, handler: EventListener */
      {},
      deregisterDocumentInteractionHandler: () =>
      /* evtType: string, handler: EventListener */
      {},
      registerResizeHandler: () =>
      /* handler: EventListener */
      {},
      deregisterResizeHandler: () =>
      /* handler: EventListener */
      {},
      updateCssVariable: () =>
      /* varName: string, value: string */
      {},
      computeBoundingRect: () =>
      /* ClientRect */
      {},
      getWindowPageOffset: () =>
      /* {x: number, y: number} */
      {}
    };
  }

  constructor(adapter) {
    super(Object.assign(MDCRippleFoundation.defaultAdapter, adapter));
    /** @private {number} */

    this.layoutFrame_ = 0;
    /** @private {!ClientRect} */

    this.frame_ =
    /** @type {!ClientRect} */
    {
      width: 0,
      height: 0
    };
    /** @private {!ActivationStateType} */

    this.activationState_ = this.defaultActivationState_();
    /** @private {number} */

    this.initialSize_ = 0;
    /** @private {number} */

    this.maxRadius_ = 0;
    /** @private {function(!Event)} */

    this.activateHandler_ = e => this.activate_(e);
    /** @private {function(!Event)} */


    this.deactivateHandler_ = e => this.deactivate_(e);
    /** @private {function(?Event=)} */


    this.focusHandler_ = () => this.handleFocus();
    /** @private {function(?Event=)} */


    this.blurHandler_ = () => this.handleBlur();
    /** @private {!Function} */


    this.resizeHandler_ = () => this.layout();
    /** @private {{left: number, top:number}} */


    this.unboundedCoords_ = {
      left: 0,
      top: 0
    };
    /** @private {number} */

    this.fgScale_ = 0;
    /** @private {number} */

    this.activationTimer_ = 0;
    /** @private {number} */

    this.fgDeactivationRemovalTimer_ = 0;
    /** @private {boolean} */

    this.activationAnimationHasEnded_ = false;
    /** @private {!Function} */

    this.activationTimerCallback_ = () => {
      this.activationAnimationHasEnded_ = true;
      this.runDeactivationUXLogicIfReady_();
    };
    /** @private {?Event} */


    this.previousActivationEvent_ = null;
  }
  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  supportsPressRipple_() {
    return this.adapter_.browserSupportsCssVars();
  }
  /**
   * @return {!ActivationStateType}
   */


  defaultActivationState_() {
    return {
      isActivated: false,
      hasDeactivationUXRun: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false,
      activationEvent: null,
      isProgrammatic: false
    };
  }
  /** @override */


  init() {
    const supportsPressRipple = this.supportsPressRipple_();
    this.registerRootHandlers_(supportsPressRipple);

    if (supportsPressRipple) {
      const {
        ROOT,
        UNBOUNDED
      } = MDCRippleFoundation.cssClasses;
      requestAnimationFrame(() => {
        this.adapter_.addClass(ROOT);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple

          this.layoutInternal_();
        }
      });
    }
  }
  /** @override */


  destroy() {
    if (this.supportsPressRipple_()) {
      if (this.activationTimer_) {
        clearTimeout(this.activationTimer_);
        this.activationTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
      }

      if (this.fgDeactivationRemovalTimer_) {
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.fgDeactivationRemovalTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
      }

      const {
        ROOT,
        UNBOUNDED
      } = MDCRippleFoundation.cssClasses;
      requestAnimationFrame(() => {
        this.adapter_.removeClass(ROOT);
        this.adapter_.removeClass(UNBOUNDED);
        this.removeCssVars_();
      });
    }

    this.deregisterRootHandlers_();
    this.deregisterDeactivationHandlers_();
  }
  /**
   * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
   * @private
   */


  registerRootHandlers_(supportsPressRipple) {
    if (supportsPressRipple) {
      ACTIVATION_EVENT_TYPES.forEach(type => {
        this.adapter_.registerInteractionHandler(type, this.activateHandler_);
      });

      if (this.adapter_.isUnbounded()) {
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }

    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
  }
  /**
   * @param {!Event} e
   * @private
   */


  registerDeactivationHandlers_(e) {
    if (e.type === 'keydown') {
      this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
    } else {
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(type => {
        this.adapter_.registerDocumentInteractionHandler(type, this.deactivateHandler_);
      });
    }
  }
  /** @private */


  deregisterRootHandlers_() {
    ACTIVATION_EVENT_TYPES.forEach(type => {
      this.adapter_.deregisterInteractionHandler(type, this.activateHandler_);
    });
    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

    if (this.adapter_.isUnbounded()) {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }
  /** @private */


  deregisterDeactivationHandlers_() {
    this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
    POINTER_DEACTIVATION_EVENT_TYPES.forEach(type => {
      this.adapter_.deregisterDocumentInteractionHandler(type, this.deactivateHandler_);
    });
  }
  /** @private */


  removeCssVars_() {
    const {
      strings: strings$$1
    } = MDCRippleFoundation;
    Object.keys(strings$$1).forEach(k => {
      if (k.indexOf('VAR_') === 0) {
        this.adapter_.updateCssVariable(strings$$1[k], null);
      }
    });
  }
  /**
   * @param {?Event} e
   * @private
   */


  activate_(e) {
    if (this.adapter_.isSurfaceDisabled()) {
      return;
    }

    const activationState = this.activationState_;

    if (activationState.isActivated) {
      return;
    } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


    const previousActivationEvent = this.previousActivationEvent_;
    const isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

    if (isSameInteraction) {
      return;
    }

    activationState.isActivated = true;
    activationState.isProgrammatic = e === null;
    activationState.activationEvent = e;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
    const hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(target => this.adapter_.containsEventTarget(target));

    if (hasActivatedChild) {
      // Immediately reset activation state, while preserving logic that prevents touch follow-on events
      this.resetActivationState_();
      return;
    }

    if (e) {
      activatedTargets.push(
      /** @type {!EventTarget} */
      e.target);
      this.registerDeactivationHandlers_(e);
    }

    activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

    if (activationState.wasElementMadeActive) {
      this.animateActivation_();
    }

    requestAnimationFrame(() => {
      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
      activatedTargets = [];

      if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
        // If space was pressed, try again within an rAF call to detect :active, because different UAs report
        // active states inconsistently when they're called within event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
        // variable is set within a rAF callback for a submit button interaction (#2241).
        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }
      }

      if (!activationState.wasElementMadeActive) {
        // Reset activation state immediately if element was not made active.
        this.activationState_ = this.defaultActivationState_();
      }
    });
  }
  /**
   * @param {?Event} e
   * @private
   */


  checkElementMadeActive_(e) {
    return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
  }
  /**
   * @param {?Event=} event Optional event containing position information.
   */


  activate(event = null) {
    this.activate_(event);
  }
  /** @private */


  animateActivation_() {
    const {
      VAR_FG_TRANSLATE_START,
      VAR_FG_TRANSLATE_END
    } = MDCRippleFoundation.strings;
    const {
      FG_DEACTIVATION,
      FG_ACTIVATION
    } = MDCRippleFoundation.cssClasses;
    const {
      DEACTIVATION_TIMEOUT_MS
    } = MDCRippleFoundation.numbers;
    this.layoutInternal_();
    let translateStart = '';
    let translateEnd = '';

    if (!this.adapter_.isUnbounded()) {
      const {
        startPoint,
        endPoint
      } = this.getFgTranslationCoordinates_();
      translateStart = `${startPoint.x}px, ${startPoint.y}px`;
      translateEnd = `${endPoint.x}px, ${endPoint.y}px`;
    }

    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

    this.adapter_.computeBoundingRect();
    this.adapter_.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(() => this.activationTimerCallback_(), DEACTIVATION_TIMEOUT_MS);
  }
  /**
   * @private
   * @return {{startPoint: PointType, endPoint: PointType}}
   */


  getFgTranslationCoordinates_() {
    const {
      activationEvent,
      wasActivatedByPointer
    } = this.activationState_;
    let startPoint;

    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(
      /** @type {!Event} */
      activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2
      };
    } // Center the element around the start point.


    startPoint = {
      x: startPoint.x - this.initialSize_ / 2,
      y: startPoint.y - this.initialSize_ / 2
    };
    const endPoint = {
      x: this.frame_.width / 2 - this.initialSize_ / 2,
      y: this.frame_.height / 2 - this.initialSize_ / 2
    };
    return {
      startPoint,
      endPoint
    };
  }
  /** @private */


  runDeactivationUXLogicIfReady_() {
    // This method is called both when a pointing device is released, and when the activation animation ends.
    // The deactivation animation should only run after both of those occur.
    const {
      FG_DEACTIVATION
    } = MDCRippleFoundation.cssClasses;
    const {
      hasDeactivationUXRun,
      isActivated
    } = this.activationState_;
    const activationHasEnded = hasDeactivationUXRun || !isActivated;

    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter_.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(() => {
        this.adapter_.removeClass(FG_DEACTIVATION);
      }, numbers.FG_DEACTIVATION_MS);
    }
  }
  /** @private */


  rmBoundedActivationClasses_() {
    const {
      FG_ACTIVATION
    } = MDCRippleFoundation.cssClasses;
    this.adapter_.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter_.computeBoundingRect();
  }

  resetActivationState_() {
    this.previousActivationEvent_ = this.activationState_.activationEvent;
    this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
    // Store the previous event until it's safe to assume that subsequent events are for new interactions.

    setTimeout(() => this.previousActivationEvent_ = null, MDCRippleFoundation.numbers.TAP_DELAY_MS);
  }
  /**
   * @param {?Event} e
   * @private
   */


  deactivate_(e) {
    const activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

    if (!activationState.isActivated) {
      return;
    }

    const state =
    /** @type {!ActivationStateType} */
    Object.assign({}, activationState);

    if (activationState.isProgrammatic) {
      const evtObject = null;
      requestAnimationFrame(() => this.animateDeactivation_(evtObject, state));
      this.resetActivationState_();
    } else {
      this.deregisterDeactivationHandlers_();
      requestAnimationFrame(() => {
        this.activationState_.hasDeactivationUXRun = true;
        this.animateDeactivation_(e, state);
        this.resetActivationState_();
      });
    }
  }
  /**
   * @param {?Event=} event Optional event containing position information.
   */


  deactivate(event = null) {
    this.deactivate_(event);
  }
  /**
   * @param {Event} e
   * @param {!ActivationStateType} options
   * @private
   */


  animateDeactivation_(e, {
    wasActivatedByPointer,
    wasElementMadeActive
  }) {
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady_();
    }
  }

  layout() {
    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }

    this.layoutFrame_ = requestAnimationFrame(() => {
      this.layoutInternal_();
      this.layoutFrame_ = 0;
    });
  }
  /** @private */


  layoutInternal_() {
    this.frame_ = this.adapter_.computeBoundingRect();
    const maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
    // `overflow: hidden`.

    const getBoundedRadius = () => {
      const hypotenuse = Math.sqrt(Math.pow(this.frame_.width, 2) + Math.pow(this.frame_.height, 2));
      return hypotenuse + MDCRippleFoundation.numbers.PADDING;
    };

    this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

    this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
    this.fgScale_ = this.maxRadius_ / this.initialSize_;
    this.updateLayoutCssVars_();
  }
  /** @private */


  updateLayoutCssVars_() {
    const {
      VAR_FG_SIZE,
      VAR_LEFT,
      VAR_TOP,
      VAR_FG_SCALE
    } = MDCRippleFoundation.strings;
    this.adapter_.updateCssVariable(VAR_FG_SIZE, `${this.initialSize_}px`);
    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

    if (this.adapter_.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
      };
      this.adapter_.updateCssVariable(VAR_LEFT, `${this.unboundedCoords_.left}px`);
      this.adapter_.updateCssVariable(VAR_TOP, `${this.unboundedCoords_.top}px`);
    }
  }
  /** @param {boolean} unbounded */


  setUnbounded(unbounded) {
    const {
      UNBOUNDED
    } = MDCRippleFoundation.cssClasses;

    if (unbounded) {
      this.adapter_.addClass(UNBOUNDED);
    } else {
      this.adapter_.removeClass(UNBOUNDED);
    }
  }

  handleFocus() {
    requestAnimationFrame(() => this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));
  }

  handleBlur() {
    requestAnimationFrame(() => this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

class MDCRipple extends MDCComponent$1 {
  /** @param {...?} args */
  constructor(...args) {
    super(...args);
    /** @type {boolean} */

    this.disabled = false;
    /** @private {boolean} */

    this.unbounded_;
  }
  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  static attachTo(root, {
    isUnbounded = undefined
  } = {}) {
    const ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

    if (isUnbounded !== undefined) {
      ripple.unbounded =
      /** @type {boolean} */
      isUnbounded;
    }

    return ripple;
  }
  /**
   * @param {!RippleCapableSurface} instance
   * @return {!MDCRippleAdapter}
   */


  static createAdapter(instance) {
    const MATCHES = getMatchesProperty(HTMLElement.prototype);
    return {
      browserSupportsCssVars: () => supportsCssVariables(window),
      isUnbounded: () => instance.unbounded,
      isSurfaceActive: () => instance.root_[MATCHES](':active'),
      isSurfaceDisabled: () => instance.disabled,
      addClass: className => instance.root_.classList.add(className),
      removeClass: className => instance.root_.classList.remove(className),
      containsEventTarget: target => instance.root_.contains(target),
      registerInteractionHandler: (evtType, handler) => instance.root_.addEventListener(evtType, handler, applyPassive()),
      deregisterInteractionHandler: (evtType, handler) => instance.root_.removeEventListener(evtType, handler, applyPassive()),
      registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
      deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
      registerResizeHandler: handler => window.addEventListener('resize', handler),
      deregisterResizeHandler: handler => window.removeEventListener('resize', handler),
      updateCssVariable: (varName, value) => instance.root_.style.setProperty(varName, value),
      computeBoundingRect: () => instance.root_.getBoundingClientRect(),
      getWindowPageOffset: () => ({
        x: window.pageXOffset,
        y: window.pageYOffset
      })
    };
  }
  /** @return {boolean} */


  get unbounded() {
    return this.unbounded_;
  }
  /** @param {boolean} unbounded */


  set unbounded(unbounded) {
    this.unbounded_ = Boolean(unbounded);
    this.setUnbounded_();
  }
  /**
   * Closure Compiler throws an access control error when directly accessing a
   * protected or private property inside a getter/setter, like unbounded above.
   * By accessing the protected property inside a method, we solve that problem.
   * That's why this function exists.
   * @private
   */


  setUnbounded_() {
    this.foundation_.setUnbounded(this.unbounded_);
  }

  activate() {
    this.foundation_.activate();
  }

  deactivate() {
    this.foundation_.deactivate();
  }

  layout() {
    this.foundation_.layout();
  }
  /**
   * @return {!MDCRippleFoundation}
   * @override
   */


  getDefaultFoundation() {
    return new MDCRippleFoundation(MDCRipple.createAdapter(this));
  }
  /** @override */


  initialSyncWithDOM() {
    this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
  }

}
/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */


class RippleCapableSurface {}
/** @protected {!Element} */


RippleCapableSurface.prototype.root_;
/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */

RippleCapableSurface.prototype.unbounded;
/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */

RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$2 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$2 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$2(root, new MDCFoundation$2());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$1 = {
  ACTIVE: 'mdc-tab-indicator--active',
  FADE: 'mdc-tab-indicator--fade',
  NO_TRANSITION: 'mdc-tab-indicator--no-transition'
};
/** @enum {string} */

const strings$1 = {
  CONTENT_SELECTOR: '.mdc-tab-indicator__content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
 * @abstract
 */

class MDCTabIndicatorFoundation extends MDCFoundation$2 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$1;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$1;
  }
  /**
   * @see MDCTabIndicatorAdapter for typing information
   * @return {!MDCTabIndicatorAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabIndicatorAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        computeContentClientRect: () => {},
        setContentStyleProperty: () => {}
      }
    );
  }
  /** @param {!MDCTabIndicatorAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter));
  }
  /** @return {!ClientRect} */


  computeContentClientRect() {
    return this.adapter_.computeContentClientRect();
  }
  /**
   * Activates the indicator
   * @param {!ClientRect=} previousIndicatorClientRect
   * @abstract
   */


  activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

  /** @abstract */


  deactivate() {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCSlidingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  /** @param {!ClientRect=} previousIndicatorClientRect */
  activate(previousIndicatorClientRect) {
    // Early exit if no indicator is present to handle cases where an indicator
    // may be activated without a prior indicator state
    if (!previousIndicatorClientRect) {
      this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
      return;
    } // This animation uses the FLIP approach. You can read more about it at the link below:
    // https://aerotwist.com/blog/flip-your-animations/
    // Calculate the dimensions based on the dimensions of the previous indicator


    const currentClientRect = this.computeContentClientRect();
    const widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
    const xPosition = previousIndicatorClientRect.left - currentClientRect.left;
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.setContentStyleProperty('transform', `translateX(${xPosition}px) scaleX(${widthDelta})`); // Force repaint before updating classes and transform to ensure the transform properly takes effect

    this.computeContentClientRect();
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    this.adapter_.setContentStyleProperty('transform', '');
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCTabIndicatorFoundation}
 * @final
 */

class MDCFadingTabIndicatorFoundation extends MDCTabIndicatorFoundation {
  activate() {
    this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

  deactivate() {
    this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
 * @final
 */

class MDCTabIndicator extends MDCComponent$2 {
  /**
   * @param {!Element} root
   * @return {!MDCTabIndicator}
   */
  static attachTo(root) {
    return new MDCTabIndicator(root);
  }
  /**
   * @param {...?} args
   */


  constructor(...args) {
    super(...args);
    /** @type {?Element} */

    this.content_;
  }

  initialize() {
    this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
  }
  /**
   * @return {!ClientRect}
   */


  computeContentClientRect() {
    return this.foundation_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabIndicatorFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabIndicatorAdapter} */
    Object.assign({
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      computeContentClientRect: () => this.content_.getBoundingClientRect(),
      setContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value)
    });

    if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
      return new MDCFadingTabIndicatorFoundation(adapter);
    } // Default to the sliding indicator


    return new MDCSlidingTabIndicatorFoundation(adapter);
  }
  /**
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.foundation_.activate(previousIndicatorClientRect);
  }

  deactivate() {
    this.foundation_.deactivate();
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$2 = {
  ACTIVE: 'mdc-tab--active'
};
/** @enum {string} */

const strings$2 = {
  ARIA_SELECTED: 'aria-selected',
  RIPPLE_SELECTOR: '.mdc-tab__ripple',
  CONTENT_SELECTOR: '.mdc-tab__content',
  TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
  TABINDEX: 'tabIndex',
  INTERACTED_EVENT: 'MDCTab:interacted'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabAdapter>}
 * @final
 */

class MDCTabFoundation extends MDCFoundation$1 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$2;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$2;
  }
  /**
   * @see MDCTabAdapter for typing information
   * @return {!MDCTabAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabAdapter} */
      {
        addClass: () => {},
        removeClass: () => {},
        hasClass: () => {},
        setAttr: () => {},
        activateIndicator: () => {},
        deactivateIndicator: () => {},
        notifyInteracted: () => {},
        getOffsetLeft: () => {},
        getOffsetWidth: () => {},
        getContentOffsetLeft: () => {},
        getContentOffsetWidth: () => {},
        focus: () => {}
      }
    );
  }
  /** @param {!MDCTabAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabFoundation.defaultAdapter, adapter));
    /** @private {function(?Event): undefined} */

    this.handleClick_ = () => this.handleClick();
  }
  /**
   * Handles the "click" event
   */


  handleClick() {
    // It's up to the parent component to keep track of the active Tab and
    // ensure we don't activate a Tab that's already active.
    this.adapter_.notifyInteracted();
  }
  /**
   * Returns the Tab's active state
   * @return {boolean}
   */


  isActive() {
    return this.adapter_.hasClass(cssClasses$2.ACTIVE);
  }
  /**
   * Activates the Tab
   * @param {!ClientRect=} previousIndicatorClientRect
   */


  activate(previousIndicatorClientRect) {
    this.adapter_.addClass(cssClasses$2.ACTIVE);
    this.adapter_.setAttr(strings$2.ARIA_SELECTED, 'true');
    this.adapter_.setAttr(strings$2.TABINDEX, '0');
    this.adapter_.activateIndicator(previousIndicatorClientRect);
    this.adapter_.focus();
  }
  /**
   * Deactivates the Tab
   */


  deactivate() {
    // Early exit
    if (!this.isActive()) {
      return;
    }

    this.adapter_.removeClass(cssClasses$2.ACTIVE);
    this.adapter_.setAttr(strings$2.ARIA_SELECTED, 'false');
    this.adapter_.setAttr(strings$2.TABINDEX, '-1');
    this.adapter_.deactivateIndicator();
  }
  /**
   * Returns the dimensions of the Tab
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    const rootWidth = this.adapter_.getOffsetWidth();
    const rootLeft = this.adapter_.getOffsetLeft();
    const contentWidth = this.adapter_.getContentOffsetWidth();
    const contentLeft = this.adapter_.getContentOffsetLeft();
    return {
      rootLeft,
      rootRight: rootLeft + rootWidth,
      contentLeft: rootLeft + contentLeft,
      contentRight: rootLeft + contentLeft + contentWidth
    };
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabFoundation>}
 * @final
 */

class MDCTab extends MDCComponent$1 {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {?MDCRipple} */

    this.ripple_;
    /** @private {?MDCTabIndicator} */

    this.tabIndicator_;
    /** @private {?Element} */

    this.content_;
    /** @private {?Function} */

    this.handleClick_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTab}
   */


  static attachTo(root) {
    return new MDCTab(root);
  }

  initialize(rippleFactory = (el, foundation) => new MDCRipple(el, foundation), tabIndicatorFactory = el => new MDCTabIndicator(el)) {
    const rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
    const rippleAdapter = Object.assign(MDCRipple.createAdapter(
    /** @type {!RippleCapableSurface} */
    this), {
      addClass: className => rippleSurface.classList.add(className),
      removeClass: className => rippleSurface.classList.remove(className),
      updateCssVariable: (varName, value) => rippleSurface.style.setProperty(varName, value)
    });
    const rippleFoundation = new MDCRippleFoundation(rippleAdapter);
    this.ripple_ = rippleFactory(this.root_, rippleFoundation);
    const tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
    this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
    this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
    this.listen('click', this.handleClick_);
  }

  destroy() {
    this.unlisten('click',
    /** @type {!Function} */
    this.handleClick_);
    this.ripple_.destroy();
    super.destroy();
  }
  /**
   * @return {!MDCTabFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabFoundation(
    /** @type {!MDCTabAdapter} */
    {
      setAttr: (attr, value) => this.root_.setAttribute(attr, value),
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      hasClass: className => this.root_.classList.contains(className),
      activateIndicator: previousIndicatorClientRect => this.tabIndicator_.activate(previousIndicatorClientRect),
      deactivateIndicator: () => this.tabIndicator_.deactivate(),
      notifyInteracted: () => this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, {
        tab: this
      }, true
      /* bubble */
      ),
      getOffsetLeft: () => this.root_.offsetLeft,
      getOffsetWidth: () => this.root_.offsetWidth,
      getContentOffsetLeft: () => this.content_.offsetLeft,
      getContentOffsetWidth: () => this.content_.offsetWidth,
      focus: () => this.root_.focus()
    });
  }
  /**
   * Getter for the active state of the tab
   * @return {boolean}
   */


  get active() {
    return this.foundation_.isActive();
  }
  /**
   * Activates the tab
   * @param {!ClientRect=} computeIndicatorClientRect
   */


  activate(computeIndicatorClientRect) {
    this.foundation_.activate(computeIndicatorClientRect);
  }
  /**
   * Deactivates the tab
   */


  deactivate() {
    this.foundation_.deactivate();
  }
  /**
   * Returns the indicator's client rect
   * @return {!ClientRect}
   */


  computeIndicatorClientRect() {
    return this.tabIndicator_.computeContentClientRect();
  }
  /**
   * @return {!MDCTabDimensions}
   */


  computeDimensions() {
    return this.foundation_.computeDimensions();
  }
  /**
   * Focuses the tab
   */


  focus() {
    this.root_.focus();
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation$3 {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }
  /** @return enum{strings} */


  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }
  /** @return enum{numbers} */


  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }
  /** @return {!Object} */


  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }
  /**
   * @param {A=} adapter
   */


  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }

}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @template F
 */

class MDCComponent$3 {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  static attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent$3(root, new MDCFoundation$3());
  }
  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  constructor(root, foundation = undefined, ...args) {
    /** @protected {!Element} */
    this.root_ = root;
    this.initialize(...args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  initialize()
  /* ...args */
  {} // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.

  /**
   * @return {!F} foundation
   */


  getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  }

  initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  }

  destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  }
  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  }
  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  }
  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  emit(evtType, evtData, shouldBubble = false) {
    let evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses$3 = {
  ANIMATING: 'mdc-tab-scroller--animating',
  SCROLL_TEST: 'mdc-tab-scroller__test',
  SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
};
/** @enum {string} */

const strings$3 = {
  AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
  CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @abstract
 */

class MDCTabScrollerRTL {
  /** @param {!MDCTabScrollerAdapter} adapter */
  constructor(adapter) {
    /** @private */
    this.adapter_ = adapter;
  }
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getScrollPositionRTL(translateX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  scrollToRTL(scrollX) {}
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   * @abstract
   */


  incrementScrollRTL(scrollX) {}
  /**
   * @param {number} scrollX The current scrollX position
   * @param {number} translateX The current translateX position
   * @return {number}
   * @abstract
   */


  getAnimatingScrollPosition(scrollX, translateX) {}

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLDefault extends MDCTabScrollerRTL {
  /**
   * @return {number}
   */
  getScrollPositionRTL() {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const {
      right
    } = this.calculateScrollEdges_(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(right - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const edges = this.calculateScrollEdges_();
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX) {
    return scrollX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLNegative extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX The current translateX position
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return Math.round(translateX - currentScrollLeft);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(-scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @param {number} translateX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX - translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: rootWidth - contentWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.max(Math.min(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCTabScrollerRTL}
 * @final
 */

class MDCTabScrollerRTLReverse extends MDCTabScrollerRTL {
  /**
   * @param {number} translateX
   * @return {number}
   */
  getScrollPositionRTL(translateX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

    return Math.round(currentScrollLeft - translateX);
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  scrollToRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {!MDCTabScrollerAnimation}
   */


  incrementScrollRTL(scrollX) {
    const currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    const clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
    return (
      /** @type {!MDCTabScrollerAnimation} */
      {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   */


  getAnimatingScrollPosition(scrollX, translateX) {
    return scrollX + translateX;
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: contentWidth - rootWidth,
        right: 0
      }
    );
  }
  /**
   * @param {number} scrollX
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.right, scrollX), edges.left);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
 * @final
 */

class MDCTabScrollerFoundation extends MDCFoundation$3 {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$3;
  }
  /** @return enum {string} */


  static get strings() {
    return strings$3;
  }
  /**
   * @see MDCTabScrollerAdapter for typing information
   * @return {!MDCTabScrollerAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabScrollerAdapter} */
      {
        eventTargetMatchesSelector: () => {},
        addClass: () => {},
        removeClass: () => {},
        addScrollAreaClass: () => {},
        setScrollAreaStyleProperty: () => {},
        setScrollContentStyleProperty: () => {},
        getScrollContentStyleValue: () => {},
        setScrollAreaScrollLeft: () => {},
        getScrollAreaScrollLeft: () => {},
        getScrollContentOffsetWidth: () => {},
        getScrollAreaOffsetWidth: () => {},
        computeScrollAreaClientRect: () => {},
        computeScrollContentClientRect: () => {},
        computeHorizontalScrollbarHeight: () => {}
      }
    );
  }
  /** @param {!MDCTabScrollerAdapter} adapter */


  constructor(adapter) {
    super(Object.assign(MDCTabScrollerFoundation.defaultAdapter, adapter));
    /**
     * This boolean controls whether we should handle the transitionend and interaction events during the animation.
     * @private {boolean}
     */

    this.isAnimating_ = false;
    /**
     * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
     * of RTL scrolling in it's own class.
     * @private {?MDCTabScrollerRTL}
     */

    this.rtlScrollerInstance_;
  }

  init() {
    // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
    // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
    const horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
    this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
    this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
  }
  /**
   * Computes the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    if (this.isRTL_()) {
      return this.computeCurrentScrollPositionRTL_();
    }

    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();
    return scrollLeft - currentTranslateX;
  }
  /**
   * Handles interaction events that occur during transition
   */


  handleInteraction() {
    // Early exit if we aren't animating
    if (!this.isAnimating_) {
      return;
    } // Prevent other event listeners from handling this event


    this.stopScrollAnimation_();
  }
  /**
   * Handles the transitionend event
   * @param {!Event} evt
   */


  handleTransitionEnd(evt) {
    // Early exit if we aren't animating or the event was triggered by a different element.
    if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
      return;
    }

    this.isAnimating_ = false;
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
  }
  /**
   * Increment the scroll value by the scrollXIncrement
   * @param {number} scrollXIncrement The value by which to increment the scroll position
   */


  incrementScroll(scrollXIncrement) {
    // Early exit for non-operational increment values
    if (scrollXIncrement === 0) {
      return;
    }

    if (this.isRTL_()) {
      return this.incrementScrollRTL_(scrollXIncrement);
    }

    this.incrementScroll_(scrollXIncrement);
  }
  /**
   * Scrolls to the given scrollX value
   * @param {number} scrollX
   */


  scrollTo(scrollX) {
    if (this.isRTL_()) {
      return this.scrollToRTL_(scrollX);
    }

    this.scrollTo_(scrollX);
  }
  /**
   * Returns the appropriate version of the MDCTabScrollerRTL
   * @return {!MDCTabScrollerRTL}
   */


  getRTLScroller() {
    if (!this.rtlScrollerInstance_) {
      this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
    }

    return this.rtlScrollerInstance_;
  }
  /**
   * Returns the translateX value from a CSS matrix transform function string
   * @return {number}
   * @private
   */


  calculateCurrentTranslateX_() {
    const transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

    if (transformValue === 'none') {
      return 0;
    } // The transform value comes back as a matrix transformation in the form
    // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
    // we're going to grab all the parenthesized values, strip out tx, and
    // parse it.


    const results = /\((.+)\)/.exec(transformValue)[1];
    const parts = results.split(',');
    return parseFloat(parts[4]);
  }
  /**
   * Calculates a safe scroll value that is > 0 and < the max scroll value
   * @param {number} scrollX The distance to scroll
   * @return {number}
   * @private
   */


  clampScrollValue_(scrollX) {
    const edges = this.calculateScrollEdges_();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  }
  /**
   * @return {number}
   * @private
   */


  computeCurrentScrollPositionRTL_() {
    const translateX = this.calculateCurrentTranslateX_();
    return this.getRTLScroller().getScrollPositionRTL(translateX);
  }
  /**
   * @return {!MDCTabScrollerHorizontalEdges}
   * @private
   */


  calculateScrollEdges_() {
    const contentWidth = this.adapter_.getScrollContentOffsetWidth();
    const rootWidth = this.adapter_.getScrollAreaOffsetWidth();
    return (
      /** @type {!MDCTabScrollerHorizontalEdges} */
      {
        left: 0,
        right: contentWidth - rootWidth
      }
    );
  }
  /**
   * Internal scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollTo_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const safeScrollX = this.clampScrollValue_(scrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal RTL scroll method
   * @param {number} scrollX The new scroll position
   * @private
   */


  scrollToRTL_(scrollX) {
    const animation = this.getRTLScroller().scrollToRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Internal increment scroll method
   * @param {number} scrollX The new scroll position increment
   * @private
   */


  incrementScroll_(scrollX) {
    const currentScrollX = this.getScrollPosition();
    const targetScrollX = scrollX + currentScrollX;
    const safeScrollX = this.clampScrollValue_(targetScrollX);
    const scrollDelta = safeScrollX - currentScrollX;
    this.animate_(
    /** @type {!MDCTabScrollerAnimation} */
    {
      finalScrollPosition: safeScrollX,
      scrollDelta: scrollDelta
    });
  }
  /**
   * Internal incremenet scroll RTL method
   * @param {number} scrollX The new scroll position RTL increment
   * @private
   */


  incrementScrollRTL_(scrollX) {
    const animation = this.getRTLScroller().incrementScrollRTL(scrollX);
    this.animate_(animation);
  }
  /**
   * Animates the tab scrolling
   * @param {!MDCTabScrollerAnimation} animation The animation to apply
   * @private
   */


  animate_(animation) {
    // Early exit if translateX is 0, which means there's no animation to perform
    if (animation.scrollDelta === 0) {
      return;
    }

    this.stopScrollAnimation_(); // This animation uses the FLIP approach.
    // Read more here: https://aerotwist.com/blog/flip-your-animations/

    this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
    this.adapter_.setScrollContentStyleProperty('transform', `translateX(${animation.scrollDelta}px)`); // Force repaint

    this.adapter_.computeScrollAreaClientRect();
    requestAnimationFrame(() => {
      this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
      this.adapter_.setScrollContentStyleProperty('transform', 'none');
    });
    this.isAnimating_ = true;
  }
  /**
   * Stops scroll animation
   * @private
   */


  stopScrollAnimation_() {
    this.isAnimating_ = false;
    const currentScrollPosition = this.getAnimatingScrollPosition_();
    this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
    this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
    this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
  }
  /**
   * Gets the current scroll position during animation
   * @return {number}
   * @private
   */


  getAnimatingScrollPosition_() {
    const currentTranslateX = this.calculateCurrentTranslateX_();
    const scrollLeft = this.adapter_.getScrollAreaScrollLeft();

    if (this.isRTL_()) {
      return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
    }

    return scrollLeft - currentTranslateX;
  }
  /**
   * Determines the RTL Scroller to use
   * @return {!MDCTabScrollerRTL}
   * @private
   */


  rtlScrollerFactory_() {
    // Browsers have three different implementations of scrollLeft in RTL mode,
    // dependent on the browser. The behavior is based off the max LTR
    // scrollleft value and 0.
    //
    // * Default scrolling in RTL *
    //    - Left-most value: 0
    //    - Right-most value: Max LTR scrollLeft value
    //
    // * Negative scrolling in RTL *
    //    - Left-most value: Negated max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // * Reverse scrolling in RTL *
    //    - Left-most value: Max LTR scrollLeft value
    //    - Right-most value: 0
    //
    // We use those principles below to determine which RTL scrollLeft
    // behavior is implemented in the current browser.
    const initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
    const newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
    // implemented negative RTL scrolling, since all other implementations have
    // only positive values.

    if (newScrollLeft < 0) {
      // Undo the scrollLeft test check
      this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
      return new MDCTabScrollerRTLNegative(this.adapter_);
    }

    const rootClientRect = this.adapter_.computeScrollAreaClientRect();
    const contentClientRect = this.adapter_.computeScrollContentClientRect();
    const rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

    this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
    // the content element, we can determine how much the scroll value changed
    // when we performed the scrollLeft subtraction above.

    if (rightEdgeDelta === newScrollLeft) {
      return new MDCTabScrollerRTLReverse(this.adapter_);
    }

    return new MDCTabScrollerRTLDefault(this.adapter_);
  }
  /**
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
 * @private {number|undefined}
 */

let horizontalScrollbarHeight_;
/**
 * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
 * May return 0 (e.g. on OS X browsers under default configuration).
 * @param {!Document} documentObj
 * @param {boolean=} shouldCacheResult
 * @return {number}
 */

function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult = true) {
  if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
    return horizontalScrollbarHeight_;
  }

  const el = documentObj.createElement('div');
  el.classList.add(cssClasses$3.SCROLL_TEST);
  documentObj.body.appendChild(el);
  const horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
  documentObj.body.removeChild(el);

  if (shouldCacheResult) {
    horizontalScrollbarHeight_ = horizontalScrollbarHeight;
  }

  return horizontalScrollbarHeight;
}
/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */


function getMatchesProperty$1(HTMLElementPrototype) {
  return ['msMatchesSelector', 'matches'].filter(p$$1 => p$$1 in HTMLElementPrototype).pop();
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabScrollerFoundation>}
 * @final
 */

class MDCTabScroller extends MDCComponent$3 {
  /**
   * @param {!Element} root
   * @return {!MDCTabScroller}
   */
  static attachTo(root) {
    return new MDCTabScroller(root);
  }

  constructor(...args) {
    super(...args);
    /** @private {?Element} */

    this.content_;
    /** @private {?Element} */

    this.area_;
    /** @private {?function(?Event): undefined} */

    this.handleInteraction_;
    /** @private {?function(!Event): undefined} */

    this.handleTransitionEnd_;
  }

  initialize() {
    this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
    this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
  }

  initialSyncWithDOM() {
    this.handleInteraction_ = () => this.foundation_.handleInteraction();

    this.handleTransitionEnd_ = evt => this.foundation_.handleTransitionEnd(evt);

    this.area_.addEventListener('wheel', this.handleInteraction_);
    this.area_.addEventListener('touchstart', this.handleInteraction_);
    this.area_.addEventListener('pointerdown', this.handleInteraction_);
    this.area_.addEventListener('mousedown', this.handleInteraction_);
    this.area_.addEventListener('keydown', this.handleInteraction_);
    this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
  }

  destroy() {
    super.destroy();
    this.area_.removeEventListener('wheel', this.handleInteraction_);
    this.area_.removeEventListener('touchstart', this.handleInteraction_);
    this.area_.removeEventListener('pointerdown', this.handleInteraction_);
    this.area_.removeEventListener('mousedown', this.handleInteraction_);
    this.area_.removeEventListener('keydown', this.handleInteraction_);
    this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
  }
  /**
   * @return {!MDCTabScrollerFoundation}
   */


  getDefaultFoundation() {
    const adapter =
    /** @type {!MDCTabScrollerAdapter} */
    {
      eventTargetMatchesSelector: (evtTarget, selector) => {
        const MATCHES = getMatchesProperty$1(HTMLElement.prototype);
        return evtTarget[MATCHES](selector);
      },
      addClass: className => this.root_.classList.add(className),
      removeClass: className => this.root_.classList.remove(className),
      addScrollAreaClass: className => this.area_.classList.add(className),
      setScrollAreaStyleProperty: (prop, value) => this.area_.style.setProperty(prop, value),
      setScrollContentStyleProperty: (prop, value) => this.content_.style.setProperty(prop, value),
      getScrollContentStyleValue: propName => window.getComputedStyle(this.content_).getPropertyValue(propName),
      setScrollAreaScrollLeft: scrollX => this.area_.scrollLeft = scrollX,
      getScrollAreaScrollLeft: () => this.area_.scrollLeft,
      getScrollContentOffsetWidth: () => this.content_.offsetWidth,
      getScrollAreaOffsetWidth: () => this.area_.offsetWidth,
      computeScrollAreaClientRect: () => this.area_.getBoundingClientRect(),
      computeScrollContentClientRect: () => this.content_.getBoundingClientRect(),
      computeHorizontalScrollbarHeight: () => computeHorizontalScrollbarHeight(document)
    };
    return new MDCTabScrollerFoundation(adapter);
  }
  /**
   * Returns the current visual scroll position
   * @return {number}
   */


  getScrollPosition() {
    return this.foundation_.getScrollPosition();
  }
  /**
   * Returns the width of the scroll content
   * @return {number}
   */


  getScrollContentWidth() {
    return this.content_.offsetWidth;
  }
  /**
   * Increments the scroll value by the given amount
   * @param {number} scrollXIncrement The pixel value by which to increment the scroll value
   */


  incrementScroll(scrollXIncrement) {
    this.foundation_.incrementScroll(scrollXIncrement);
  }
  /**
   * Scrolls to the given pixel position
   * @param {number} scrollX The pixel value to scroll to
   */


  scrollTo(scrollX) {
    this.foundation_.scrollTo(scrollX);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const strings$4 = {
  TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
  TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
  TAB_SELECTOR: '.mdc-tab',
  ARROW_LEFT_KEY: 'ArrowLeft',
  ARROW_RIGHT_KEY: 'ArrowRight',
  END_KEY: 'End',
  HOME_KEY: 'Home',
  ENTER_KEY: 'Enter',
  SPACE_KEY: 'Space'
};
/** @enum {number} */

const numbers$1 = {
  EXTRA_SCROLL_AMOUNT: 20,
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  HOME_KEYCODE: 36,
  ENTER_KEYCODE: 13,
  SPACE_KEYCODE: 32
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* eslint-enable no-unused-vars */

/**
 * @type {Set<string>}
 */

const ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand

ACCEPTABLE_KEYS.add(strings$4.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings$4.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings$4.END_KEY);
ACCEPTABLE_KEYS.add(strings$4.HOME_KEY);
ACCEPTABLE_KEYS.add(strings$4.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings$4.SPACE_KEY);
/**
 * @type {Map<number, string>}
 */

const KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand

KEYCODE_MAP.set(numbers$1.ARROW_LEFT_KEYCODE, strings$4.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers$1.ARROW_RIGHT_KEYCODE, strings$4.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers$1.END_KEYCODE, strings$4.END_KEY);
KEYCODE_MAP.set(numbers$1.HOME_KEYCODE, strings$4.HOME_KEY);
KEYCODE_MAP.set(numbers$1.ENTER_KEYCODE, strings$4.ENTER_KEY);
KEYCODE_MAP.set(numbers$1.SPACE_KEYCODE, strings$4.SPACE_KEY);
/**
 * @extends {MDCFoundation<!MDCTabBarAdapter>}
 * @final
 */

class MDCTabBarFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$4;
  }
  /** @return enum {number} */


  static get numbers() {
    return numbers$1;
  }
  /**
   * @see MDCTabBarAdapter for typing information
   * @return {!MDCTabBarAdapter}
   */


  static get defaultAdapter() {
    return (
      /** @type {!MDCTabBarAdapter} */
      {
        scrollTo: () => {},
        incrementScroll: () => {},
        getScrollPosition: () => {},
        getScrollContentWidth: () => {},
        getOffsetWidth: () => {},
        isRTL: () => {},
        setActiveTab: () => {},
        activateTabAtIndex: () => {},
        deactivateTabAtIndex: () => {},
        focusTabAtIndex: () => {},
        getTabIndicatorClientRectAtIndex: () => {},
        getTabDimensionsAtIndex: () => {},
        getPreviousActiveTabIndex: () => {},
        getFocusedTabIndex: () => {},
        getIndexOfTab: () => {},
        getTabListLength: () => {},
        notifyTabActivated: () => {}
      }
    );
  }
  /**
   * @param {!MDCTabBarAdapter} adapter
   * */


  constructor(adapter) {
    super(Object.assign(MDCTabBarFoundation.defaultAdapter, adapter));
    /** @private {boolean} */

    this.useAutomaticActivation_ = false;
  }
  /**
   * Switches between automatic and manual activation modes.
   * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
   * @param {boolean} useAutomaticActivation
   */


  setUseAutomaticActivation(useAutomaticActivation) {
    this.useAutomaticActivation_ = useAutomaticActivation;
  }
  /**
   * Activates the tab at the given index
   * @param {number} index
   */


  activateTab(index) {
    const previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();

    if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
      return;
    }

    this.adapter_.deactivateTabAtIndex(previousActiveIndex);
    this.adapter_.activateTabAtIndex(index, this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex));
    this.scrollIntoView(index);
    this.adapter_.notifyTabActivated(index);
  }
  /**
   * Handles the keydown event
   * @param {!Event} evt
   */


  handleKeyDown(evt) {
    // Get the key from the event
    const key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys

    if (key === undefined) {
      return;
    } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple


    if (!this.isActivationKey_(key)) {
      evt.preventDefault();
    }

    if (this.useAutomaticActivation_) {
      if (this.isActivationKey_(key)) {
        return;
      }

      const index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
      this.adapter_.setActiveTab(index);
      this.scrollIntoView(index);
    } else {
      const focusedTabIndex = this.adapter_.getFocusedTabIndex();

      if (this.isActivationKey_(key)) {
        this.adapter_.setActiveTab(focusedTabIndex);
      } else {
        const index = this.determineTargetFromKey_(focusedTabIndex, key);
        this.adapter_.focusTabAtIndex(index);
        this.scrollIntoView(index);
      }
    }
  }
  /**
   * Handles the MDCTab:interacted event
   * @param {!Event} evt
   */


  handleTabInteraction(evt) {
    this.adapter_.setActiveTab(this.adapter_.getIndexOfTab(evt.detail.tab));
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index The tab index to make visible
   */


  scrollIntoView(index) {
    // Early exit if the index is out of range
    if (!this.indexIsInRange_(index)) {
      return;
    } // Always scroll to 0 if scrolling to the 0th index


    if (index === 0) {
      return this.adapter_.scrollTo(0);
    } // Always scroll to the max value if scrolling to the Nth index
    // MDCTabScroller.scrollTo() will never scroll past the max possible value


    if (index === this.adapter_.getTabListLength() - 1) {
      return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
    }

    if (this.isRTL_()) {
      return this.scrollIntoViewRTL_(index);
    }

    this.scrollIntoView_(index);
  }
  /**
   * Private method for determining the index of the destination tab based on what key was pressed
   * @param {number} origin The original index from which to determine the destination
   * @param {string} key The name of the key
   * @return {number}
   * @private
   */


  determineTargetFromKey_(origin, key) {
    const isRTL = this.isRTL_();
    const maxIndex = this.adapter_.getTabListLength() - 1;
    const shouldGoToEnd = key === strings$4.END_KEY;
    const shouldDecrement = key === strings$4.ARROW_LEFT_KEY && !isRTL || key === strings$4.ARROW_RIGHT_KEY && isRTL;
    const shouldIncrement = key === strings$4.ARROW_RIGHT_KEY && !isRTL || key === strings$4.ARROW_LEFT_KEY && isRTL;
    let index = origin;

    if (shouldGoToEnd) {
      index = maxIndex;
    } else if (shouldDecrement) {
      index -= 1;
    } else if (shouldIncrement) {
      index += 1;
    } else {
      index = 0;
    }

    if (index < 0) {
      index = maxIndex;
    } else if (index > maxIndex) {
      index = 0;
    }

    return index;
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @return {number}
   * @private
   */


  calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
    const relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
    const leftIncrement = relativeContentRight - numbers$1.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft + numbers$1.EXTRA_SCROLL_AMOUNT;

    if (nextIndex < index) {
      return Math.min(leftIncrement, 0);
    }

    return Math.max(rightIncrement, 0);
  }
  /**
   * Calculates the scroll increment that will make the tab at the given index visible in RTL
   * @param {number} index The index of the tab
   * @param {number} nextIndex The index of the next tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the Tab Bar
   * @param {number} scrollContentWidth The width of the scroll content
   * @return {number}
   * @private
   */


  calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
    const nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
    const relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
    const relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
    const leftIncrement = relativeContentRight + numbers$1.EXTRA_SCROLL_AMOUNT;
    const rightIncrement = relativeContentLeft - numbers$1.EXTRA_SCROLL_AMOUNT;

    if (nextIndex > index) {
      return Math.max(leftIncrement, 0);
    }

    return Math.min(rightIncrement, 0);
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth) {
    /**
     * Tabs are laid out in the Tab Scroller like this:
     *
     *    Scroll Position
     *    +---+
     *    |   |   Bar Width
     *    |   +-----------------------------------+
     *    |   |                                   |
     *    |   V                                   V
     *    |   +-----------------------------------+
     *    V   |             Tab Scroller          |
     *    +------------+--------------+-------------------+
     *    |    Tab     |      Tab     |        Tab        |
     *    +------------+--------------+-------------------+
     *        |                                   |
     *        +-----------------------------------+
     *
     * To determine the next adjacent index, we look at the Tab root left and
     * Tab root right, both relative to the scroll position. If the Tab root
     * left is less than 0, then we know it's out of view to the left. If the
     * Tab root right minus the bar width is greater than 0, we know the Tab is
     * out of view to the right. From there, we either increment or decrement
     * the index.
     */
    const relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
    const relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
    const relativeRootDelta = relativeRootLeft + relativeRootRight;
    const leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
    const rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;

    if (leftEdgeIsCloser) {
      return index - 1;
    }

    if (rightEdgeIsCloser) {
      return index + 1;
    }

    return -1;
  }
  /**
   * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
   * @param {number} index The index of the tab
   * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
   * @param {number} scrollPosition The current scroll position
   * @param {number} barWidth The width of the tab bar
   * @param {number} scrollContentWidth The width of the scroller content
   * @return {number}
   * @private
   */


  findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
    const rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
    const rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
    const rootDelta = rootLeft + rootRight;
    const leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
    const rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;

    if (leftEdgeIsCloser) {
      return index + 1;
    }

    if (rightEdgeIsCloser) {
      return index - 1;
    }

    return -1;
  }
  /**
   * Returns the key associated with a keydown event
   * @param {!Event} evt The keydown event
   * @return {string}
   * @private
   */


  getKeyFromEvent_(evt) {
    if (ACCEPTABLE_KEYS.has(evt.key)) {
      return evt.key;
    }

    return KEYCODE_MAP.get(evt.keyCode);
  }

  isActivationKey_(key) {
    return key === strings$4.SPACE_KEY || key === strings$4.ENTER_KEY;
  }
  /**
   * Returns whether a given index is inclusively between the ends
   * @param {number} index The index to test
   * @private
   */


  indexIsInRange_(index) {
    return index >= 0 && index < this.adapter_.getTabListLength();
  }
  /**
   * Returns the view's RTL property
   * @return {boolean}
   * @private
   */


  isRTL_() {
    return this.adapter_.isRTL();
  }
  /**
   * Scrolls the tab at the given index into view for left-to-right useragents
   * @param {number} index The index of the tab to scroll into view
   * @private
   */


  scrollIntoView_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }
  /**
   * Scrolls the tab at the given index into view in RTL
   * @param {number} index The tab index to make visible
   * @private
   */


  scrollIntoViewRTL_(index) {
    const scrollPosition = this.adapter_.getScrollPosition();
    const barWidth = this.adapter_.getOffsetWidth();
    const tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
    const scrollWidth = this.adapter_.getScrollContentWidth();
    const nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);

    if (!this.indexIsInRange_(nextIndex)) {
      return;
    }

    const scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
    this.adapter_.incrementScroll(scrollIncrement);
  }

}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @extends {MDCComponent<!MDCTabBarFoundation>}
 * @final
 */

class MDCTabBar extends MDCComponent {
  /**
   * @param {...?} args
   */
  constructor(...args) {
    super(...args);
    /** @private {!Array<!MDCTab>} */

    this.tabList_;
    /** @type {(function(!Element): !MDCTab)} */

    this.tabFactory_;
    /** @private {?MDCTabScroller} */

    this.tabScroller_;
    /** @type {(function(!Element): !MDCTabScroller)} */

    this.tabScrollerFactory_;
    /** @private {?function(?Event): undefined} */

    this.handleTabInteraction_;
    /** @private {?function(?Event): undefined} */

    this.handleKeyDown_;
  }
  /**
   * @param {!Element} root
   * @return {!MDCTabBar}
   */


  static attachTo(root) {
    return new MDCTabBar(root);
  }

  set useAutomaticActivation(useAutomaticActivation) {
    this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
  }
  /**
   * @param {(function(!Element): !MDCTab)=} tabFactory A function which creates a new MDCTab
   * @param {(function(!Element): !MDCTabScroller)=} tabScrollerFactory A function which creates a new MDCTabScroller
   */


  initialize(tabFactory = el => new MDCTab(el), tabScrollerFactory = el => new MDCTabScroller(el)) {
    this.tabFactory_ = tabFactory;
    this.tabScrollerFactory_ = tabScrollerFactory;
    this.tabList_ = this.getTabElements_().map(el => this.tabFactory_(el));
    const tabScrollerElement = this.root_.querySelector(MDCTabBarFoundation.strings.TAB_SCROLLER_SELECTOR);

    if (tabScrollerElement) {
      this.tabScroller_ = this.tabScrollerFactory_(tabScrollerElement);
    }
  }

  initialSyncWithDOM() {
    this.handleTabInteraction_ = evt => this.foundation_.handleTabInteraction(evt);

    this.handleKeyDown_ = evt => this.foundation_.handleKeyDown(evt);

    this.root_.addEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.addEventListener('keydown', this.handleKeyDown_);

    for (let i = 0; i < this.tabList_.length; i++) {
      if (this.tabList_[i].active) {
        this.scrollIntoView(i);
        break;
      }
    }
  }

  destroy() {
    super.destroy();
    this.root_.removeEventListener(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
    this.root_.removeEventListener('keydown', this.handleKeyDown_);
    this.tabList_.forEach(tab => tab.destroy());
    this.tabScroller_.destroy();
  }
  /**
   * @return {!MDCTabBarFoundation}
   */


  getDefaultFoundation() {
    return new MDCTabBarFoundation(
    /** @type {!MDCTabBarAdapter} */
    {
      scrollTo: scrollX => this.tabScroller_.scrollTo(scrollX),
      incrementScroll: scrollXIncrement => this.tabScroller_.incrementScroll(scrollXIncrement),
      getScrollPosition: () => this.tabScroller_.getScrollPosition(),
      getScrollContentWidth: () => this.tabScroller_.getScrollContentWidth(),
      getOffsetWidth: () => this.root_.offsetWidth,
      isRTL: () => window.getComputedStyle(this.root_).getPropertyValue('direction') === 'rtl',
      setActiveTab: index => this.foundation_.activateTab(index),
      activateTabAtIndex: (index, clientRect) => this.tabList_[index].activate(clientRect),
      deactivateTabAtIndex: index => this.tabList_[index].deactivate(),
      focusTabAtIndex: index => this.tabList_[index].focus(),
      getTabIndicatorClientRectAtIndex: index => this.tabList_[index].computeIndicatorClientRect(),
      getTabDimensionsAtIndex: index => this.tabList_[index].computeDimensions(),
      getPreviousActiveTabIndex: () => {
        for (let i = 0; i < this.tabList_.length; i++) {
          if (this.tabList_[i].active) {
            return i;
          }
        }

        return -1;
      },
      getFocusedTabIndex: () => {
        const tabElements = this.getTabElements_();
        const activeElement = document.activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTab: tabToFind => this.tabList_.indexOf(tabToFind),
      getTabListLength: () => this.tabList_.length,
      notifyTabActivated: index => this.emit(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {
        index
      }, true)
    });
  }
  /**
   * Activates the tab at the given index
   * @param {number} index The index of the tab
   */


  activateTab(index) {
    this.foundation_.activateTab(index);
  }
  /**
   * Scrolls the tab at the given index into view
   * @param {number} index THe index of the tab
   */


  scrollIntoView(index) {
    this.foundation_.scrollIntoView(index);
  }

  getTabElements_() {
    return [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
  }

}

var tabBar = /*#__PURE__*/Object.freeze({
  MDCTabBar: MDCTabBar,
  MDCTabBarFoundation: MDCTabBarFoundation
});

var TabBar_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.TabBar = exports.Tab = exports.TabIcon = exports.TabLabel = void 0;

  var _get2 = _interopRequireDefault(require$$0);

  var _classCallCheck2 = _interopRequireDefault(require$$0$1);

  var _createClass2 = _interopRequireDefault(require$$1);

  var _possibleConstructorReturn2 = _interopRequireDefault(require$$2);

  var _getPrototypeOf2 = _interopRequireDefault(getPrototypeOf);

  var _inherits2 = _interopRequireDefault(require$$4);

  var _MaterialComponent5 = _interopRequireDefault(require$$5);

  var TabLabel =
  /*#__PURE__*/
  function (_MaterialComponent) {
    (0, _inherits2.default)(TabLabel, _MaterialComponent);

    function TabLabel() {
      var _this;

      (0, _classCallCheck2.default)(this, TabLabel);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabLabel).apply(this, arguments));
      _this.componentName = 'tab__text-label';
      _this.mdcProps = [];
      return _this;
    }

    (0, _createClass2.default)(TabLabel, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({}, props), props.children);
      }
    }]);
    return TabLabel;
  }(_MaterialComponent5.default);

  exports.TabLabel = TabLabel;

  var TabIcon =
  /*#__PURE__*/
  function (_MaterialComponent2) {
    (0, _inherits2.default)(TabIcon, _MaterialComponent2);

    function TabIcon() {
      var _this2;

      (0, _classCallCheck2.default)(this, TabIcon);
      _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabIcon).apply(this, arguments));
      _this2.componentName = 'tab__icon';
      _this2.mdcProps = [];
      return _this2;
    }

    (0, _createClass2.default)(TabIcon, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("span", Object.assign({
          className: "material-icons"
        }, props), props.children);
      }
    }]);
    return TabIcon;
  }(_MaterialComponent5.default);

  exports.TabIcon = TabIcon;

  var Tab =
  /*#__PURE__*/
  function (_MaterialComponent3) {
    (0, _inherits2.default)(Tab, _MaterialComponent3);

    function Tab() {
      var _this3;

      (0, _classCallCheck2.default)(this, Tab);
      _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Tab).apply(this, arguments));
      _this3.componentName = 'tab';
      _this3.mdcProps = ['active'];
      _this3.mdcNotifyProps = ['active'];
      return _this3;
    }

    (0, _createClass2.default)(Tab, [{
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("button", Object.assign({
          class: "mdc-tab",
          role: "tab",
          "aria-selected": "true"
        }, props), (0, _preact.h)("span", {
          class: "mdc-tab__content"
        }, props.children), (0, _preact.h)("span", {
          class: "mdc-tab-indicator ".concat(props.active ? 'mdc-tab-indicator--active' : '')
        }, (0, _preact.h)("span", {
          class: "mdc-tab-indicator__content mdc-tab-indicator__content--underline"
        })), (0, _preact.h)("span", {
          class: "mdc-tab__ripple"
        }));
      }
    }]);
    return Tab;
  }(_MaterialComponent5.default);

  exports.Tab = Tab;

  var TabBar =
  /*#__PURE__*/
  function (_MaterialComponent4) {
    (0, _inherits2.default)(TabBar, _MaterialComponent4);

    function TabBar() {
      var _this4;

      (0, _classCallCheck2.default)(this, TabBar);
      _this4 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TabBar).apply(this, arguments));
      _this4.componentName = 'tab-bar';
      _this4.mdcProps = [];
      _this4.mdcNotifyProps = ['activeTabIndex'];
      return _this4;
    }

    (0, _createClass2.default)(TabBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentDidMount", this).call(this);

        if (this.control) {
          this.MDComponent = new tabBar.MDCTabBar(this.control);
        }

        this.afterComponentDidMount();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TabBar.prototype), "componentWillUnmount", this).call(this);

        if (this.MDComponent) {
          this.MDComponent.destroy();
        }
      }
    }, {
      key: "materialDom",
      value: function materialDom(props) {
        return (0, _preact.h)("div", {
          class: "mdc-tab-bar",
          role: "tablist",
          ref: this.setControlRef
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-area"
        }, (0, _preact.h)("div", {
          class: "mdc-tab-scroller__scroll-content"
        }, props.children))));
      }
    }]);
    return TabBar;
  }(_MaterialComponent5.default);

  exports.TabBar = TabBar;

  var default_1 =
  /*#__PURE__*/
  function (_TabBar) {
    (0, _inherits2.default)(default_1, _TabBar);

    function default_1() {
      (0, _classCallCheck2.default)(this, default_1);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(default_1).apply(this, arguments));
    }

    return default_1;
  }(TabBar);

  exports.default = default_1;
  default_1.Tab = Tab;
  default_1.TabLabel = TabLabel;
  default_1.TabIcon = TabIcon;
});
var TabBar = unwrapExports(TabBar_1);
var TabBar_2 = TabBar_1.TabBar;
var TabBar_3 = TabBar_1.Tab;
var TabBar_4 = TabBar_1.TabIcon;
var TabBar_5 = TabBar_1.TabLabel;

var css = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n.mdc-tab-bar {\n  width: 100%; }";
styleInject(css);

var css$1 = "/*!\n Material Components for the Web\n Copyright (c) 2018 Google Inc.\n License: MIT\n*/\n@-webkit-keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@keyframes mdc-ripple-fg-radius-in {\n  from {\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);\n            transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\n  to {\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@keyframes mdc-ripple-fg-opacity-in {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: 0; }\n  to {\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\n\n@-webkit-keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n@keyframes mdc-ripple-fg-opacity-out {\n  from {\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\n  to {\n    opacity: 0; } }\n\n.mdc-ripple-surface--test-edge-var-bug {\n  --mdc-ripple-surface-test-edge-var: 1px solid #000;\n  visibility: hidden; }\n  .mdc-ripple-surface--test-edge-var-bug::before {\n    border: var(--mdc-ripple-surface-test-edge-var); }\n\n.mdc-tab {\n  font-family: Roboto, sans-serif;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  font-size: 0.875rem;\n  line-height: 2.25rem;\n  font-weight: 500;\n  letter-spacing: 0.08929em;\n  text-decoration: none;\n  text-transform: uppercase;\n  color: rgba(0, 0, 0, 0.54);\n  /* @alternate */\n  color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n  --mdc-ripple-fg-size: 0;\n  --mdc-ripple-left: 0;\n  --mdc-ripple-top: 0;\n  --mdc-ripple-fg-scale: 1;\n  --mdc-ripple-fg-translate-end: 0;\n  --mdc-ripple-fg-translate-start: 0;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  will-change: transform, opacity;\n  display: table-cell;\n  position: relative;\n  box-sizing: border-box;\n  min-width: 160px;\n  min-height: 48px;\n  padding: 0 24px;\n  text-align: center;\n  text-decoration: none;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n  vertical-align: middle; }\n  .mdc-tab .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54)); }\n  .mdc-tab::before, .mdc-tab::after {\n    position: absolute;\n    border-radius: 50%;\n    opacity: 0;\n    pointer-events: none;\n    content: \"\"; }\n  .mdc-tab::before {\n    transition: opacity 15ms linear;\n    z-index: 1; }\n  .mdc-tab.mdc-ripple-upgraded::before {\n    -webkit-transform: scale(var(--mdc-ripple-fg-scale, 1));\n            transform: scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    top: 0;\n    /* @noflip */\n    left: 0;\n    -webkit-transform: scale(0);\n            transform: scale(0);\n    -webkit-transform-origin: center center;\n            transform-origin: center center; }\n  .mdc-tab.mdc-ripple-upgraded--unbounded::after {\n    top: var(--mdc-ripple-top, 0);\n    /* @noflip */\n    left: var(--mdc-ripple-left, 0); }\n  .mdc-tab.mdc-ripple-upgraded--foreground-activation::after {\n    -webkit-animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards;\n            animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards; }\n  .mdc-tab.mdc-ripple-upgraded--foreground-deactivation::after {\n    -webkit-animation: 150ms mdc-ripple-fg-opacity-out;\n            animation: 150ms mdc-ripple-fg-opacity-out;\n    -webkit-transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));\n            transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); }\n  .mdc-tab::before, .mdc-tab::after {\n    background-color: black; }\n  .mdc-tab:hover::before {\n    opacity: 0.04; }\n  .mdc-tab:not(.mdc-ripple-upgraded):focus::before, .mdc-tab.mdc-ripple-upgraded--background-focused::before {\n    transition-duration: 75ms;\n    opacity: 0.12; }\n  .mdc-tab:not(.mdc-ripple-upgraded)::after {\n    transition: opacity 150ms linear; }\n  .mdc-tab:not(.mdc-ripple-upgraded):active::after {\n    transition-duration: 75ms;\n    opacity: 0.16; }\n  .mdc-tab.mdc-ripple-upgraded {\n    --mdc-ripple-fg-opacity: 0.16; }\n  .mdc-tab::before, .mdc-tab::after {\n    top: calc(50% - 100%);\n    /* @noflip */\n    left: calc(50% - 100%);\n    width: 200%;\n    height: 200%; }\n  .mdc-tab.mdc-ripple-upgraded::after {\n    width: var(--mdc-ripple-fg-size, 100%);\n    height: var(--mdc-ripple-fg-size, 100%); }\n  .mdc-tab:hover {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab:hover .mdc-tab__icon {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab:focus {\n    outline: none; }\n  @media screen and (max-width: 600px) {\n    .mdc-tab {\n      min-width: 72px;\n      padding: 0 12px; } }\n  .mdc-tab__icon {\n    display: block;\n    margin: 0 auto;\n    width: 24px;\n    height: 24px; }\n    .mdc-tab-bar--icons-with-text .mdc-tab__icon {\n      margin-top: 4px; }\n  .mdc-tab__icon-text {\n    display: block;\n    margin: 0 auto; }\n  .mdc-tab__icon + .mdc-tab__icon-text {\n    padding-top: 6px; }\n\n.mdc-tab--active {\n  color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active .mdc-tab__icon {\n    color: rgba(0, 0, 0, 0.87);\n    /* @alternate */\n    color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n  .mdc-tab--active::before {\n    bottom: 0; }\n\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 2px;\n  width: calc(100% - 4px); }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:hover .mdc-tab__indicator,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:active .mdc-tab__indicator {\n  visibility: visible; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):hover .mdc-tab__indicator {\n  opacity: .38; }\n\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab--active,\n.mdc-tab-bar:not(.mdc-tab-bar-upgraded) .mdc-tab:not(.mdc-tab--active):active .mdc-tab__indicator {\n  opacity: .87; }\n\n.mdc-tab-bar__indicator,\n.mdc-tab__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n\n.mdc-tab-bar {\n  display: table;\n  position: relative;\n  height: 48px;\n  margin: 0 auto;\n  text-transform: uppercase; }\n\n.mdc-tab-bar__indicator {\n  background-color: rgba(0, 0, 0, 0.87);\n  /* @alternate */\n  background-color: var(--mdc-theme-text-primary-on-light, rgba(0, 0, 0, 0.87));\n  position: absolute;\n  bottom: 0;\n  height: 2px;\n  visibility: hidden;\n  left: 0;\n  width: 100%;\n  -webkit-transform-origin: left top;\n          transform-origin: left top;\n  transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n  will-change: transform; }\n\n.mdc-tab-bar--icons-with-text {\n  height: 72px; }\n\n.mdc-tab-bar-scroller {\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  background-color: inherit;\n  overflow: hidden; }\n  .mdc-tab-bar-scroller__scroll-frame {\n    display: flex;\n    position: relative;\n    flex: 1;\n    justify-content: flex-start;\n    overflow: hidden; }\n    .mdc-tab-bar-scroller__scroll-frame__tabs {\n      transition: -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      transition: transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1), -webkit-transform 240ms 0ms cubic-bezier(0, 0, 0.2, 1);\n      will-change: transform; }\n  .mdc-tab-bar-scroller__indicator {\n    color: rgba(0, 0, 0, 0.54);\n    /* @alternate */\n    color: var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54));\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 48px;\n    cursor: pointer;\n    visibility: hidden; }\n    .mdc-tab-bar-scroller__indicator:hover {\n      color: rgba(0, 0, 0, 0.87);\n      /* @alternate */\n      color: var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87)); }\n    .mdc-tab-bar-scroller__indicator__inner {\n      color: inherit;\n      text-decoration: inherit;\n      cursor: inherit; }\n      .mdc-tab-bar-scroller__indicator__inner:focus {\n        outline-color: inherit; }\n      .mdc-tab-bar-scroller[dir=\"rtl\"] .mdc-tab-bar-scroller__indicator__inner,\n      [dir=\"rtl\"] .mdc-tab-bar-scroller .mdc-tab-bar-scroller__indicator__inner {\n        -webkit-transform: rotate(180deg);\n                transform: rotate(180deg); }\n    .mdc-tab-bar-scroller__indicator__inner:hover {\n      color: inherit; }\n  .mdc-tab-bar-scroller__indicator--enabled {\n    visibility: visible; }";
styleInject(css$1);

var DateLinebreak = function DateLinebreak(_ref) {
  var datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex"
    }
  }, h("div", {
    style: {
      flex: "1"
    }
  }, h("hr", null)), h("div", null, new Date(datetime).toLocaleDateString()), h("div", {
    style: {
      flex: 1
    }
  }, h("hr", null)));
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MessageAligner = function MessageAligner(_ref) {
  var children = _ref.children,
      side = _ref.side,
      style = _ref.style;
  var alignment = side === "left" ? "flex-start" : "flex-end";
  return h("div", {
    style: _objectSpread({
      display: "flex",
      justifyContent: alignment
    }, style)
  }, children);
};

var MessageView = function MessageView(_ref) {
  var message = _ref.message,
      backgroundColor = _ref.backgroundColor,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      backgroundColor: backgroundColor,
      padding: 5,
      margin: 2,
      borderRadius: 15,
      borderColor: '#9E9E9E',
      borderStyle: 'solid',
      borderWidth: 2,
      maxWidth: '100%',
      wordWrap: 'break-word',
      wordBreak: 'break-all',
      minWidth: '30%'
    }
  }, h("div", null, message), h("div", {
    style: {
      fontSize: 10,
      paddingTop: 2,
      textAlign: 'end'
    }
  }, h("i", {
    style: {
      backgroundColor: '#efebe9'
    }
  }, new Date(datetime).toLocaleTimeString())));
};

var SubsequentMessage = function SubsequentMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center",
      marginLeft: 45
    }
  }, h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

var style = {
  height: 30,
  width: 40,
  padding: 3,
  borderRadius: 30,
  backgroundColor: 'darkSmoke',
  borderStyle: 'solid',
  borderWidth: 2,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: '#009688',
  borderColor: '#80cbc4'
};

var MessageAvatar = function MessageAvatar(_ref) {
  var _ref$letter = _ref.letter,
      letter = _ref$letter === void 0 ? 'U' : _ref$letter;
  return h("div", {
    style: style
  }, h("div", null, letter.toUpperCase()));
};

var FirstMessage = function FirstMessage(_ref) {
  var message = _ref.message,
      datetime = _ref.datetime,
      letter = _ref.letter,
      local = _ref.local;
  return h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, !local && h(MessageAvatar, {
    letter: letter
  }), h(MessageView, {
    message: message,
    datetime: datetime,
    backgroundColor: "#FFECB3"
  }));
};

/* eslint-disable react/jsx-props-no-spreading */

var MessageObjectMappter = function MessageObjectMappter(props) {
  var order = props.order,
      dateSpace = props.dateSpace;
  return h("div", null, dateSpace && h(DateLinebreak, props), h(MessageAligner, props, order === 'F' ? h(FirstMessage, props) : h(SubsequentMessage, props)));
};

var useMessageSorter = function useMessageSorter(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      sortedMessages = _useState2[0],
      setSortedMessages = _useState2[1];

  p(function () {
    setSortedMessages(messages.sort(function (a, b) {
      return a.datetime - b.datetime;
    }));
  }, [messages]);
  return {
    sortedMessages: sortedMessages
  };
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useMessagesMapper = function useMessagesMapper(messages) {
  var _useState = v(messages),
      _useState2 = _slicedToArray(_useState, 2),
      mappedMessages = _useState2[0],
      setMappedMessages = _useState2[1];

  var mapMessages = function mapMessages() {
    var localSide = "right";
    var remoteSide = "left";

    if (messages.length === 0) {
      return [];
    }

    var email = messages[0].from;
    var lastDatetime = messages[0].datetime;
    return messages.map(function (m, i) {
      if (i === 0 && m.local) {
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i === 0 && !m.local) {
        var letter = m.from[0] !== undefined ? m.from[0] : "";
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: letter
        });
      }

      if (i > 0 && email === m.from && m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "S",
            dateSpace: true
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "S",
          dateSpace: false
        });
      }

      if (i > 0 && email !== m.from && m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: localSide,
            order: "F",
            dateSpace: false
          });
        }

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: localSide,
          order: "F",
          dateSpace: true
        });
      }

      if (i > 0 && email === m.from && !m.local) {
        if (new Date(lastDatetime).getDate() !== new Date(m.datetime).getDate()) {
          var _letter2 = m.from[0] !== undefined ? m.from[0] : "";

          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "S",
            dateSpace: true,
            letter: _letter2
          });
        }

        var _letter = m.from[0] !== undefined ? m.from[0] : "";

        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "S",
          dateSpace: false,
          letter: _letter
        });
      }

      if (i > 0 && email !== m.from && !m.local) {
        if (new Date(lastDatetime).getDate() === new Date(m.datetime).getDate()) {
          var _letter4 = m.from[0] !== undefined ? m.from[0] : "";

          email = m.from;
          lastDatetime = m.datetime;
          return _objectSpread$1({}, m, {
            side: remoteSide,
            order: "F",
            dateSpace: false,
            letter: _letter4
          });
        }

        var _letter3 = m.from[0] !== undefined ? m.from[0] : "";

        email = m.from;
        lastDatetime = m.datetime;
        return _objectSpread$1({}, m, {
          side: remoteSide,
          order: "F",
          dateSpace: true,
          letter: _letter3
        });
      }

      return null;
    });
  };

  p(function () {
    setMappedMessages(mapMessages());
  }, [messages]);
  return {
    mappedMessages: mappedMessages
  };
};

var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
});

var MessageCollectionView = function MessageCollectionView(_ref) {
  var messages = _ref.messages;

  if (messages.length > 0) {
    return messages.map(function (message, i) {
      return h(MessageObjectMappter, _extends_1({}, message, {
        key: i
      }));
    });
  }

  return null;
};

/* eslint-disable react/no-deprecated */

var MessageViewScroller = function MessageViewScroller(_ref) {
  var children = _ref.children;
  return h("div", {
    style: {
      transform: "rotate(180deg)",
      height: "85%",
      backgroundColor: "#edeff2",
      overflow: "scroll",
      width: "100%"
    }
  }, h("div", {
    style: {
      transform: "rotate(180deg)"
    }
  }, children));
};

var MessageEditorDisplayer = function MessageEditorDisplayer(_ref) {
  var onMessageChange = _ref.onMessageChange,
      message = _ref.message,
      sendMessage = _ref.sendMessage,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 0 : _ref$id,
      disabled = _ref.disabled;
  return h("div", {
    style: {
      display: 'flex'
    }
  }, h("input", {
    style: {
      flex: 1
    },
    "data-testid": "message".concat(id),
    onInput: onMessageChange,
    value: message,
    name: "message",
    type: "text",
    placeholder: "Enter message text"
  }), h("div", {
    style: {
      display: 'flex'
    }
  }, h("button", {
    "data-testid": "sendMessage".concat(id),
    disabled: message === '' || disabled,
    style: {
      marginLeft: 2,
      width: '100%'
    },
    onClick: sendMessage
  }, h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, h("path", {
    d: "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"
  }), h("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  })))));
};

/* eslint-disable no-shadow */

var MessagesDisplayer = function MessagesDisplayer(_ref) {
  var messages = _ref.messages,
      socket = _ref.socket,
      id = _ref.id,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage,
      handleMessageChange = _ref.handleMessageChange;

  var _useMessageSorter = useMessageSorter(messages),
      sortedMessages = _useMessageSorter.sortedMessages;

  var _useMessageMapper = useMessagesMapper(sortedMessages),
      mappedMessages = _useMessageMapper.mappedMessages;

  return [h(MessageViewScroller, null, h(MessageCollectionView, {
    messages: mappedMessages
  })), h(MessageEditorDisplayer, {
    disabled: socket === null,
    id: id,
    message: messageText,
    sendMessage: sendMessage,
    onMessageChange: handleMessageChange
  })];
};

var css$2 = ".chip{\r\n    background-color: darkgrey;\r\n    color: white;\r\n    width: 20px;\r\n    height: 20px;\r\n    border-radius: 10px;\r\n   line-height: 20px;\r\n}\r\n\r\n.media-height{\r\nheight: 100%;\r\n}\r\n\r\n\r\n.root{\r\n    padding: 3px;\r\n    margin-left: 5px;\r\n    margin-bottom: 5px;\r\n    box-shadow: 0 3px 3px -2px rgba(0,0,0,.2), 0 3px 4px 0 rgba(0,0,0,.14), 0 1px 8px 0 rgba(0,0,0,.12);\r\n}\r\n\r\n.tab-bar{\r\n    padding: 0;\r\n    width: 50%;\r\n    display: flex ;\r\n    justify-content: center;\r\n  \r\n    \r\n}";
styleInject(css$2);

var ChatUser = function ChatUser(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      socket = _ref.socket,
      errors = _ref.errors,
      messages = _ref.messages,
      handleMessageChange = _ref.handleMessageChange,
      messageText = _ref.messageText,
      sendMessage = _ref.sendMessage;
  return h("div", {
    className: "root",
    style: {
      height: "97%",
      width: "50%"
    }
  }, h(MessagesDisplayer, {
    errors: errors,
    socket: socket,
    messages: messages,
    handleMessageChange: handleMessageChange,
    messageText: messageText,
    sendMessage: sendMessage
  }));
};

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

var useSocketMessaging = function useSocketMessaging(_ref) {
  var socket = _ref.socket,
      targetName = _ref.targetName;

  var _useState = v(''),
      _useState2 = _slicedToArray(_useState, 2),
      messageText = _useState2[0],
      setMessageText = _useState2[1];

  var _useState3 = v(null),
      _useState4 = _slicedToArray(_useState3, 2),
      messageRecieved = _useState4[0],
      setMessageRecieved = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      messageSent = _useState6[0],
      setMessageSent = _useState6[1];

  var _useState7 = v(false),
      _useState8 = _slicedToArray(_useState7, 2),
      connected = _useState8[0],
      setConnected = _useState8[1];

  var _useState9 = v([]),
      _useState10 = _slicedToArray(_useState9, 2),
      errors = _useState10[0],
      setError = _useState10[1];

  var sendMessage = function sendMessage() {
    var datetime = new Date().getTime();
    socket.emit("text_message", {
      reciever: targetName,
      message: messageText,
      datetime: datetime
    });
    setMessageSent({
      reciever: targetName,
      datetime: datetime,
      message: messageText
    });
    setMessageText('');
  };

  var handleMessageChange = function handleMessageChange(e) {
    setMessageText(e.target.value);
  };

  p(function () {
    if (socket !== null) {
      socket.on("text_message", function (data) {
        var sender = data.sender,
            message = data.message,
            datetime = data.datetime;
        setMessageRecieved({
          sender: sender,
          message: message,
          datetime: datetime
        });
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("disconnect", function () {
        setConnected(false);
      });
      socket.on('error', function (error) {
        setError([].concat(toConsumableArray(errors), [error]));
      });
    }
  });
  return {
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    handleMessageChange: handleMessageChange,
    errors: errors,
    connected: connected
  };
};

var useChatLog = function useChatLog(_ref) {
  var name = _ref.name,
      messageRecieved = _ref.messageRecieved,
      messageSent = _ref.messageSent;

  var _useState = v([]),
      _useState2 = _slicedToArray(_useState, 2),
      messages = _useState2[0],
      setMessages = _useState2[1];

  var saveToLocalStorage = function saveToLocalStorage(m, key) {
    var persistedMessages = JSON.parse(localStorage.getItem(key)) === null ? [m] : [].concat(toConsumableArray(JSON.parse(localStorage.getItem(key))), [m]);
    localStorage.setItem(key, JSON.stringify(persistedMessages));
    return persistedMessages;
  }; // componentDidMount


  p(function () {
    setMessages(JSON.parse(localStorage.getItem(name)) === null ? [] : toConsumableArray(JSON.parse(localStorage.getItem(name))));
  }, []); // saveRemoteMessage

  p(function () {
    if (messageRecieved !== null) {
      var datetime = messageRecieved.datetime,
          message = messageRecieved.message,
          sender = messageRecieved.sender;
      var local = false;
      setMessages(saveToLocalStorage({
        message: message,
        from: sender,
        local: local,
        datetime: datetime,
        to: name
      }, name));
    }
  }, [messageRecieved]); // saveLocalMessage

  p(function () {
    if (messageSent !== null) {
      var datetime = messageSent.datetime,
          message = messageSent.message,
          reciever = messageSent.reciever;
      var local = true;
      var from = name;
      setMessages(saveToLocalStorage({
        message: message,
        from: from,
        local: local,
        datetime: datetime,
        to: reciever
      }, name));
    }
  }, [messageSent]);
  return {
    messages: messages
  };
};

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

var parseuri = function parseuri(str) {
  var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');

  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }

  var m = re.exec(str || ''),
      uri = {},
      i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }

  return uri;
};

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h$1 = m * 60;
var d = h$1 * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h$1) {
    return plural(ms, msAbs, h$1, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set `diff` timestamp

      const curr = Number(new Date());
      const ms$$1 = curr - (prevTime || curr);
      self.diff = ms$$1;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    const index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      const instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

var common = setup;

var browser = createCommonjsModule(function (module, exports) {
  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log(...args) {
    // This hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return typeof console === 'object' && console.log && console.log(...args);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    let r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
});
var browser_1 = browser.log;
var browser_2 = browser.formatArgs;
var browser_3 = browser.save;
var browser_4 = browser.load;
var browser_5 = browser.useColors;
var browser_6 = browser.storage;
var browser_7 = browser.colors;

/**
 * Module dependencies.
 */

var debug = browser('socket.io-client:url');
/**
 * Module exports.
 */

var url_1 = url;
/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc) {
  var obj = uri; // default to window.location

  loc = loc || typeof location !== 'undefined' && location;
  if (null == uri) uri = loc.protocol + '//' + loc.host; // relative path support

  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);

      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    } // parse


    debug('parse %s', uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';
  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host; // define unique id

  obj.id = obj.protocol + '://' + host + ':' + obj.port; // define href

  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
  return obj;
}

/**
 * Helpers.
 */
var s$1 = 1000;
var m$1 = s$1 * 60;
var h$2 = m$1 * 60;
var d$1 = h$2 * 24;
var y$1 = d$1 * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse$1(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;

    case 'days':
    case 'day':
    case 'd':
      return n * d$1;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort$1(ms) {
  if (ms >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }

  if (ms >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }

  if (ms >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }

  if (ms >= s$1) {
    return Math.round(ms / s$1) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong$1(ms) {
  return plural$1(ms, d$1, 'day') || plural$1(ms, h$2, 'hour') || plural$1(ms, m$1, 'minute') || plural$1(ms, s$1, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = ms$1;
  /**
   * Active `debug` instances.
   */

  exports.instances = [];
  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};
  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0,
        i;

    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */


  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // disabled?
      if (!debug.enabled) return;
      var self = debug; // set `diff` timestamp

      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr; // turn the `arguments` into a proper Array

      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      } // apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];

        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // apply env-specific formatting (colors, etc.)

      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy; // env-specific initialization logic for debug instances

    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    exports.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = exports.instances.indexOf(this);

    if (index !== -1) {
      exports.instances.splice(index, 1);
      return true;
    } else {
      return false;
    }
  }
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */


  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < exports.instances.length; i++) {
      var instance = exports.instances[i];
      instance.enabled = exports.enabled(instance.namespace);
    }
  }
  /**
   * Disable debug output.
   *
   * @api public
   */


  function disable() {
    exports.enable('');
  }
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i, len;

    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */


  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
});
var debug_1 = debug$1.coerce;
var debug_2 = debug$1.disable;
var debug_3 = debug$1.enable;
var debug_4 = debug$1.enabled;
var debug_5 = debug$1.humanize;
var debug_6 = debug$1.instances;
var debug_7 = debug$1.names;
var debug_8 = debug$1.skips;
var debug_9 = debug$1.formatters;

var browser$1 = createCommonjsModule(function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  exports = module.exports = debug$1;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */


  exports.formatters.j = function (v$$1) {
    try {
      return JSON.stringify(v$$1);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors) return;
    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if ('%%' === match) return;
      index++;

      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    var r;

    try {
      r = exports.storage.debug;
    } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */


  exports.enable(load());
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});
var browser_1$1 = browser$1.log;
var browser_2$1 = browser$1.formatArgs;
var browser_3$1 = browser$1.save;
var browser_4$1 = browser$1.load;
var browser_5$1 = browser$1.useColors;
var browser_6$1 = browser$1.storage;
var browser_7$1 = browser$1.colors;

var componentEmitter = createCommonjsModule(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1),
        callbacks = this._callbacks['$' + event];

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
});

var toString = {}.toString;

var isarray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;
var isArray = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}
Buffer.isBuffer = isBuffer;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read$$1(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read$$1(arr, i + j) !== read$$1(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write$$1(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var isBuffer$1 = isBuf;
var withNativeBuffer = typeof Buffer === 'function' && typeof isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */


function isBuf(obj) {
  return withNativeBuffer && isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
}

/*global Blob,File*/

/**
 * Module requirements
 */

var toString$2 = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$2.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString$2.call(File) === '[object FileConstructor]';
/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

var deconstructPacket = function (packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuffer$1(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (isarray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};

    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }

    return newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */


var reconstructPacket = function (packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isarray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}
/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */


var removeBlobs = function (data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj; // convert any blob

    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
      pendingBlobs++; // async filereader

      var fileReader = new FileReader();

      fileReader.onload = function () {
        // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        } else {
          bloblessData = this.result;
        } // if nothing pending its callback time


        if (! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isarray(obj)) {
      // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuffer$1(obj)) {
      // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;

  _removeBlobs(bloblessData);

  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

var binary = {
  deconstructPacket: deconstructPacket,
  reconstructPacket: reconstructPacket,
  removeBlobs: removeBlobs
};

var socket_ioParser = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser$1('socket.io-parser');
  /**
   * Protocol version.
   *
   * @api public
   */

  exports.protocol = 4;
  /**
   * Packet types.
   *
   * @api public
   */

  exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
  /**
   * Packet type `connect`.
   *
   * @api public
   */

  exports.CONNECT = 0;
  /**
   * Packet type `disconnect`.
   *
   * @api public
   */

  exports.DISCONNECT = 1;
  /**
   * Packet type `event`.
   *
   * @api public
   */

  exports.EVENT = 2;
  /**
   * Packet type `ack`.
   *
   * @api public
   */

  exports.ACK = 3;
  /**
   * Packet type `error`.
   *
   * @api public
   */

  exports.ERROR = 4;
  /**
   * Packet type 'binary event'
   *
   * @api public
   */

  exports.BINARY_EVENT = 5;
  /**
   * Packet type `binary ack`. For acks with binary arguments.
   *
   * @api public
   */

  exports.BINARY_ACK = 6;
  /**
   * Encoder constructor.
   *
   * @api public
   */

  exports.Encoder = Encoder;
  /**
   * Decoder constructor.
   *
   * @api public
   */

  exports.Decoder = Decoder;
  /**
   * A socket.io Encoder instance
   *
   * @api public
   */

  function Encoder() {}

  var ERROR_PACKET = exports.ERROR + '"encode error"';
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   * @param {Function} callback - function to handle encodings (likely engine.write)
   * @return Calls callback with Array of encodings
   * @api public
   */

  Encoder.prototype.encode = function (obj, callback) {
    debug('encoding packet %j', obj);

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      encodeAsBinary(obj, callback);
    } else {
      var encoding = encodeAsString(obj);
      callback([encoding]);
    }
  };
  /**
   * Encode packet as string.
   *
   * @param {Object} packet
   * @return {String} encoded
   * @api private
   */


  function encodeAsString(obj) {
    // first is type
    var str = '' + obj.type; // attachments if we have them

    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
      str += obj.attachments + '-';
    } // if we have a namespace other than `/`
    // we append it followed by a comma `,`


    if (obj.nsp && '/' !== obj.nsp) {
      str += obj.nsp + ',';
    } // immediately followed by the id


    if (null != obj.id) {
      str += obj.id;
    } // json data


    if (null != obj.data) {
      var payload = tryStringify(obj.data);

      if (payload !== false) {
        str += payload;
      } else {
        return ERROR_PACKET;
      }
    }

    debug('encoded %j as %s', obj, str);
    return str;
  }

  function tryStringify(str) {
    try {
      return JSON.stringify(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   *
   * @param {Object} packet
   * @return {Buffer} encoded
   * @api private
   */


  function encodeAsBinary(obj, callback) {
    function writeEncoding(bloblessData) {
      var deconstruction = binary.deconstructPacket(bloblessData);
      var pack = encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      callback(buffers); // write all the buffers
    }

    binary.removeBlobs(obj, writeEncoding);
  }
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   * @api public
   */


  function Decoder() {
    this.reconstructor = null;
  }
  /**
   * Mix in `Emitter` with Decoder.
   */


  componentEmitter(Decoder.prototype);
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   * @return {Object} packet
   * @api public
   */

  Decoder.prototype.add = function (obj) {
    var packet;

    if (typeof obj === 'string') {
      packet = decodeString(obj);

      if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
        // binary packet's json
        this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

        if (this.reconstructor.reconPack.attachments === 0) {
          this.emit('decoded', packet);
        }
      } else {
        // non-binary full packet
        this.emit('decoded', packet);
      }
    } else if (isBuffer$1(obj) || obj.base64) {
      // raw binary data
      if (!this.reconstructor) {
        throw new Error('got binary data when not reconstructing a packet');
      } else {
        packet = this.reconstructor.takeBinaryData(obj);

        if (packet) {
          // received final buffer
          this.reconstructor = null;
          this.emit('decoded', packet);
        }
      }
    } else {
      throw new Error('Unknown type: ' + obj);
    }
  };
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   * @api private
   */


  function decodeString(str) {
    var i = 0; // look up type

    var p$$1 = {
      type: Number(str.charAt(0))
    };

    if (null == exports.types[p$$1.type]) {
      return error('unknown packet type ' + p$$1.type);
    } // look up attachments if type binary


    if (exports.BINARY_EVENT === p$$1.type || exports.BINARY_ACK === p$$1.type) {
      var buf = '';

      while (str.charAt(++i) !== '-') {
        buf += str.charAt(i);
        if (i == str.length) break;
      }

      if (buf != Number(buf) || str.charAt(i) !== '-') {
        throw new Error('Illegal attachments');
      }

      p$$1.attachments = Number(buf);
    } // look up namespace (if any)


    if ('/' === str.charAt(i + 1)) {
      p$$1.nsp = '';

      while (++i) {
        var c = str.charAt(i);
        if (',' === c) break;
        p$$1.nsp += c;
        if (i === str.length) break;
      }
    } else {
      p$$1.nsp = '/';
    } // look up id


    var next = str.charAt(i + 1);

    if ('' !== next && Number(next) == next) {
      p$$1.id = '';

      while (++i) {
        var c = str.charAt(i);

        if (null == c || Number(c) != c) {
          --i;
          break;
        }

        p$$1.id += str.charAt(i);
        if (i === str.length) break;
      }

      p$$1.id = Number(p$$1.id);
    } // look up json data


    if (str.charAt(++i)) {
      var payload = tryParse(str.substr(i));
      var isPayloadValid = payload !== false && (p$$1.type === exports.ERROR || isarray(payload));

      if (isPayloadValid) {
        p$$1.data = payload;
      } else {
        return error('invalid payload');
      }
    }

    debug('decoded %s as %j', str, p$$1);
    return p$$1;
  }

  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  /**
   * Deallocates a parser's resources
   *
   * @api public
   */


  Decoder.prototype.destroy = function () {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  };
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   * @api private
   */


  function BinaryReconstructor(packet) {
    this.reconPack = packet;
    this.buffers = [];
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   * @api private
   */


  BinaryReconstructor.prototype.takeBinaryData = function (binData) {
    this.buffers.push(binData);

    if (this.buffers.length === this.reconPack.attachments) {
      // done with buffer list
      var packet = binary.reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }

    return null;
  };
  /**
   * Cleans up binary packet reconstruction variables.
   *
   * @api private
   */


  BinaryReconstructor.prototype.finishedReconstruction = function () {
    this.reconPack = null;
    this.buffers = [];
  };

  function error(msg) {
    return {
      type: exports.ERROR,
      data: 'parser error: ' + msg
    };
  }
});
var socket_ioParser_1 = socket_ioParser.protocol;
var socket_ioParser_2 = socket_ioParser.types;
var socket_ioParser_3 = socket_ioParser.CONNECT;
var socket_ioParser_4 = socket_ioParser.DISCONNECT;
var socket_ioParser_5 = socket_ioParser.EVENT;
var socket_ioParser_6 = socket_ioParser.ACK;
var socket_ioParser_7 = socket_ioParser.ERROR;
var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
var socket_ioParser_10 = socket_ioParser.Encoder;
var socket_ioParser_11 = socket_ioParser.Decoder;

var hasCors = createCommonjsModule(function (module) {
  /**
   * Module exports.
   *
   * Logic borrowed from Modernizr:
   *
   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
   */
  try {
    module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
    module.exports = false;
  }
});

var xmlhttprequest = function (opts) {
  var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

  var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217

  var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE

  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
      return new XMLHttpRequest();
    }
  } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example


  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) {}
  }
};

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */
var keys = Object.keys || function keys(obj) {
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }

  return arr;
};

var toString$3 = {}.toString;

var isarray$1 = Array.isArray || function (arr) {
  return toString$3.call(arr) == '[object Array]';
};

/* global Blob File */

/*
 * Module requirements.
 */

var toString$4 = Object.prototype.toString;
var withNativeBlob$1 = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$4.call(Blob) === '[object BlobConstructor]';
var withNativeFile$1 = typeof File === 'function' || typeof File !== 'undefined' && toString$4.call(File) === '[object FileConstructor]';
/**
 * Module exports.
 */

var hasBinary2 = hasBinary;
/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isarray$1(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (typeof Buffer === 'function' && isBuffer && isBuffer(obj) || typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
    return true;
  } // see: https://github.com/Automattic/has-binary/pull/4


  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */
var arraybuffer_slice = function (arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) {
    return arraybuffer.slice(start, end);
  }

  if (start < 0) {
    start += bytes;
  }

  if (end < 0) {
    end += bytes;
  }

  if (end > bytes) {
    end = bytes;
  }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);

  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }

  return result.buffer;
};

var after_1 = after;

function after(count, callback, err_cb) {
  var bail = false;
  err_cb = err_cb || noop;
  proxy.count = count;
  return count === 0 ? callback() : proxy;

  function proxy(err, result) {
    if (proxy.count <= 0) {
      throw new Error('after called too many times');
    }

    --proxy.count; // after first error, rest are passed to err_cb

    if (err) {
      bail = true;
      callback(err); // future error callbacks will go to error handler

      callback = err_cb;
    } else if (proxy.count === 0 && !bail) {
      callback(null, result);
    }
  }
}

function noop() {}

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode

function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  var value;
  var extra;

  while (counter < length) {
    value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
} // Taken from https://mths.be/punycode


function ucs2encode(array) {
  var length = array.length;
  var index = -1;
  var value;
  var output = '';

  while (++index < length) {
    value = array[index];

    if (value > 0xFFFF) {
      value -= 0x10000;
      output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      value = 0xDC00 | value & 0x3FF;
    }

    output += stringFromCharCode(value);
  }

  return output;
}

function checkScalarValue(codePoint, strict) {
  if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    if (strict) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }

    return false;
  }

  return true;
}
/*--------------------------------------------------------------------------*/


function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
}

function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 0xFFFFFF80) == 0) {
    // 1-byte sequence
    return stringFromCharCode(codePoint);
  }

  var symbol = '';

  if ((codePoint & 0xFFFFF800) == 0) {
    // 2-byte sequence
    symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
  } else if ((codePoint & 0xFFFF0000) == 0) {
    // 3-byte sequence
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 0xFFFD;
    }

    symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 0xFFE00000) == 0) {
    // 4-byte sequence
    symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }

  symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
  return symbol;
}

function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length = codePoints.length;
  var index = -1;
  var codePoint;
  var byteString = '';

  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint, strict);
  }

  return byteString;
}
/*--------------------------------------------------------------------------*/


function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error('Invalid byte index');
  }

  var continuationByte = byteArray[byteIndex] & 0xFF;
  byteIndex++;

  if ((continuationByte & 0xC0) == 0x80) {
    return continuationByte & 0x3F;
  } // If we end up here, its not a continuation byte


  throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;

  if (byteIndex > byteCount) {
    throw Error('Invalid byte index');
  }

  if (byteIndex == byteCount) {
    return false;
  } // Read first byte


  byte1 = byteArray[byteIndex] & 0xFF;
  byteIndex++; // 1-byte sequence (no continuation bytes)

  if ((byte1 & 0x80) == 0) {
    return byte1;
  } // 2-byte sequence


  if ((byte1 & 0xE0) == 0xC0) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 0x1F) << 6 | byte2;

    if (codePoint >= 0x80) {
      return codePoint;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 3-byte sequence (may include unpaired surrogates)


  if ((byte1 & 0xF0) == 0xE0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;

    if (codePoint >= 0x0800) {
      return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 4-byte sequence


  if ((byte1 & 0xF8) == 0xF0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;

    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      return codePoint;
    }
  }

  throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;

function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;

  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }

  return ucs2encode(codePoints);
}

var utf8 = {
  version: '2.1.2',
  encode: utf8encode,
  decode: utf8decode
};

var base64Arraybuffer = createCommonjsModule(function (module, exports) {
  /*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
  (function () {

    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index.

    var lookup = new Uint8Array(256);

    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }

    exports.encode = function (arraybuffer) {
      var bytes = new Uint8Array(arraybuffer),
          i,
          len = bytes.length,
          base64 = "";

      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }

      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }

      return base64;
    };

    exports.decode = function (base64) {
      var bufferLength = base64.length * 0.75,
          len = base64.length,
          i,
          p$$1 = 0,
          encoded1,
          encoded2,
          encoded3,
          encoded4;

      if (base64[base64.length - 1] === "=") {
        bufferLength--;

        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }

      var arraybuffer = new ArrayBuffer(bufferLength),
          bytes = new Uint8Array(arraybuffer);

      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p$$1++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p$$1++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p$$1++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }

      return arraybuffer;
    };
  })();
});
var base64Arraybuffer_1 = base64Arraybuffer.encode;
var base64Arraybuffer_2 = base64Arraybuffer.decode;

/**
 * Create a blob builder even when vendor prefixes exist
 */
var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : false;
/**
 * Check if Blob constructor is supported
 */

var blobSupported = function () {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */


var blobSupportsArrayBufferView = blobSupported && function () {
  try {
    var b = new Blob([new Uint8Array([1, 2])]);
    return b.size === 2;
  } catch (e) {
    return false;
  }
}();
/**
 * Check if BlobBuilder is supported
 */


var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function (chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer; // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer

      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};
  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function (part) {
    bb.append(part);
  });
  return options.type ? bb.getBlob(options.type) : bb.getBlob();
}

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
}

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

var blob = function () {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
}();

var browser$2 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var base64encoder;

  if (typeof ArrayBuffer !== 'undefined') {
    base64encoder = base64Arraybuffer;
  }
  /**
   * Check if we are running an android browser. That requires us to use
   * ArrayBuffer with polling transports...
   *
   * http://ghinda.net/jpeg-blob-ajax-android/
   */


  var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
  /**
   * Check if we are running in PhantomJS.
   * Uploading a Blob with PhantomJS does not work correctly, as reported here:
   * https://github.com/ariya/phantomjs/issues/11395
   * @type boolean
   */

  var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
  /**
   * When true, avoids using Blobs to encode payloads.
   * @type boolean
   */

  var dontSendBlobs = isAndroid || isPhantomJS;
  /**
   * Current protocol version.
   */

  exports.protocol = 3;
  /**
   * Packet types.
   */

  var packets = exports.packets = {
    open: 0 // non-ws
    ,
    close: 1 // non-ws
    ,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = keys(packets);
  /**
   * Premade error packet.
   */

  var err = {
    type: 'error',
    data: 'parser error'
  };
  /**
   * Create a blob api even for blob builder when vendor prefixes exist
   */

  /**
   * Encodes a packet.
   *
   *     <packet type id> [ <data> ]
   *
   * Example:
   *
   *     5hello world
   *     3
   *     4
   *
   * Binary is encoded in an identical principle
   *
   * @api private
   */

  exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = false;
    }

    if (typeof utf8encode === 'function') {
      callback = utf8encode;
      utf8encode = null;
    }

    var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

    if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
      return encodeArrayBuffer(packet, supportsBinary, callback);
    } else if (typeof blob !== 'undefined' && data instanceof blob) {
      return encodeBlob(packet, supportsBinary, callback);
    } // might be an object with { base64: true, data: dataAsBase64String }


    if (data && data.base64) {
      return encodeBase64Object(packet, callback);
    } // Sending data as a utf-8 string


    var encoded = packets[packet.type]; // data fragment is optional

    if (undefined !== packet.data) {
      encoded += utf8encode ? utf8.encode(String(packet.data), {
        strict: false
      }) : String(packet.data);
    }

    return callback('' + encoded);
  };

  function encodeBase64Object(packet, callback) {
    // packet data is an object { base64: true, data: dataAsBase64String }
    var message = 'b' + exports.packets[packet.type] + packet.data.data;
    return callback(message);
  }
  /**
   * Encode packet helpers for binary types
   */


  function encodeArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var data = packet.data;
    var contentArray = new Uint8Array(data);
    var resultBuffer = new Uint8Array(1 + data.byteLength);
    resultBuffer[0] = packets[packet.type];

    for (var i = 0; i < contentArray.length; i++) {
      resultBuffer[i + 1] = contentArray[i];
    }

    return callback(resultBuffer.buffer);
  }

  function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    var fr = new FileReader();

    fr.onload = function () {
      exports.encodePacket({
        type: packet.type,
        data: fr.result
      }, supportsBinary, true, callback);
    };

    return fr.readAsArrayBuffer(packet.data);
  }

  function encodeBlob(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return exports.encodeBase64Packet(packet, callback);
    }

    if (dontSendBlobs) {
      return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
    }

    var length = new Uint8Array(1);
    length[0] = packets[packet.type];
    var blob$$1 = new blob([length.buffer, packet.data]);
    return callback(blob$$1);
  }
  /**
   * Encodes a packet with binary data in a base64 string
   *
   * @param {Object} packet, has `type` and `data`
   * @return {String} base64 encoded message
   */


  exports.encodeBase64Packet = function (packet, callback) {
    var message = 'b' + exports.packets[packet.type];

    if (typeof blob !== 'undefined' && packet.data instanceof blob) {
      var fr = new FileReader();

      fr.onload = function () {
        var b64 = fr.result.split(',')[1];
        callback(message + b64);
      };

      return fr.readAsDataURL(packet.data);
    }

    var b64data;

    try {
      b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
    } catch (e) {
      // iPhone Safari doesn't let you apply with typed arrays
      var typed = new Uint8Array(packet.data);
      var basic = new Array(typed.length);

      for (var i = 0; i < typed.length; i++) {
        basic[i] = typed[i];
      }

      b64data = String.fromCharCode.apply(null, basic);
    }

    message += btoa(b64data);
    return callback(message);
  };
  /**
   * Decodes a packet. Changes format to Blob if requested.
   *
   * @return {Object} with `type` and `data` (if any)
   * @api private
   */


  exports.decodePacket = function (data, binaryType, utf8decode) {
    if (data === undefined) {
      return err;
    } // String data


    if (typeof data === 'string') {
      if (data.charAt(0) === 'b') {
        return exports.decodeBase64Packet(data.substr(1), binaryType);
      }

      if (utf8decode) {
        data = tryDecode(data);

        if (data === false) {
          return err;
        }
      }

      var type = data.charAt(0);

      if (Number(type) != type || !packetslist[type]) {
        return err;
      }

      if (data.length > 1) {
        return {
          type: packetslist[type],
          data: data.substring(1)
        };
      } else {
        return {
          type: packetslist[type]
        };
      }
    }

    var asArray = new Uint8Array(data);
    var type = asArray[0];
    var rest = arraybuffer_slice(data, 1);

    if (blob && binaryType === 'blob') {
      rest = new blob([rest]);
    }

    return {
      type: packetslist[type],
      data: rest
    };
  };

  function tryDecode(data) {
    try {
      data = utf8.decode(data, {
        strict: false
      });
    } catch (e) {
      return false;
    }

    return data;
  }
  /**
   * Decodes a packet encoded in a base64 string
   *
   * @param {String} base64 encoded message
   * @return {Object} with `type` and `data` (if any)
   */


  exports.decodeBase64Packet = function (msg, binaryType) {
    var type = packetslist[msg.charAt(0)];

    if (!base64encoder) {
      return {
        type: type,
        data: {
          base64: true,
          data: msg.substr(1)
        }
      };
    }

    var data = base64encoder.decode(msg.substr(1));

    if (binaryType === 'blob' && blob) {
      data = new blob([data]);
    }

    return {
      type: type,
      data: data
    };
  };
  /**
   * Encodes multiple messages (payload).
   *
   *     <length>:data
   *
   * Example:
   *
   *     11:hello world2:hi
   *
   * If any contents are binary, they will be encoded as base64 strings. Base64
   * encoded strings are marked with a b before the length specifier
   *
   * @param {Array} packets
   * @api private
   */


  exports.encodePayload = function (packets, supportsBinary, callback) {
    if (typeof supportsBinary === 'function') {
      callback = supportsBinary;
      supportsBinary = null;
    }

    var isBinary = hasBinary2(packets);

    if (supportsBinary && isBinary) {
      if (blob && !dontSendBlobs) {
        return exports.encodePayloadAsBlob(packets, callback);
      }

      return exports.encodePayloadAsArrayBuffer(packets, callback);
    }

    if (!packets.length) {
      return callback('0:');
    }

    function setLengthHeader(message) {
      return message.length + ':' + message;
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
        doneCallback(null, setLengthHeader(message));
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(results.join(''));
    });
  };
  /**
   * Async array map using after
   */


  function map(ary, each, done) {
    var result = new Array(ary.length);
    var next = after_1(ary.length, done);

    var eachWithIndex = function (i, el, cb) {
      each(el, function (error, msg) {
        result[i] = msg;
        cb(error, result);
      });
    };

    for (var i = 0; i < ary.length; i++) {
      eachWithIndex(i, ary[i], next);
    }
  }
  /*
   * Decodes data when a payload is maybe expected. Possible binary contents are
   * decoded from their base64 representation
   *
   * @param {String} data, callback method
   * @api public
   */


  exports.decodePayload = function (data, binaryType, callback) {
    if (typeof data !== 'string') {
      return exports.decodePayloadAsBinary(data, binaryType, callback);
    }

    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var packet;

    if (data === '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    var length = '',
        n,
        msg;

    for (var i = 0, l = data.length; i < l; i++) {
      var chr = data.charAt(i);

      if (chr !== ':') {
        length += chr;
        continue;
      }

      if (length === '' || length != (n = Number(length))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, false);

        if (err.type === packet.type && err.data === packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      } // advance cursor


      i += n;
      length = '';
    }

    if (length !== '') {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }
  };
  /**
   * Encodes multiple messages (payload) as binary.
   *
   * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
   * 255><data>
   *
   * Example:
   * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
   *
   * @param {Array} packets
   * @return {ArrayBuffer} encoded payload
   * @api private
   */


  exports.encodePayloadAsArrayBuffer = function (packets, callback) {
    if (!packets.length) {
      return callback(new ArrayBuffer(0));
    }

    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (data) {
        return doneCallback(null, data);
      });
    }

    map(packets, encodeOne, function (err, encodedPackets) {
      var totalLength = encodedPackets.reduce(function (acc, p$$1) {
        var len;

        if (typeof p$$1 === 'string') {
          len = p$$1.length;
        } else {
          len = p$$1.byteLength;
        }

        return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
      }, 0);
      var resultArray = new Uint8Array(totalLength);
      var bufferIndex = 0;
      encodedPackets.forEach(function (p$$1) {
        var isString = typeof p$$1 === 'string';
        var ab = p$$1;

        if (isString) {
          var view = new Uint8Array(p$$1.length);

          for (var i = 0; i < p$$1.length; i++) {
            view[i] = p$$1.charCodeAt(i);
          }

          ab = view.buffer;
        }

        if (isString) {
          // not true binary
          resultArray[bufferIndex++] = 0;
        } else {
          // true binary
          resultArray[bufferIndex++] = 1;
        }

        var lenStr = ab.byteLength.toString();

        for (var i = 0; i < lenStr.length; i++) {
          resultArray[bufferIndex++] = parseInt(lenStr[i]);
        }

        resultArray[bufferIndex++] = 255;
        var view = new Uint8Array(ab);

        for (var i = 0; i < view.length; i++) {
          resultArray[bufferIndex++] = view[i];
        }
      });
      return callback(resultArray.buffer);
    });
  };
  /**
   * Encode as Blob
   */


  exports.encodePayloadAsBlob = function (packets, callback) {
    function encodeOne(packet, doneCallback) {
      exports.encodePacket(packet, true, true, function (encoded) {
        var binaryIdentifier = new Uint8Array(1);
        binaryIdentifier[0] = 1;

        if (typeof encoded === 'string') {
          var view = new Uint8Array(encoded.length);

          for (var i = 0; i < encoded.length; i++) {
            view[i] = encoded.charCodeAt(i);
          }

          encoded = view.buffer;
          binaryIdentifier[0] = 0;
        }

        var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
        var lenStr = len.toString();
        var lengthAry = new Uint8Array(lenStr.length + 1);

        for (var i = 0; i < lenStr.length; i++) {
          lengthAry[i] = parseInt(lenStr[i]);
        }

        lengthAry[lenStr.length] = 255;

        if (blob) {
          var blob$$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
          doneCallback(null, blob$$1);
        }
      });
    }

    map(packets, encodeOne, function (err, results) {
      return callback(new blob(results));
    });
  };
  /*
   * Decodes data when a payload is maybe expected. Strings are decoded by
   * interpreting each byte as a key code for entries marked to start with 0. See
   * description of encodePayloadAsBinary
   *
   * @param {ArrayBuffer} data, callback method
   * @api public
   */


  exports.decodePayloadAsBinary = function (data, binaryType, callback) {
    if (typeof binaryType === 'function') {
      callback = binaryType;
      binaryType = null;
    }

    var bufferTail = data;
    var buffers = [];

    while (bufferTail.byteLength > 0) {
      var tailArray = new Uint8Array(bufferTail);
      var isString = tailArray[0] === 0;
      var msgLength = '';

      for (var i = 1;; i++) {
        if (tailArray[i] === 255) break; // 310 = char length of Number.MAX_VALUE

        if (msgLength.length > 310) {
          return callback(err, 0, 1);
        }

        msgLength += tailArray[i];
      }

      bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
      msgLength = parseInt(msgLength);
      var msg = arraybuffer_slice(bufferTail, 0, msgLength);

      if (isString) {
        try {
          msg = String.fromCharCode.apply(null, new Uint8Array(msg));
        } catch (e) {
          // iPhone Safari doesn't let you apply to typed arrays
          var typed = new Uint8Array(msg);
          msg = '';

          for (var i = 0; i < typed.length; i++) {
            msg += String.fromCharCode(typed[i]);
          }
        }
      }

      buffers.push(msg);
      bufferTail = arraybuffer_slice(bufferTail, msgLength);
    }

    var total = buffers.length;
    buffers.forEach(function (buffer, i) {
      callback(exports.decodePacket(buffer, binaryType, true), i, total);
    });
  };
});
var browser_1$2 = browser$2.protocol;
var browser_2$2 = browser$2.packets;
var browser_3$2 = browser$2.encodePacket;
var browser_4$2 = browser$2.encodeBase64Packet;
var browser_5$2 = browser$2.decodePacket;
var browser_6$2 = browser$2.decodeBase64Packet;
var browser_7$2 = browser$2.encodePayload;
var browser_8 = browser$2.decodePayload;
var browser_9 = browser$2.encodePayloadAsArrayBuffer;
var browser_10 = browser$2.encodePayloadAsBlob;
var browser_11 = browser$2.decodePayloadAsBinary;

/**
 * Module dependencies.
 */

/**
 * Module exports.
 */

var transport = Transport;
/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport(opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode; // results of ReactNative environment detection

  this.isReactNative = opts.isReactNative; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Transport.prototype);
/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};
/**
 * Opens the transport.
 *
 * @api public
 */


Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};
/**
 * Closes the transport.
 *
 * @api private
 */


Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};
/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */


Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};
/**
 * Called upon open
 *
 * @api private
 */


Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};
/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */


Transport.prototype.onData = function (data) {
  var packet = browser$2.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};
/**
 * Called with a decoded packet.
 */


Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon close.
 *
 * @api private
 */


Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
var encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */


var decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');

  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }

  return qry;
};

var parseqs = {
  encode: encode,
  decode: decode
};

var componentInherit = function (a, b) {
  var fn = function () {};

  fn.prototype = b.prototype;
  a.prototype = new fn();
  a.prototype.constructor = a;
};

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */

function encode$1(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */


function decode$1(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */


function yeast() {
  var now = encode$1(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode$1(seed++);
} //
// Map each character to its index.
//


for (; i < length; i++) map[alphabet[i]] = i; //
// Expose the `yeast`, `encode` and `decode` functions.
//


yeast.encode = encode$1;
yeast.decode = decode$1;
var yeast_1 = yeast;

/**
 * Module dependencies.
 */

var debug$2 = browser('engine.io-client:polling');
/**
 * Module exports.
 */

var polling = Polling;
/**
 * Is XHR2 supported?
 */

var hasXHR2 = function () {
  var XMLHttpRequest = xmlhttprequest;
  var xhr = new XMLHttpRequest({
    xdomain: false
  });
  return null != xhr.responseType;
}();
/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */


function Polling(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(Polling, transport);
/**
 * Transport name.
 */

Polling.prototype.name = 'polling';
/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};
/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */


Polling.prototype.pause = function (onPause) {
  var self = this;
  this.readyState = 'pausing';

  function pause() {
    debug$2('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug$2('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug$2('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug$2('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug$2('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};
/**
 * Starts polling cycle.
 *
 * @api public
 */


Polling.prototype.poll = function () {
  debug$2('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};
/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */


Polling.prototype.onData = function (data) {
  var self = this;
  debug$2('polling got data %s', data);

  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    } // if its a close packet, we close the ongoing requests


    if ('close' === packet.type) {
      self.onClose();
      return false;
    } // otherwise bypass onData and handle the message


    self.onPacket(packet);
  }; // decode payload


  browser$2.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing

  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug$2('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};
/**
 * For polling, send a close packet.
 *
 * @api private
 */


Polling.prototype.doClose = function () {
  var self = this;

  function close() {
    debug$2('writing close packet');
    self.write([{
      type: 'close'
    }]);
  }

  if ('open' === this.readyState) {
    debug$2('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug$2('transport not open - deferring close');
    this.once('open', close);
  }
};
/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */


Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  browser$2.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = ''; // cache busting is forced

  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // avoid port if default for schema

  if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // prepend ? to query


  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/* global attachEvent */

/**
 * Module requirements.
 */

var debug$3 = browser('engine.io-client:polling-xhr');
/**
 * Module exports.
 */

var pollingXhr = XHR;
var Request_1 = Request;
/**
 * Empty function
 */

function empty() {}
/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */


function XHR(opts) {
  polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = typeof location !== 'undefined' && opts.hostname !== location.hostname || port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(XHR, polling);
/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;
/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout; // other options for Node.js client

  opts.extraHeaders = this.extraHeaders;
  return new Request(opts);
};
/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */


XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({
    method: 'POST',
    data: data,
    isBinary: isBinary
  });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


XHR.prototype.doPoll = function () {
  debug$3('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};
/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */


function Request(opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout; // SSL options for Node.js client

  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized; // other options for Node.js client

  this.extraHeaders = opts.extraHeaders;
  this.create();
}
/**
 * Mix in `Emitter`.
 */


componentEmitter(Request.prototype);
/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = {
    agent: this.agent,
    xdomain: this.xd,
    xscheme: this.xs,
    enablesXDR: this.enablesXDR
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  var xhr = this.xhr = new xmlhttprequest(opts);
  var self = this;

  try {
    debug$3('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);

    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {} // ie6 check


    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };

      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');

            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }

        if (4 !== xhr.readyState) return;

        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug$3('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};
/**
 * Called upon successful response.
 *
 * @api private
 */


Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};
/**
 * Called if we have data.
 *
 * @api private
 */


Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};
/**
 * Called upon error.
 *
 * @api private
 */


Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};
/**
 * Cleans up house.
 *
 * @api private
 */


Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  } // xmlhttprequest


  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};
/**
 * Called upon load.
 *
 * @api private
 */


Request.prototype.onLoad = function () {
  var data;

  try {
    var contentType;

    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}

    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }

  if (null != data) {
    this.onData(data);
  }
};
/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */


Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};
/**
 * Aborts the request.
 *
 * @api public
 */


Request.prototype.abort = function () {
  this.cleanup();
};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */


Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
pollingXhr.Request = Request_1;

/**
 * Module requirements.
 */

/**
 * Module exports.
 */

var pollingJsonp = JSONPPolling;
/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
/**
 * Global JSONP callbacks.
 */

var callbacks;
/**
 * Noop.
 */

function empty$1() {}
/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */


function glob() {
  return typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : {};
}
/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */


function JSONPPolling(opts) {
  polling.call(this, opts);
  this.query = this.query || {}; // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution

  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = global.___eio || [];
  } // callback identifier


  this.index = callbacks.length; // add callback to jsonp global

  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  }); // append to query string

  this.query.j = this.index; // prevent spurious errors from being emitted when the window is unloaded

  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty$1;
    }, false);
  }
}
/**
 * Inherits from Polling.
 */


componentInherit(JSONPPolling, polling);
/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;
/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  polling.prototype.doClose.call(this);
};
/**
 * Starts a poll cycle.
 *
 * @api private
 */


JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();

  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];

  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }

  this.script = script;
  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};
/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */


JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;
    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);
    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete() {
    initIframe();
    fn();
  }

  function initIframe() {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;
    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side

  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

var require$$1$1 = {};

/**
 * Module dependencies.
 */

var debug$4 = browser('engine.io-client:websocket');
var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require$$1$1;
  } catch (e) {}
}
/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */


var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
/**
 * Module exports.
 */

var websocket = WS;
/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts) {
  var forceBase64 = opts && opts.forceBase64;

  if (forceBase64) {
    this.supportsBinary = false;
  }

  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;

  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }

  transport.call(this, opts);
}
/**
 * Inherits from Transport.
 */


componentInherit(WS, transport);
/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';
/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;
/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  }; // SSL options for Node.js client

  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};
/**
 * Adds event listeners to the socket
 *
 * @api private
 */


WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };

  this.ws.onclose = function () {
    self.onClose();
  };

  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };

  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};
/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */


WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false; // encodePacket efficient as it uses WS framing
  // no need for encodePayload

  var total = packets.length;

  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      browser$2.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};

          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;

            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        } // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error


        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug$4('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done() {
    self.emit('flush'); // fake drain
    // defer to next tick to allow Socket to clear writeBuffer

    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};
/**
 * Called upon close
 *
 * @api private
 */


WS.prototype.onClose = function () {
  transport.prototype.onClose.call(this);
};
/**
 * Closes socket.
 *
 * @api private
 */


WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};
/**
 * Generates uri for connection.
 *
 * @api private
 */


WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = ''; // avoid port if default for schema

  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  } // append timestamp to URI


  if (this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  } // communicate binary support capabilities


  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query); // prepend ? to query

  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};
/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */


WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/**
 * Module dependencies
 */

/**
 * Export transports.
 */

var polling_1 = polling$1;
var websocket_1 = websocket;
/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling$1(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new xmlhttprequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new pollingXhr(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new pollingJsonp(opts);
  }
}

var transports = {
  polling: polling_1,
  websocket: websocket_1
};

var indexOf = [].indexOf;

var indexof = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/**
 * Module dependencies.
 */

var debug$5 = browser('engine.io-client:socket');
/**
 * Module exports.
 */

var socket = Socket;
/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);
  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure : typeof location !== 'undefined' && 'https:' === location.protocol;

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port ? location.port : this.secure ? 443 : 80);
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
  if (true === this.perMessageDeflate) this.perMessageDeflate = {};

  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  } // SSL options for Node.js client


  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode; // detect ReactNative environment

  this.isReactNative = typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative'; // other options for Node.js or ReactNative client

  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  } // set on handshake


  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null; // set on heartbeat

  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;
  this.open();
}

Socket.priorWebsocketSuccess = false;
/**
 * Mix in `Emitter`.
 */

componentEmitter(Socket.prototype);
/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = browser$2.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = transport;
Socket.transports = transports;
Socket.parser = browser$2;
/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug$5('creating transport "%s"', name);
  var query = clone(this.query); // append engine.io protocol identifier

  query.EIO = browser$2.protocol; // transport name

  query.transport = name; // per-transport options

  var options = this.transportOptions[name] || {}; // session id if we already have one

  if (this.id) query.sid = this.id;
  var transport$$1 = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void 0,
    isReactNative: this.isReactNative
  });
  return transport$$1;
};

function clone(obj) {
  var o = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }

  return o;
}
/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */


Socket.prototype.open = function () {
  var transport$$1;

  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport$$1 = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport$$1 = this.transports[0];
  }

  this.readyState = 'opening'; // Retry with the next transport if the transport is disabled (jsonp: false)

  try {
    transport$$1 = this.createTransport(transport$$1);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport$$1.open();
  this.setTransport(transport$$1);
};
/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */


Socket.prototype.setTransport = function (transport$$1) {
  debug$5('setting transport %s', transport$$1.name);
  var self = this;

  if (this.transport) {
    debug$5('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  } // set up transport


  this.transport = transport$$1; // set up transport listeners

  transport$$1.on('drain', function () {
    self.onDrain();
  }).on('packet', function (packet) {
    self.onPacket(packet);
  }).on('error', function (e) {
    self.onError(e);
  }).on('close', function () {
    self.onClose('transport close');
  });
};
/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */


Socket.prototype.probe = function (name) {
  debug$5('probing transport "%s"', name);
  var transport$$1 = this.createTransport(name, {
    probe: 1
  });
  var failed = false;
  var self = this;
  Socket.priorWebsocketSuccess = false;

  function onTransportOpen() {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }

    if (failed) return;
    debug$5('probe transport "%s" opened', name);
    transport$$1.send([{
      type: 'ping',
      data: 'probe'
    }]);
    transport$$1.once('packet', function (msg) {
      if (failed) return;

      if ('pong' === msg.type && 'probe' === msg.data) {
        debug$5('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport$$1);
        if (!transport$$1) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport$$1.name;
        debug$5('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug$5('changing transport and sending upgrade packet');
          cleanup();
          self.setTransport(transport$$1);
          transport$$1.send([{
            type: 'upgrade'
          }]);
          self.emit('upgrade', transport$$1);
          transport$$1 = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug$5('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport$$1.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return; // Any callback called by transport should be ignored since now

    failed = true;
    cleanup();
    transport$$1.close();
    transport$$1 = null;
  } // Handle any error that happens while probing


  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport$$1.name;
    freezeTransport();
    debug$5('probe transport "%s" failed because of error: %s', name, err);
    self.emit('upgradeError', error);
  }

  function onTransportClose() {
    onerror('transport closed');
  } // When the socket is closed while we're probing


  function onclose() {
    onerror('socket closed');
  } // When the socket is upgraded while we're probing


  function onupgrade(to) {
    if (transport$$1 && to.name !== transport$$1.name) {
      debug$5('"%s" works - aborting "%s"', to.name, transport$$1.name);
      freezeTransport();
    }
  } // Remove all listeners on the transport and on self


  function cleanup() {
    transport$$1.removeListener('open', onTransportOpen);
    transport$$1.removeListener('error', onerror);
    transport$$1.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport$$1.once('open', onTransportOpen);
  transport$$1.once('error', onerror);
  transport$$1.once('close', onTransportClose);
  this.once('close', onclose);
  this.once('upgrading', onupgrade);
  transport$$1.open();
};
/**
 * Called when connection is deemed open.
 *
 * @api public
 */


Socket.prototype.onOpen = function () {
  debug$5('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush(); // we check for `readyState` in case an `open`
  // listener already closed the socket

  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug$5('starting upgrade probes');

    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};
/**
 * Handles a packet.
 *
 * @api private
 */


Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);
    this.emit('packet', packet); // Socket is live - any packet counts

    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug$5('packet received with socket readyState "%s"', this.readyState);
  }
};
/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */


Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen(); // In case open handler closes socket

  if ('closed' === this.readyState) return;
  this.setPing(); // Prolong liveness of socket on heartbeat

  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};
/**
 * Resets ping timeout.
 *
 * @api private
 */


Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || self.pingInterval + self.pingTimeout);
};
/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */


Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug$5('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};
/**
* Sends a ping packet.
*
* @api private
*/


Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};
/**
 * Called on `drain` event
 *
 * @api private
 */


Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`

  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};
/**
 * Flush write buffers.
 *
 * @api private
 */


Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
    debug$5('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`

    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};
/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */


Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};
/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */


Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;
  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};
/**
 * Closes the connection.
 *
 * @api private
 */


Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';
    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug$5('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};
/**
 * Called upon transport error
 *
 * @api private
 */


Socket.prototype.onError = function (err) {
  debug$5('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};
/**
 * Called upon transport close.
 *
 * @api private
 */


Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket close with reason: "%s"', reason);
    var self = this; // clear timers

    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport

    this.transport.removeAllListeners('close'); // ensure transport won't stay open

    this.transport.close(); // ignore further transport communication

    this.transport.removeAllListeners(); // set ready state

    this.readyState = 'closed'; // clear session id

    this.id = null; // emit close event

    this.emit('close', reason, desc); // clean buffers after, so users can still
    // grab the buffers on `close` event

    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};
/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */


Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];

  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~indexof(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }

  return filteredUpgrades;
};

var lib = socket;
/**
 * Exports parser
 *
 * @api public
 *
 */

var parser = browser$2;
lib.parser = parser;

var toArray_1 = toArray;

function toArray(list, index) {
  var array = [];
  index = index || 0;

  for (var i = index || 0; i < list.length; i++) {
    array[i - index] = list[i];
  }

  return array;
}

/**
 * Module exports.
 */
var on_1 = on;
/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

/**
 * Slice reference.
 */
var slice = [].slice;
/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

var componentBind = function (obj, fn) {
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function () {
    return fn.apply(obj, args.concat(slice.call(arguments)));
  };
};

var socket$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client:socket');
  /**
   * Module exports.
   */

  module.exports = exports = Socket;
  /**
   * Internal events (blacklisted).
   * These events can't be emitted by the user.
   *
   * @api private
   */

  var events = {
    connect: 1,
    connect_error: 1,
    connect_timeout: 1,
    connecting: 1,
    disconnect: 1,
    error: 1,
    reconnect: 1,
    reconnect_attempt: 1,
    reconnect_failed: 1,
    reconnect_error: 1,
    reconnecting: 1,
    ping: 1,
    pong: 1
  };
  /**
   * Shortcut to `Emitter#emit`.
   */

  var emit = componentEmitter.prototype.emit;
  /**
   * `Socket` constructor.
   *
   * @api public
   */

  function Socket(io, nsp, opts) {
    this.io = io;
    this.nsp = nsp;
    this.json = this; // compat

    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    this.flags = {};

    if (opts && opts.query) {
      this.query = opts.query;
    }

    if (this.io.autoConnect) this.open();
  }
  /**
   * Mix in `Emitter`.
   */


  componentEmitter(Socket.prototype);
  /**
   * Subscribe to open, close and packet events
   *
   * @api private
   */

  Socket.prototype.subEvents = function () {
    if (this.subs) return;
    var io = this.io;
    this.subs = [on_1(io, 'open', componentBind(this, 'onopen')), on_1(io, 'packet', componentBind(this, 'onpacket')), on_1(io, 'close', componentBind(this, 'onclose'))];
  };
  /**
   * "Opens" the socket.
   *
   * @api public
   */


  Socket.prototype.open = Socket.prototype.connect = function () {
    if (this.connected) return this;
    this.subEvents();
    this.io.open(); // ensure open

    if ('open' === this.io.readyState) this.onopen();
    this.emit('connecting');
    return this;
  };
  /**
   * Sends a `message` event.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.send = function () {
    var args = toArray_1(arguments);
    args.unshift('message');
    this.emit.apply(this, args);
    return this;
  };
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @param {String} event name
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.emit = function (ev) {
    if (events.hasOwnProperty(ev)) {
      emit.apply(this, arguments);
      return this;
    }

    var args = toArray_1(arguments);
    var packet = {
      type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback

    if ('function' === typeof args[args.length - 1]) {
      debug('emitting packet with ack id %d', this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }

    if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }

    this.flags = {};
    return this;
  };
  /**
   * Sends a packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.packet = function (packet) {
    packet.nsp = this.nsp;
    this.io.packet(packet);
  };
  /**
   * Called upon engine `open`.
   *
   * @api private
   */


  Socket.prototype.onopen = function () {
    debug('transport is open - connecting'); // write connect packet if necessary

    if ('/' !== this.nsp) {
      if (this.query) {
        var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
        debug('sending connect packet with query %s', query);
        this.packet({
          type: socket_ioParser.CONNECT,
          query: query
        });
      } else {
        this.packet({
          type: socket_ioParser.CONNECT
        });
      }
    }
  };
  /**
   * Called upon engine `close`.
   *
   * @param {String} reason
   * @api private
   */


  Socket.prototype.onclose = function (reason) {
    debug('close (%s)', reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emit('disconnect', reason);
  };
  /**
   * Called with socket packet.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onpacket = function (packet) {
    var sameNamespace = packet.nsp === this.nsp;
    var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === '/';
    if (!sameNamespace && !rootNamespaceError) return;

    switch (packet.type) {
      case socket_ioParser.CONNECT:
        this.onconnect();
        break;

      case socket_ioParser.EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.BINARY_EVENT:
        this.onevent(packet);
        break;

      case socket_ioParser.ACK:
        this.onack(packet);
        break;

      case socket_ioParser.BINARY_ACK:
        this.onack(packet);
        break;

      case socket_ioParser.DISCONNECT:
        this.ondisconnect();
        break;

      case socket_ioParser.ERROR:
        this.emit('error', packet.data);
        break;
    }
  };
  /**
   * Called upon a server event.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onevent = function (packet) {
    var args = packet.data || [];
    debug('emitting event %j', args);

    if (null != packet.id) {
      debug('attaching ack callback to event');
      args.push(this.ack(packet.id));
    }

    if (this.connected) {
      emit.apply(this, args);
    } else {
      this.receiveBuffer.push(args);
    }
  };
  /**
   * Produces an ack callback to emit with an event.
   *
   * @api private
   */


  Socket.prototype.ack = function (id) {
    var self = this;
    var sent = false;
    return function () {
      // prevent double callbacks
      if (sent) return;
      sent = true;
      var args = toArray_1(arguments);
      debug('sending ack %j', args);
      self.packet({
        type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
        id: id,
        data: args
      });
    };
  };
  /**
   * Called upon a server acknowlegement.
   *
   * @param {Object} packet
   * @api private
   */


  Socket.prototype.onack = function (packet) {
    var ack = this.acks[packet.id];

    if ('function' === typeof ack) {
      debug('calling ack %s with %j', packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug('bad ack %s', packet.id);
    }
  };
  /**
   * Called upon server connect.
   *
   * @api private
   */


  Socket.prototype.onconnect = function () {
    this.connected = true;
    this.disconnected = false;
    this.emit('connect');
    this.emitBuffered();
  };
  /**
   * Emit buffered events (received and emitted).
   *
   * @api private
   */


  Socket.prototype.emitBuffered = function () {
    var i;

    for (i = 0; i < this.receiveBuffer.length; i++) {
      emit.apply(this, this.receiveBuffer[i]);
    }

    this.receiveBuffer = [];

    for (i = 0; i < this.sendBuffer.length; i++) {
      this.packet(this.sendBuffer[i]);
    }

    this.sendBuffer = [];
  };
  /**
   * Called upon server disconnect.
   *
   * @api private
   */


  Socket.prototype.ondisconnect = function () {
    debug('server disconnect (%s)', this.nsp);
    this.destroy();
    this.onclose('io server disconnect');
  };
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @api private.
   */


  Socket.prototype.destroy = function () {
    if (this.subs) {
      // clean subscriptions to avoid reconnections
      for (var i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }

      this.subs = null;
    }

    this.io.destroy(this);
  };
  /**
   * Disconnects the socket manually.
   *
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.close = Socket.prototype.disconnect = function () {
    if (this.connected) {
      debug('performing disconnect (%s)', this.nsp);
      this.packet({
        type: socket_ioParser.DISCONNECT
      });
    } // remove socket from pool


    this.destroy();

    if (this.connected) {
      // fire events
      this.onclose('io client disconnect');
    }

    return this;
  };
  /**
   * Sets the compress flag.
   *
   * @param {Boolean} if `true`, compresses the sending data
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.compress = function (compress) {
    this.flags.compress = compress;
    return this;
  };
  /**
   * Sets the binary flag
   *
   * @param {Boolean} whether the emitted data contains binary
   * @return {Socket} self
   * @api public
   */


  Socket.prototype.binary = function (binary) {
    this.flags.binary = binary;
    return this;
  };
});

/**
 * Expose `Backoff`.
 */
var backo2 = Backoff;
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */


Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);

  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }

  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */


Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */


Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */


Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */


Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/**
 * Module dependencies.
 */

var debug$6 = browser('socket.io-client:manager');
/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;
/**
 * Module exports
 */

var manager = Manager;
/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new backo2({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];

  var _parser = opts.parser || socket_ioParser;

  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}
/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */


Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);

  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};
/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */


Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};
/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */


Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
};
/**
 * Mix in `Emitter`.
 */


componentEmitter(Manager.prototype);
/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v$$1) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v$$1;
  return this;
};
/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionAttempts = function (v$$1) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v$$1;
  return this;
};
/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelay = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v$$1;
  this.backoff && this.backoff.setMin(v$$1);
  return this;
};

Manager.prototype.randomizationFactor = function (v$$1) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v$$1;
  this.backoff && this.backoff.setJitter(v$$1);
  return this;
};
/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.reconnectionDelayMax = function (v$$1) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v$$1;
  this.backoff && this.backoff.setMax(v$$1);
  return this;
};
/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */


Manager.prototype.timeout = function (v$$1) {
  if (!arguments.length) return this._timeout;
  this._timeout = v$$1;
  return this;
};
/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */


Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};
/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */


Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
  debug$6('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;
  debug$6('opening %s', this.uri);
  this.engine = lib(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false; // emit `open`

  var openSub = on_1(socket, 'open', function () {
    self.onopen();
    fn && fn();
  }); // emit `connect_error`

  var errorSub = on_1(socket, 'error', function (data) {
    debug$6('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);

    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  }); // emit `connect_timeout`

  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug$6('connect attempt will timeout after %d', timeout); // set timer

    var timer = setTimeout(function () {
      debug$6('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);
  return this;
};
/**
 * Called upon transport open.
 *
 * @api private
 */


Manager.prototype.onopen = function () {
  debug$6('open'); // clear old subs

  this.cleanup(); // mark as open

  this.readyState = 'open';
  this.emit('open'); // add new subs

  var socket = this.engine;
  this.subs.push(on_1(socket, 'data', componentBind(this, 'ondata')));
  this.subs.push(on_1(socket, 'ping', componentBind(this, 'onping')));
  this.subs.push(on_1(socket, 'pong', componentBind(this, 'onpong')));
  this.subs.push(on_1(socket, 'error', componentBind(this, 'onerror')));
  this.subs.push(on_1(socket, 'close', componentBind(this, 'onclose')));
  this.subs.push(on_1(this.decoder, 'decoded', componentBind(this, 'ondecoded')));
};
/**
 * Called upon a ping.
 *
 * @api private
 */


Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};
/**
 * Called upon a packet.
 *
 * @api private
 */


Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};
/**
 * Called with data.
 *
 * @api private
 */


Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};
/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */


Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};
/**
 * Called upon socket error.
 *
 * @api private
 */


Manager.prototype.onerror = function (err) {
  debug$6('error', err);
  this.emitAll('error', err);
};
/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */


Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];

  if (!socket) {
    socket = new socket$1(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexof(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};
/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */


Manager.prototype.destroy = function (socket) {
  var index = indexof(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;
  this.close();
};
/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */


Manager.prototype.packet = function (packet) {
  debug$6('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }

      self.encoding = false;
      self.processPacketQueue();
    });
  } else {
    // add packet to the queue
    self.packetBuffer.push(packet);
  }
};
/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */


Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};
/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */


Manager.prototype.cleanup = function () {
  debug$6('cleanup');
  var subsLength = this.subs.length;

  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;
  this.decoder.destroy();
};
/**
 * Close the current socket.
 *
 * @api private
 */


Manager.prototype.close = Manager.prototype.disconnect = function () {
  debug$6('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;

  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }

  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};
/**
 * Called upon engine close.
 *
 * @api private
 */


Manager.prototype.onclose = function (reason) {
  debug$6('onclose');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};
/**
 * Attempt a reconnection.
 *
 * @api private
 */


Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;
  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug$6('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug$6('will wait %dms before reconnect attempt', delay);
    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;
      debug$6('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events

      if (self.skipReconnect) return;
      self.open(function (err) {
        if (err) {
          debug$6('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug$6('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);
    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};
/**
 * Called upon successful reconnect.
 *
 * @api private
 */


Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

var lib$1 = createCommonjsModule(function (module, exports) {
  /**
   * Module dependencies.
   */
  var debug = browser('socket.io-client');
  /**
   * Module exports.
   */

  module.exports = exports = lookup;
  /**
   * Managers cache.
   */

  var cache = exports.managers = {};
  /**
   * Looks up an existing `Manager` for multiplexing.
   * If the user summons:
   *
   *   `io('http://localhost/a');`
   *   `io('http://localhost/b');`
   *
   * We reuse the existing instance based on same scheme/port/host,
   * and we initialize sockets for each namespace.
   *
   * @api public
   */

  function lookup(uri, opts) {
    if (typeof uri === 'object') {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    var parsed = url_1(uri);
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] && path in cache[id].nsps;
    var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
    var io;

    if (newConnection) {
      debug('ignoring socket cache for %s', source);
      io = manager(source, opts);
    } else {
      if (!cache[id]) {
        debug('new io instance for %s', source);
        cache[id] = manager(source, opts);
      }

      io = cache[id];
    }

    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }

    return io.socket(parsed.path, opts);
  }
  /**
   * Protocol version.
   *
   * @api public
   */


  exports.protocol = socket_ioParser.protocol;
  /**
   * `connect`.
   *
   * @param {String} uri
   * @api public
   */

  exports.connect = lookup;
  /**
   * Expose constructors for standalone build.
   *
   * @api public
   */

  exports.Manager = manager;
  exports.Socket = socket$1;
});
var lib_1 = lib$1.managers;
var lib_2 = lib$1.protocol;
var lib_3 = lib$1.connect;
var lib_4 = lib$1.Manager;
var lib_5 = lib$1.Socket;

var useSocket = function useSocket(_ref) {
  var username = _ref.username,
      _ref$route = _ref.route,
      route = _ref$route === void 0 ? '/anonymous' : _ref$route,
      serverUrl = _ref.serverUrl;

  var _useState = v(null),
      _useState2 = _slicedToArray(_useState, 2),
      socket = _useState2[0],
      setSocket = _useState2[1];

  var _useState3 = v(false),
      _useState4 = _slicedToArray(_useState3, 2),
      connected = _useState4[0],
      setConnected = _useState4[1];

  var _useState5 = v(null),
      _useState6 = _slicedToArray(_useState5, 2),
      socketError = _useState6[0],
      setSocketError = _useState6[1];

  p(function () {
    function fetchToken() {
      var response, data;
      return _regeneratorRuntime.async(function fetchToken$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return _regeneratorRuntime.awrap(fetch(route, {
                method: "POST",
                body: JSON.stringify({
                  username: username
                }),
                headers: {
                  "Content-Type": "application/json"
                }
              }));

            case 3:
              response = _context.sent;
              _context.next = 6;
              return _regeneratorRuntime.awrap(response.json());

            case 6:
              data = _context.sent;
              setSocket(lib$1(serverUrl, {
                query: "token=".concat(data.token)
              }));
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](0);
              setSocketError(_context.t0);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[0, 10]]);
    }

    fetchToken();
  }, []);
  p(function () {
    if (socket !== null) {
      socket.on("error", function (error) {
        setSocketError(error);
      });
      socket.on("connect", function () {
        setConnected(true);
      });
      socket.on("message", function () {});
    }
  }, [socket]);
  return {
    socket: socket,
    connected: connected,
    socketError: socketError
  };
};

var useSocketClient = function useSocketClient(_ref) {
  var name = _ref.name,
      targetName = _ref.targetName,
      route = _ref.route,
      serverUrl = _ref.serverUrl;

  var _useSocket = useSocket({
    username: name,
    route: route,
    serverUrl: serverUrl
  }),
      socket = _useSocket.socket,
      connected = _useSocket.connected,
      socketError = _useSocket.socketError;

  var _useSocketMessaging = useSocketMessaging({
    socket: socket,
    targetName: targetName
  }),
      errors = _useSocketMessaging.errors,
      handleMessageChange = _useSocketMessaging.handleMessageChange,
      messageRecieved = _useSocketMessaging.messageRecieved,
      messageSent = _useSocketMessaging.messageSent,
      messageText = _useSocketMessaging.messageText,
      sendMessage = _useSocketMessaging.sendMessage;

  var _useChatLog = useChatLog({
    name: name,
    messageRecieved: messageRecieved,
    messageSent: messageSent
  }),
      messages = _useChatLog.messages;

  return {
    messages: messages,
    messageRecieved: messageRecieved,
    messageSent: messageSent,
    messageText: messageText,
    sendMessage: sendMessage,
    errors: errors,
    connected: connected,
    handleMessageChange: handleMessageChange
  };
};

var ChatRoom = function ChatRoom() {
  var _useState = v(0),
      _useState2 = _slicedToArray(_useState, 2),
      msgForMario = _useState2[0],
      setMsgForMario = _useState2[1];

  var _useState3 = v(0),
      _useState4 = _slicedToArray(_useState3, 2),
      msgForDragos = _useState4[0],
      setMsgForDragos = _useState4[1];

  var _useState5 = v(0),
      _useState6 = _slicedToArray(_useState5, 2),
      selectedItem = _useState6[0],
      setSelectedItem = _useState6[1];

  var _useSocketClient = useSocketClient({
    name: "mario",
    targetName: "dragos",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgMario = _useSocketClient.messages,
      msgRecMario = _useSocketClient.messageRecieved,
      msgSntMario = _useSocketClient.messageSent,
      msgTxtMario = _useSocketClient.messageText,
      sendMsgMario = _useSocketClient.sendMessage,
      errMario = _useSocketClient.errors,
      cntMario = _useSocketClient.connected,
      hdleMessageChageMario = _useSocketClient.handleMessageChange,
      marioSocket = _useSocketClient.socket;

  var _useSocketClient2 = useSocketClient({
    name: "dragos",
    targetName: "mario",
    serverUrl: "http://localhost:3000",
    route: '/anonymous'
  }),
      msgDragos = _useSocketClient2.messages,
      msgRecDragos = _useSocketClient2.messageRecieved,
      msgSntDragos = _useSocketClient2.messageSent,
      msgTxtDragos = _useSocketClient2.messageText,
      sendMsgDragos = _useSocketClient2.sendMessage,
      errDragos = _useSocketClient2.errors,
      cntDragos = _useSocketClient2.connected,
      hdleMessageChageDragos = _useSocketClient2.handleMessageChange,
      dragosSocket = _useSocketClient2.socket;

  p(function () {
    if (msgForDragos !== null) setMsgForDragos(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecDragos]);
  p(function () {
    if (msgForMario !== null) setMsgForMario(function (prevState) {
      return prevState + 1;
    });
  }, [msgRecMario]);
  p(function () {
    if (selectedItem === 0) {
      setMsgForMario(0);
    } else {
      setMsgForDragos(0);
    }
  }, [selectedItem]);
  return h("div", {
    style: {
      width: "100%",
      height: "100%"
    }
  }, h("div", {
    className: "tab-bar"
  }, h("div", null, h(TabBar, null, h(TabBar.Tab, {
    active: true,
    onClick: function onClick() {
      return setSelectedItem(0);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntMario ? "green" : "orange"
    }
  }, "mario"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForMario > 0 ? "green" : "darkgrey"
    }
  }, msgForMario)))), h(TabBar.Tab, {
    onClick: function onClick() {
      return setSelectedItem(1);
    }
  }, h(TabBar.TabLabel, null, h("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, h("div", {
    style: {
      color: cntDragos ? "green" : "orange"
    }
  }, "dragos"), h("div", {
    className: "chip",
    style: {
      backgroundColor: msgForDragos > 0 ? "green" : "darkgrey"
    }
  }, msgForDragos))))))), selectedItem === 0 && h(ChatUser, {
    handleMessageChange: hdleMessageChageMario,
    connected: cntMario,
    errors: errMario,
    messageSent: msgSntMario,
    messageText: msgTxtMario,
    messages: msgMario,
    sendMessage: sendMsgMario,
    messageRecieved: msgRecMario,
    socket: dragosSocket,
    name: "mario",
    targetName: "dragos"
  }), selectedItem === 1 && h(ChatUser, {
    handleMessageChange: hdleMessageChageDragos,
    connected: cntDragos,
    errors: errDragos,
    messageSent: msgSntDragos,
    messageText: msgTxtDragos,
    messages: msgDragos,
    sendMessage: sendMsgDragos,
    messageRecieved: msgRecDragos,
    socket: dragosSocket,
    name: "dragos",
    targetName: "mario"
  }));
};

var SocketIOMessaging = function SocketIOMessaging() {
  return h(ChatRoom, null);
};

var WebRTCMessaging = function WebRTCMessaging() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTC Messaging");
};

var WebRTCVideoChat = function WebRTCVideoChat() {
  return h("div", {
    style: {
      marginTop: 200
    }
  }, "WebRTCVideoChat");
};

export { SocketIOMessaging as a, WebRTCMessaging as b, WebRTCVideoChat as c };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmstNTI4NzI3ZjEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvYWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3Ivbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1pbmRpY2F0b3Ivbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9hZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL3NsaWRpbmctZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9mYWRpbmctZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL2FkYXB0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9hZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLXNjcm9sbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLWRlZmF1bHQtc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ydGwtbmVnYXRpdmUtc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9ydGwtcmV2ZXJzZS1zY3JvbGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvYWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1iYXIvZm91bmRhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcmVhY3QtbWF0ZXJpYWwtY29tcG9uZW50cy9UYWJCYXIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2Utb2JqZWN0LW1hcHBlci9kYXRlLWxpbmVicmVhay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1hbGlnbmVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS12aWV3LmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvc3Vic2VxdWVudC1tZXNzYWdlLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1hdmF0YXIuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2Utb2JqZWN0LW1hcHBlci9maXJzdC1tZXNzYWdlLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi9tZXNzYWdlLW9iamVjdC1tYXBwZXIvbWVzc2FnZS1vYmplY3QtbWFwcGVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi91c2VNZXNzYWdlU29ydGVyLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtdWkvbWVzc2FnZXMtZGlzcGxheWVyL2xpYi91c2VNZXNzYWdlTWFwcGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLXVpL21lc3NhZ2VzLWRpc3BsYXllci9saWIvbWVzc2FnZS1jb2xsZWN0aW9uLXZpZXcuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2VzLXZpZXctc2Nyb2xsZXIuanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlLWVkaXRvci1kaXNwbGF5ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXIvbGliL21lc3NhZ2VzLWRpc3BsYXllci5qcyIsIi4uL21vZHVsZXMvc29ja2V0LWlvLW1lc3NhZ2luZy9DaGF0VXNlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLWhvb2tzL3NvY2tldC1pby1tZXNzYWdpbmcvdXNlU29ja2V0TWVzc2FnaW5nLmpzIiwiLi4vLi4vLi4vcnRjanMvcmV1c2FibGUtaG9va3MvdXNlQ2hhdExvZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2Jhc2U2NC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2llZWU3NTQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9pc0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcmVzb2x2ZS9zcmMvZW1wdHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS1ob29rcy9zb2NrZXQtaW8tbWVzc2FnaW5nL3VzZVNvY2tldC5qcyIsIi4uLy4uLy4uL3J0Y2pzL3JldXNhYmxlLWhvb2tzL3NvY2tldC1pby1tZXNzYWdpbmcvdXNlU29ja2V0Q2xpZW50LmpzIiwiLi4vbW9kdWxlcy9zb2NrZXQtaW8tbWVzc2FnaW5nL0NoYXRSb29tLmpzIiwiLi4vbW9kdWxlcy9zb2NrZXQtaW8tbWVzc2FnaW5nL2luZGV4LmpzIiwiLi4vbW9kdWxlcy93ZWJydGMtbWVzc2FnaW5nL2luZGV4LmpzIiwiLi4vbW9kdWxlcy93ZWJydGMtdmlkZW8tY2hhdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gIGNvbnN0IHt4LCB5fSA9IHBhZ2VPZmZzZXQ7XG4gIGNvbnN0IGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gIGNvbnN0IGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcblxuICBsZXQgbm9ybWFsaXplZFg7XG4gIGxldCBub3JtYWxpemVkWTtcbiAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2dldE5vcm1hbGl6ZWRFdmVudENvb3Jkc30gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGZvY3VzOiBmdW5jdGlvbigpLFxuICogICBibHVyOiBmdW5jdGlvbigpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJzVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlRm9jdXMoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUJsdXIoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuXG4gICAgLyoqIEBwcml2YXRlIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyfX0gKi9cbiAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnU2NhbGVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgez9FdmVudH0gKi9cbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2UgY29tcHV0ZSB0aGlzIHByb3BlcnR5IHNvIHRoYXQgd2UgYXJlIG5vdCBxdWVyeWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2xpZW50XG4gICAqIHVudGlsIHRoZSBwb2ludCBpbiB0aW1lIHdoZXJlIHRoZSBmb3VuZGF0aW9uIHJlcXVlc3RzIGl0LiBUaGlzIHByZXZlbnRzIHNjZW5hcmlvcyB3aGVyZVxuICAgKiBjbGllbnQtc2lkZSBmZWF0dXJlLWRldGVjdGlvbiBtYXkgaGFwcGVuIHRvbyBlYXJseSwgc3VjaCBhcyB3aGVuIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHRoZW4gaW5pdGlhbGl6ZWQgYXQgbW91bnQgdGltZSBvbiB0aGUgY2xpZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3VwcG9ydHNQcmVzc1JpcHBsZV8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBY3RpdmF0aW9uU3RhdGVUeXBlfVxuICAgKi9cbiAgZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uRXZlbnQ6IG51bGwsXG4gICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzdXBwb3J0c1ByZXNzUmlwcGxlID0gdGhpcy5zdXBwb3J0c1ByZXNzUmlwcGxlXygpO1xuXG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oc3VwcG9ydHNQcmVzc1JpcHBsZSk7XG5cbiAgICBpZiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZV8oKSkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkdfQUNUSVZBVElPTik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IDA7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzdXBwb3J0c1ByZXNzUmlwcGxlIFBhc3NlZCBmcm9tIGluaXQgdG8gc2F2ZSBhIHJlZHVuZGFudCBmdW5jdGlvbiBjYWxsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY3RpdmF0ZV8oZSkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHJlYWN0aW5nIHRvIGZvbGxvdy1vbiBldmVudHMgZmlyZWQgYnkgdG91Y2ggZGV2aWNlIGFmdGVyIGFuIGFscmVhZHktcHJvY2Vzc2VkIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICAgIGNvbnN0IGlzU2FtZUludGVyYWN0aW9uID0gcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgJiYgZSAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSBudWxsO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID1cbiAgICAgIGUgJiYgYWN0aXZhdGVkVGFyZ2V0cy5sZW5ndGggPiAwICYmIGFjdGl2YXRlZFRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZS50YXJnZXQpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBSZXNldCBhcnJheSBvbiBuZXh0IGZyYW1lIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGhhcyBoYWQgYSBjaGFuY2UgdG8gYnViYmxlIHRvIHByZXZlbnQgYW5jZXN0b3IgcmlwcGxlc1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSAmJiAoZS5rZXkgPT09ICcgJyB8fCBlLmtleUNvZGUgPT09IDMyKSkge1xuICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAvLyBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAvLyBXZSB0cnkgZmlyc3Qgb3V0c2lkZSByQUYgdG8gc3VwcG9ydCBFZGdlLCB3aGljaCBkb2VzIG5vdCBleGhpYml0IHRoaXMgcHJvYmxlbSwgYnV0IHdpbGwgY3Jhc2ggaWYgYSBDU1NcbiAgICAgICAgLy8gdmFyaWFibGUgaXMgc2V0IHdpdGhpbiBhIHJBRiBjYWxsYmFjayBmb3IgYSBzdWJtaXQgYnV0dG9uIGludGVyYWN0aW9uICgjMjI0MSkuXG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgIC8vIFJlc2V0IGFjdGl2YXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgaWYgZWxlbWVudCB3YXMgbm90IG1hZGUgYWN0aXZlLlxuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS50eXBlID09PSAna2V5ZG93bicpID8gdGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VBY3RpdmUoKSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5hY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGFuaW1hdGVBY3RpdmF0aW9uXygpIHtcbiAgICBjb25zdCB7VkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgVkFSX0ZHX1RSQU5TTEFURV9FTkR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT04sIEZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtERUFDVElWQVRJT05fVElNRU9VVF9NU30gPSBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnM7XG5cbiAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuXG4gICAgbGV0IHRyYW5zbGF0ZVN0YXJ0ID0gJyc7XG4gICAgbGV0IHRyYW5zbGF0ZUVuZCA9ICcnO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIGNvbnN0IHtzdGFydFBvaW50LCBlbmRQb2ludH0gPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKTtcbiAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gYCR7c3RhcnRQb2ludC54fXB4LCAke3N0YXJ0UG9pbnQueX1weGA7XG4gICAgICB0cmFuc2xhdGVFbmQgPSBgJHtlbmRQb2ludC54fXB4LCAke2VuZFBvaW50Lnl9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgdHJhbnNsYXRlU3RhcnQpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9FTkQsIHRyYW5zbGF0ZUVuZCk7XG4gICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuXG4gICAgLy8gRm9yY2UgbGF5b3V0IGluIG9yZGVyIHRvIHJlLXRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18oKSwgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3tzdGFydFBvaW50OiBQb2ludFR5cGUsIGVuZFBvaW50OiBQb2ludFR5cGV9fVxuICAgKi9cbiAgZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpIHtcbiAgICBjb25zdCB7YWN0aXZhdGlvbkV2ZW50LCB3YXNBY3RpdmF0ZWRCeVBvaW50ZXJ9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuXG4gICAgbGV0IHN0YXJ0UG9pbnQ7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlcikge1xuICAgICAgc3RhcnRQb2ludCA9IGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhcbiAgICAgICAgLyoqIEB0eXBlIHshRXZlbnR9ICovIChhY3RpdmF0aW9uRXZlbnQpLFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd1BhZ2VPZmZzZXQoKSwgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgIHg6IHRoaXMuZnJhbWVfLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5mcmFtZV8uaGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENlbnRlciB0aGUgZWxlbWVudCBhcm91bmQgdGhlIHN0YXJ0IHBvaW50LlxuICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBzdGFydFBvaW50LnggLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6IHN0YXJ0UG9pbnQueSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmRQb2ludCA9IHtcbiAgICAgIHg6ICh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiAodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtzdGFydFBvaW50LCBlbmRQb2ludH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBib3RoIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgcmVsZWFzZWQsIGFuZCB3aGVuIHRoZSBhY3RpdmF0aW9uIGFuaW1hdGlvbiBlbmRzLlxuICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtoYXNEZWFjdGl2YXRpb25VWFJ1biwgaXNBY3RpdmF0ZWR9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGNvbnN0IGFjdGl2YXRpb25IYXNFbmRlZCA9IGhhc0RlYWN0aXZhdGlvblVYUnVuIHx8ICFpc0FjdGl2YXRlZDtcblxuICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfKSB7XG4gICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgfSwgbnVtYmVycy5GR19ERUFDVElWQVRJT05fTVMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSB7XG4gICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gIH1cblxuICByZXNldEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uYWN0aXZhdGlvbkV2ZW50O1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91cyBldmVudCB1bnRpbCBpdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgc3Vic2VxdWVudCBldmVudHMgYXJlIGZvciBuZXcgaW50ZXJhY3Rpb25zLlxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsLCBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuVEFQX0RFTEFZX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZV8oZSkge1xuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovIChPYmplY3QuYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpKTtcblxuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgIGNvbnN0IGV2dE9iamVjdCA9IG51bGw7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhldnRPYmplY3QsIHN0YXRlKSk7XG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGRlYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0geyFBY3RpdmF0aW9uU3RhdGVUeXBlfSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlRGVhY3RpdmF0aW9uXyhlLCB7d2FzQWN0aXZhdGVkQnlQb2ludGVyLCB3YXNFbGVtZW50TWFkZUFjdGl2ZX0pIHtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyIHx8IHdhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgdGhpcy5mcmFtZV8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh0aGlzLmZyYW1lXy5oZWlnaHQsIHRoaXMuZnJhbWVfLndpZHRoKTtcblxuICAgIC8vIFN1cmZhY2UgZGlhbWV0ZXIgaXMgdHJlYXRlZCBkaWZmZXJlbnRseSBmb3IgdW5ib3VuZGVkIHZzLiBib3VuZGVkIHJpcHBsZXMuXG4gICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBkaWFtZXRlciBpcyBjYWxjdWxhdGVkIHNtYWxsZXIgc2luY2UgdGhlIHN1cmZhY2UgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBiZSBwYWRkZWQgYXBwcm9wcmlhdGVseVxuICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgLy8gc3F1YXJlKS4gQm91bmRlZCByaXBwbGVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGZ1bGx5IGV4cGVjdGVkIHRvIGV4cGFuZCBiZXlvbmQgdGhlIHN1cmZhY2UncyBsb25nZXN0IGRpYW1ldGVyXG4gICAgLy8gKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpYWdvbmFsIHBsdXMgYSBjb25zdGFudCBwYWRkaW5nKSwgYW5kIGFyZSBjbGlwcGVkIGF0IHRoZSBzdXJmYWNlJ3MgYm9yZGVyIHZpYVxuICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICBjb25zdCBnZXRCb3VuZGVkUmFkaXVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmZyYW1lXy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmZyYW1lXy5oZWlnaHQsIDIpKTtcbiAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgfTtcblxuICAgIHRoaXMubWF4UmFkaXVzXyA9IHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSA/IG1heERpbSA6IGdldEJvdW5kZWRSYWRpdXMoKTtcblxuICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSBtYXhEaW0gKiBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuSU5JVElBTF9PUklHSU5fU0NBTEU7XG4gICAgdGhpcy5mZ1NjYWxlXyA9IHRoaXMubWF4UmFkaXVzXyAvIHRoaXMuaW5pdGlhbFNpemVfO1xuXG4gICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVwZGF0ZUxheW91dENzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIFZBUl9GR19TSVpFLCBWQVJfTEVGVCwgVkFSX1RPUCwgVkFSX0ZHX1NDQUxFLFxuICAgIH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TSVpFLCBgJHt0aGlzLmluaXRpYWxTaXplX31weGApO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NDQUxFLCB0aGlzLmZnU2NhbGVfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0xFRlQsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy5sZWZ0fXB4YCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9UT1AsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy50b3B9cHhgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0VW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIGNvbnN0IHtVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCkpO1xuICB9XG5cbiAgaGFuZGxlQmx1cigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEBleHRlbmRzIE1EQ0NvbXBvbmVudDwhTURDUmlwcGxlRm91bmRhdGlvbj5cbiAqL1xuY2xhc3MgTURDUmlwcGxlIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqIEBwYXJhbSB7Li4uP30gYXJncyAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMudW5ib3VuZGVkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7e2lzVW5ib3VuZGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpfT19IG9wdGlvbnNcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZX1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290LCB7aXNVbmJvdW5kZWQgPSB1bmRlZmluZWR9ID0ge30pIHtcbiAgICBjb25zdCByaXBwbGUgPSBuZXcgTURDUmlwcGxlKHJvb3QpO1xuICAgIC8vIE9ubHkgb3ZlcnJpZGUgdW5ib3VuZGVkIGJlaGF2aW9yIGlmIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgIGlmIChpc1VuYm91bmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByaXBwbGUudW5ib3VuZGVkID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaXNVbmJvdW5kZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVJpcHBsZUNhcGFibGVTdXJmYWNlfSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBZGFwdGVyKGluc3RhbmNlKSB7XG4gICAgY29uc3QgTUFUQ0hFUyA9IHV0aWwuZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gdXRpbC5zdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3cpLFxuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IGluc3RhbmNlLnVuYm91bmRlZCxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gaW5zdGFuY2Uucm9vdF9bTUFUQ0hFU10oJzphY3RpdmUnKSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiBpbnN0YW5jZS5kaXNhYmxlZCxcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gaW5zdGFuY2Uucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKHRhcmdldCkgPT4gaW5zdGFuY2Uucm9vdF8uY29udGFpbnModGFyZ2V0KSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgaW5zdGFuY2Uucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IGluc3RhbmNlLnJvb3RfLnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IGluc3RhbmNlLnJvb3RfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4gKHt4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldH0pLFxuICAgIH07XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0IHVuYm91bmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldCB1bmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgdGhpcy51bmJvdW5kZWRfID0gQm9vbGVhbih1bmJvdW5kZWQpO1xuICAgIHRoaXMuc2V0VW5ib3VuZGVkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3N1cmUgQ29tcGlsZXIgdGhyb3dzIGFuIGFjY2VzcyBjb250cm9sIGVycm9yIHdoZW4gZGlyZWN0bHkgYWNjZXNzaW5nIGFcbiAgICogcHJvdGVjdGVkIG9yIHByaXZhdGUgcHJvcGVydHkgaW5zaWRlIGEgZ2V0dGVyL3NldHRlciwgbGlrZSB1bmJvdW5kZWQgYWJvdmUuXG4gICAqIEJ5IGFjY2Vzc2luZyB0aGUgcHJvdGVjdGVkIHByb3BlcnR5IGluc2lkZSBhIG1ldGhvZCwgd2Ugc29sdmUgdGhhdCBwcm9ibGVtLlxuICAgKiBUaGF0J3Mgd2h5IHRoaXMgZnVuY3Rpb24gZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VW5ib3VuZGVkXygpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFVuYm91bmRlZCh0aGlzLnVuYm91bmRlZF8pO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5hY3RpdmF0ZSgpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmxheW91dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVGb3VuZGF0aW9ufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihNRENSaXBwbGUuY3JlYXRlQWRhcHRlcih0aGlzKSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLnVuYm91bmRlZCA9ICdtZGNSaXBwbGVJc1VuYm91bmRlZCcgaW4gdGhpcy5yb290Xy5kYXRhc2V0O1xuICB9XG59XG5cbi8qKlxuICogU2VlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGZvciBtb3JlIGRldGFpbHMgb24gd2hlbiB0byB1c2UgcmlwcGxlcy5cbiAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9tb3Rpb24vY2hvcmVvZ3JhcGh5Lmh0bWwjY2hvcmVvZ3JhcGh5LWNyZWF0aW9uXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIFJpcHBsZUNhcGFibGVTdXJmYWNlIHt9XG5cbi8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS5yb290XztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGJsZWVkcyBvdXQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLnVuYm91bmRlZDtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGlzIGF0dGFjaGVkIHRvIGEgZGlzYWJsZWQgY29tcG9uZW50LlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUuZGlzYWJsZWQ7XG5cbmV4cG9ydCB7TURDUmlwcGxlLCBNRENSaXBwbGVGb3VuZGF0aW9uLCBSaXBwbGVDYXBhYmxlU3VyZmFjZSwgdXRpbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYiBJbmRpY2F0b3IuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGFiIEluZGljYXRvciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGFiSW5kaWNhdG9yQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzc05hbWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCByZWN0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBjb250ZW50IGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldENvbnRlbnRTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiSW5kaWNhdG9yQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy10YWItaW5kaWNhdG9yLS1hY3RpdmUnLFxuICBGQURFOiAnbWRjLXRhYi1pbmRpY2F0b3ItLWZhZGUnLFxuICBOT19UUkFOU0lUSU9OOiAnbWRjLXRhYi1pbmRpY2F0b3ItLW5vLXRyYW5zaXRpb24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWItaW5kaWNhdG9yX19jb250ZW50Jyxcbn07XG5cbmV4cG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RhYkluZGljYXRvckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiSW5kaWNhdG9yQWRhcHRlcj59XG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiSW5kaWNhdG9yQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJJbmRpY2F0b3JBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdDogKCkgPT4ge30sXG4gICAgICBzZXRDb250ZW50U3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGluZGljYXRvclxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqIEBhYnN0cmFjdCAqL1xuICBkZWFjdGl2YXRlKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGV4dGVuZHMgTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbiB7XG4gIC8qKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0ICovXG4gIGFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgbm8gaW5kaWNhdG9yIGlzIHByZXNlbnQgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIGFuIGluZGljYXRvclxuICAgIC8vIG1heSBiZSBhY3RpdmF0ZWQgd2l0aG91dCBhIHByaW9yIGluZGljYXRvciBzdGF0ZVxuICAgIGlmICghcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgYW5pbWF0aW9uIHVzZXMgdGhlIEZMSVAgYXBwcm9hY2guIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGl0IGF0IHRoZSBsaW5rIGJlbG93OlxuICAgIC8vIGh0dHBzOi8vYWVyb3R3aXN0LmNvbS9ibG9nL2ZsaXAteW91ci1hbmltYXRpb25zL1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcmV2aW91cyBpbmRpY2F0b3JcbiAgICBjb25zdCBjdXJyZW50Q2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgd2lkdGhEZWx0YSA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC53aWR0aCAvIGN1cnJlbnRDbGllbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IHhQb3NpdGlvbiA9IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdC5sZWZ0IC0gY3VycmVudENsaWVudFJlY3QubGVmdDtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5OT19UUkFOU0lUSU9OKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgke3hQb3NpdGlvbn1weCkgc2NhbGVYKCR7d2lkdGhEZWx0YX0pYCk7XG5cbiAgICAvLyBGb3JjZSByZXBhaW50IGJlZm9yZSB1cGRhdGluZyBjbGFzc2VzIGFuZCB0cmFuc2Zvcm0gdG8gZW5zdXJlIHRoZSB0cmFuc2Zvcm0gcHJvcGVybHkgdGFrZXMgZWZmZWN0XG4gICAgdGhpcy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLk5PX1RSQU5TSVRJT04pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJycpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYkluZGljYXRvckZvdW5kYXRpb259XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24ge1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuaW1wb3J0IE1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vc2xpZGluZy1mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGYWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZmFkaW5nLWZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYkluZGljYXRvciBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENUYWJJbmRpY2F0b3J9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiSW5kaWNhdG9yKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAdHlwZSB7P0VsZW1lbnR9ICovXG4gICAgdGhpcy5jb250ZW50XztcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5jb250ZW50XyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLnN0cmluZ3MuQ09OVEVOVF9TRUxFQ1RPUik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQ29udGVudENsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkluZGljYXRvckZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gLyoqIEB0eXBlIHshTURDVGFiSW5kaWNhdG9yQWRhcHRlcn0gKi8gKE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB0aGlzLmNvbnRlbnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgc2V0Q29udGVudFN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT4gdGhpcy5jb250ZW50Xy5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSksXG4gICAgfSkpO1xuXG4gICAgaWYgKHRoaXMucm9vdF8uY2xhc3NMaXN0LmNvbnRhaW5zKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GQURFKSkge1xuICAgICAgcmV0dXJuIG5ldyBNRENGYWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uKGFkYXB0ZXIpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gdGhlIHNsaWRpbmcgaW5kaWNhdG9yXG4gICAgcmV0dXJuIG5ldyBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7TURDVGFiSW5kaWNhdG9yLCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLCBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiwgTURDRmFkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogTURDVGFiRGltZW5zaW9ucyBwcm92aWRlcyBkZXRhaWxzIGFib3V0IHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlcyBvZiB0aGUgVGFiXG4gKiByb290IGVsZW1lbnQgYW5kIHRoZSBUYWIgY29udGVudCBlbGVtZW50LiBUaGVzZSB2YWx1ZXMgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBUYWIgd2l0aCByZXNwZWN0IGl0J3MgcGFyZW50IGNvbnRhaW5lci5cbiAqIEB0eXBlZGVmIHt7cm9vdExlZnQ6IG51bWJlciwgcm9vdFJpZ2h0OiBudW1iZXIsIGNvbnRlbnRMZWZ0OiBudW1iZXIsIGNvbnRlbnRSaWdodDogbnVtYmVyfX1cbiAqL1xubGV0IE1EQ1RhYkRpbWVuc2lvbnM7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYi5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gYWRkXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzTmFtZSBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb290IGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0ck5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBzbyBnaXZlIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgaW5kaWNhdG9yIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QgVGhlIGNsaWVudCByZWN0IG9mIHRoZSBwcmV2aW91c2x5IGFjdGl2YXRlZCBpbmRpY2F0b3JcbiAgICovXG4gIGFjdGl2YXRlSW5kaWNhdG9yKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge31cblxuICAvKiogRGVhY3RpdmF0ZXMgdGhlIGluZGljYXRvci4gKi9cbiAgZGVhY3RpdmF0ZUluZGljYXRvcigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBNRENUYWI6aW50ZXJhY3RlZCBldmVudCBmb3IgdXNlIGJ5IHBhcmVudCBjb21wb25lbnRzXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGVkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0TGVmdCB2YWx1ZSBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggdmFsdWUgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXRMZWZ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbnRlbnRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggb2YgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q29udGVudE9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogQXBwbGllcyBmb2N1cyB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAqL1xuICBmb2N1cygpIHt9XG59XG5cbmV4cG9ydCB7TURDVGFiRGltZW5zaW9ucywgTURDVGFiQWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBQ1RJVkU6ICdtZGMtdGFiLS1hY3RpdmUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX1NFTEVDVEVEOiAnYXJpYS1zZWxlY3RlZCcsXG4gIFJJUFBMRV9TRUxFQ1RPUjogJy5tZGMtdGFiX19yaXBwbGUnLFxuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWJfX2NvbnRlbnQnLFxuICBUQUJfSU5ESUNBVE9SX1NFTEVDVE9SOiAnLm1kYy10YWItaW5kaWNhdG9yJyxcbiAgVEFCSU5ERVg6ICd0YWJJbmRleCcsXG4gIElOVEVSQUNURURfRVZFTlQ6ICdNRENUYWI6aW50ZXJhY3RlZCcsXG59O1xuXG5leHBvcnQge1xuICBjc3NDbGFzc2VzLFxuICBzdHJpbmdzLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiQWRhcHRlciwgTURDVGFiRGltZW5zaW9uc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuaW1wb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICBhY3RpdmF0ZUluZGljYXRvcjogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5kaWNhdG9yOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUludGVyYWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRDb250ZW50T2Zmc2V0TGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZm9jdXM6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYkFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVDbGlja18gPSAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgXCJjbGlja1wiIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGFjdGl2ZSBUYWIgYW5kXG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IGFjdGl2YXRlIGEgVGFiIHRoYXQncyBhbHJlYWR5IGFjdGl2ZS5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUludGVyYWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUYWIncyBhY3RpdmUgc3RhdGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRhYlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX1NFTEVDVEVELCAndHJ1ZScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLlRBQklOREVYLCAnMCcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVJbmRpY2F0b3IocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIFRhYlxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICAvLyBFYXJseSBleGl0XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX1NFTEVDVEVELCAnZmFsc2UnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5UQUJJTkRFWCwgJy0xJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5kaWNhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgVGFiXG4gICAqIEByZXR1cm4geyFNRENUYWJEaW1lbnNpb25zfVxuICAgKi9cbiAgY29tcHV0ZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qgcm9vdFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRMZWZ0KCk7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCBjb250ZW50TGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29udGVudE9mZnNldExlZnQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICByb290TGVmdCxcbiAgICAgIHJvb3RSaWdodDogcm9vdExlZnQgKyByb290V2lkdGgsXG4gICAgICBjb250ZW50TGVmdDogcm9vdExlZnQgKyBjb250ZW50TGVmdCxcbiAgICAgIGNvbnRlbnRSaWdodDogcm9vdExlZnQgKyBjb250ZW50TGVmdCArIGNvbnRlbnRXaWR0aCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENSaXBwbGUsIE1EQ1JpcHBsZUZvdW5kYXRpb24sIFJpcHBsZUNhcGFibGVTdXJmYWNlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4JztcbmltcG9ydCB7TURDVGFiSW5kaWNhdG9yLCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvdGFiLWluZGljYXRvci9pbmRleCc7XG5pbXBvcnQge01EQ1RhYkFkYXB0ZXIsIE1EQ1RhYkRpbWVuc2lvbnN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCBNRENUYWJGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDVGFiRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAcHJpdmF0ZSB7P01EQ1JpcHBsZX0gKi9cbiAgICB0aGlzLnJpcHBsZV87XG4gICAgLyoqIEBwcml2YXRlIHs/TURDVGFiSW5kaWNhdG9yfSAqL1xuICAgIHRoaXMudGFiSW5kaWNhdG9yXztcbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuY29udGVudF87XG5cbiAgICAvKiogQHByaXZhdGUgez9GdW5jdGlvbn0gKi9cbiAgICB0aGlzLmhhbmRsZUNsaWNrXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENUYWJ9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiKHJvb3QpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShcbiAgICByaXBwbGVGYWN0b3J5ID0gKGVsLCBmb3VuZGF0aW9uKSA9PiBuZXcgTURDUmlwcGxlKGVsLCBmb3VuZGF0aW9uKSxcbiAgICB0YWJJbmRpY2F0b3JGYWN0b3J5ID0gKGVsKSA9PiBuZXcgTURDVGFiSW5kaWNhdG9yKGVsKSkge1xuICAgIGNvbnN0IHJpcHBsZVN1cmZhY2UgPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlJJUFBMRV9TRUxFQ1RPUik7XG4gICAgY29uc3QgcmlwcGxlQWRhcHRlciA9IE9iamVjdC5hc3NpZ24oTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIoLyoqIEB0eXBlIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9ICovICh0aGlzKSksIHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiByaXBwbGVTdXJmYWNlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiByaXBwbGVTdXJmYWNlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IHJpcHBsZVN1cmZhY2Uuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IHJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihyaXBwbGVBZGFwdGVyKTtcbiAgICB0aGlzLnJpcHBsZV8gPSByaXBwbGVGYWN0b3J5KHRoaXMucm9vdF8sIHJpcHBsZUZvdW5kYXRpb24pO1xuXG4gICAgY29uc3QgdGFiSW5kaWNhdG9yRWxlbWVudCA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX0lORElDQVRPUl9TRUxFQ1RPUik7XG4gICAgdGhpcy50YWJJbmRpY2F0b3JfID0gdGFiSW5kaWNhdG9yRmFjdG9yeSh0YWJJbmRpY2F0b3JFbGVtZW50KTtcblxuICAgIHRoaXMuY29udGVudF8gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3IoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMuaGFuZGxlQ2xpY2tfID0gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVDbGljay5iaW5kKHRoaXMuZm91bmRhdGlvbl8pO1xuICAgIHRoaXMubGlzdGVuKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bmxpc3RlbignY2xpY2snLCAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKHRoaXMuaGFuZGxlQ2xpY2tfKSk7XG4gICAgdGhpcy5yaXBwbGVfLmRlc3Ryb3koKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYkZvdW5kYXRpb24oXG4gICAgICAvKiogQHR5cGUgeyFNRENUYWJBZGFwdGVyfSAqLyAoe1xuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHRoaXMucm9vdF8uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcbiAgICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgICBhY3RpdmF0ZUluZGljYXRvcjogKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkgPT4gdGhpcy50YWJJbmRpY2F0b3JfLmFjdGl2YXRlKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCksXG4gICAgICAgIGRlYWN0aXZhdGVJbmRpY2F0b3I6ICgpID0+IHRoaXMudGFiSW5kaWNhdG9yXy5kZWFjdGl2YXRlKCksXG4gICAgICAgIG5vdGlmeUludGVyYWN0ZWQ6ICgpID0+IHRoaXMuZW1pdChNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RFRF9FVkVOVCwge3RhYjogdGhpc30sIHRydWUgLyogYnViYmxlICovKSxcbiAgICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRMZWZ0LFxuICAgICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRXaWR0aCxcbiAgICAgICAgZ2V0Q29udGVudE9mZnNldExlZnQ6ICgpID0+IHRoaXMuY29udGVudF8ub2Zmc2V0TGVmdCxcbiAgICAgICAgZ2V0Q29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLmNvbnRlbnRfLm9mZnNldFdpZHRoLFxuICAgICAgICBmb2N1czogKCkgPT4gdGhpcy5yb290Xy5mb2N1cygpLFxuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgdGFiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmlzQWN0aXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWJcbiAgICogQHBhcmFtIHshQ2xpZW50UmVjdD19IGNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGUoY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSB0YWJcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kaWNhdG9yJ3MgY2xpZW50IHJlY3RcbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJJbmRpY2F0b3JfLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJEaW1lbnNpb25zfVxuICAgKi9cbiAgY29tcHV0ZURpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uY29tcHV0ZURpbWVuc2lvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSB0YWJcbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMucm9vdF8uZm9jdXMoKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYiwgTURDVGFiRm91bmRhdGlvbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogTURDVGFiU2Nyb2xsZXJBbmltYXRpb24gY29udGFpbnMgdGhlIHZhbHVlcyByZXF1aXJlZCBmb3IgYW5pbWF0aW5nIGZyb20gdGhlXG4gKiBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvbi4gVGhlIFwiZmluYWxTY3JvbGxQb3NpdGlvblwiXG4gKiB2YWx1ZSByZXByZXNlbnRzIHRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uIHdoaWxlIHRoZSBcInNjcm9sbERlbHRhXCIgdmFsdWUgaXMgdGhlXG4gKiBjb3JyZXNwb25kaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgc2Nyb2xsIGNvbnRlbnQuIFRvZ2V0aGVyLFxuICogdGhleSBjcmVhdGUgdGhlIGFuaW1hdGlvbiBieSBmaXJzdCB1cGRhdGluZyB0aGUgc2Nyb2xsIHZhbHVlIHRoZW4gYXBwbHlpbmdcbiAqIHRoZSB0cmFuc2Zvcm1hdGlvbiBhbmQgYW5pbWF0aW5nIHRoZSB0cmFuc2l0aW9uLiBCb3RoIHBpZWNlcyBhcmUgbmVjZXNzYXJ5XG4gKiBmb3IgdGhlIHNjcm9sbCBhbmltYXRpb24gdG8gd29yay4gVGhlIHZhbHVlcyBhcmUgdXNlZCBhcy1pcyBieSB0aGUgdGFiXG4gKiBzY3JvbGxlciBhbmltYXRpb24gbWV0aG9kLCBlbnN1cmluZyB0aGF0IGFsbCBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgc2Nyb2xsXG4gKiBwb3NpdGlvbiBvciB0cmFuc2Zvcm1hdGlvbiBpcyBhYnN0cmFjdGVkIGF3YXkgZnJvbSB0aGUgYW5pbWF0aW9uIG1ldGhvZC5cbiAqIEB0eXBlZGVmIHt7ZmluYWxTY3JvbGxQb3NpdGlvbjogbnVtYmVyLCBzY3JvbGxEZWx0YTogbnVtYmVyfX1cbiAqL1xubGV0IE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uO1xuXG4vKipcbiAqIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzIHJlcHJlc2VudHMgdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzIG9mIHRoZVxuICogc2Nyb2xsIGNvbnRlbnQuIFRoZXNlIHZhbHVlcyB2YXJ5IGRlcGVuZGluZyBvbiBob3cgc2Nyb2xsaW5nIGluIFJUTCBpc1xuICogaW1wbGVtZW50ZWQgYnkgdGhlIGJyb3dzZXIuIE9uZSB2YWx1ZSBpcyBhbHdheXMgMCBhbmQgb25lIHZhbHVlIGlzIGFsd2F5c1xuICogdGhlIG1heCBzY3JvbGxhYmxlIHZhbHVlIGFzIGVpdGhlciBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIuXG4gKiBAdHlwZWRlZiB7e2xlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcztcblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGFiIFNjcm9sbGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRhYiAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzc05hbWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGFkZFxuICAgKi9cbiAgYWRkU2Nyb2xsQXJlYUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyBnaXZlbiBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2dFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yKGV2dFRhcmdldCwgc2VsZWN0b3IpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgYXJlYSBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBUaGUgc3R5bGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHkocHJvcE5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Nyb2xsIGNvbnRlbnQgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlIG9mIHRoZSBnaXZlbiBjc3MgcHJvcGVydHkgYHByb3BlcnR5TmFtZWAuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGdldENvbXB1dGVkU3R5bGUoLi4uKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKHByb3BlcnR5TmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2Nyb2xsTGVmdCB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsTGVmdCBUaGUgbmV3IHNjcm9sbExlZnQgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KHNjcm9sbExlZnQpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpdGR0aCBvZiB0aGUgc2Nyb2xsIGFyZWEgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBicm93c2VyJ3MgaG9yaXpvbnRhbCBzY3JvbGxiYXJzIChpbiBweCkuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0KCkge31cbn1cblxuZXhwb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXMsIE1EQ1RhYlNjcm9sbGVyQWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBTklNQVRJTkc6ICdtZGMtdGFiLXNjcm9sbGVyLS1hbmltYXRpbmcnLFxuICBTQ1JPTExfVEVTVDogJ21kYy10YWItc2Nyb2xsZXJfX3Rlc3QnLFxuICBTQ1JPTExfQVJFQV9TQ1JPTEw6ICdtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYS0tc2Nyb2xsJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJFQV9TRUxFQ1RPUjogJy5tZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYScsXG4gIENPTlRFTlRfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnQnLFxufTtcblxuZXhwb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQWRhcHRlciwgTURDVGFiU2Nyb2xsZXJBbmltYXRpb259IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIGN1cnJlbnQgc2Nyb2xsWCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNsYXRlWCBUaGUgY3VycmVudCB0cmFuc2xhdGVYIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVEwgZnJvbSAnLi9ydGwtc2Nyb2xsZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYlNjcm9sbGVyUlRMfVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IHtyaWdodH0gPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIC8vIFNjcm9sbCB2YWx1ZXMgb24gbW9zdCBicm93c2VycyBhcmUgaW50cyBpbnN0ZWFkIG9mIGZsb2F0cyBzbyB3ZSByb3VuZFxuICAgIHJldHVybiBNYXRoLnJvdW5kKHJpZ2h0IC0gY3VycmVudFNjcm9sbExlZnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGVkZ2VzLnJpZ2h0IC0gc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCkge1xuICAgIHJldHVybiBzY3JvbGxYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBjb250ZW50V2lkdGggLSByb290V2lkdGgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMubGVmdCwgc2Nyb2xsWCksIGVkZ2VzLnJpZ2h0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJTY3JvbGxlclJUTH1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlIGV4dGVuZHMgTURDVGFiU2Nyb2xsZXJSVEwge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvblJUTCh0cmFuc2xhdGVYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodHJhbnNsYXRlWCAtIGN1cnJlbnRTY3JvbGxMZWZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKC1zY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjbGFtcGVkU2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIGluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGN1cnJlbnRTY3JvbGxMZWZ0IC0gc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNsYXRlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7XG4gICAgcmV0dXJuIHNjcm9sbFggLSB0cmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogcm9vdFdpZHRoIC0gY29udGVudFdpZHRoLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZWRnZXMucmlnaHQsIHNjcm9sbFgpLCBlZGdlcy5sZWZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDVGFiU2Nyb2xsZXJSVEx9XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIGV4dGVuZHMgTURDVGFiU2Nyb2xsZXJSVEwge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIC8vIFNjcm9sbCB2YWx1ZXMgb24gbW9zdCBicm93c2VycyBhcmUgaW50cyBpbnN0ZWFkIG9mIGZsb2F0cyBzbyB3ZSByb3VuZFxuICAgIHJldHVybiBNYXRoLnJvdW5kKGN1cnJlbnRTY3JvbGxMZWZ0IC0gdHJhbnNsYXRlWCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgc2Nyb2xsVG9SVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjdXJyZW50U2Nyb2xsTGVmdCAtIGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIGluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgY29uc3QgY2xhbXBlZFNjcm9sbExlZnQgPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKGN1cnJlbnRTY3JvbGxMZWZ0ICsgc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY3VycmVudFNjcm9sbExlZnQgLSBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxYLCB0cmFuc2xhdGVYKSB7XG4gICAgcmV0dXJuIHNjcm9sbFggKyB0cmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogY29udGVudFdpZHRoIC0gcm9vdFdpZHRoLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMucmlnaHQsIHNjcm9sbFgpLCBlZGdlcy5sZWZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJTY3JvbGxlclJUTFJldmVyc2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcywgTURDVGFiU2Nyb2xsZXJBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQgZnJvbSAnLi9ydGwtZGVmYXVsdC1zY3JvbGxlcic7XG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZSBmcm9tICcuL3J0bC1uZWdhdGl2ZS1zY3JvbGxlcic7XG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIGZyb20gJy4vcnRsLXJldmVyc2Utc2Nyb2xsZXInO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJTY3JvbGxlckFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiU2Nyb2xsZXJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yOiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGFkZFNjcm9sbEFyZWFDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxBcmVhU3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogKCkgPT4ge30sXG4gICAgICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdDogKCkgPT4ge30sXG4gICAgICBjb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3Q6ICgpID0+IHt9LFxuICAgICAgY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYm9vbGVhbiBjb250cm9scyB3aGV0aGVyIHdlIHNob3VsZCBoYW5kbGUgdGhlIHRyYW5zaXRpb25lbmQgYW5kIGludGVyYWN0aW9uIGV2ZW50cyBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQW5pbWF0aW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIE1EQ1RhYlNjcm9sbGVyUlRMIGluc3RhbmNlIHZhcmllcyBwZXIgYnJvd3NlciBhbmQgYWxsb3dzIHVzIHRvIGVuY2Fwc3VsYXRlIHRoZSBwZWN1bGlhciBicm93c2VyIGJlaGF2aW9yXG4gICAgICogb2YgUlRMIHNjcm9sbGluZyBpbiBpdCdzIG93biBjbGFzcy5cbiAgICAgKiBAcHJpdmF0ZSB7P01EQ1RhYlNjcm9sbGVyUlRMfVxuICAgICAqL1xuICAgIHRoaXMucnRsU2Nyb2xsZXJJbnN0YW5jZV87XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIENvbXB1dGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGVpZ2h0IG9uIHNjcm9sbGVyIHdpdGggb3ZlcmZsb3cgaW5pdGlhbGx5IGhpZGRlbiwgdGhlbiB1cGRhdGUgb3ZlcmZsb3cgdG8gc2Nyb2xsXG4gICAgLy8gYW5kIGltbWVkaWF0ZWx5IGFkanVzdCBib3R0b20gbWFyZ2luIHRvIGF2b2lkIHRoZSBzY3JvbGxiYXIgaW5pdGlhbGx5IGFwcGVhcmluZyBiZWZvcmUgSlMgcnVucy5cbiAgICBjb25zdCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nLCAtaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCArICdweCcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkU2Nyb2xsQXJlYUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlNDUk9MTF9BUkVBX1NDUk9MTCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGN1cnJlbnQgdmlzdWFsIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUN1cnJlbnRTY3JvbGxQb3NpdGlvblJUTF8oKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VHJhbnNsYXRlWCA9IHRoaXMuY2FsY3VsYXRlQ3VycmVudFRyYW5zbGF0ZVhfKCk7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICByZXR1cm4gc2Nyb2xsTGVmdCAtIGN1cnJlbnRUcmFuc2xhdGVYO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW50ZXJhY3Rpb24gZXZlbnRzIHRoYXQgb2NjdXIgZHVyaW5nIHRyYW5zaXRpb25cbiAgICovXG4gIGhhbmRsZUludGVyYWN0aW9uKCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgd2UgYXJlbid0IGFuaW1hdGluZ1xuICAgIGlmICghdGhpcy5pc0FuaW1hdGluZ18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IG90aGVyIGV2ZW50IGxpc3RlbmVycyBmcm9tIGhhbmRsaW5nIHRoaXMgZXZlbnRcbiAgICB0aGlzLnN0b3BTY3JvbGxBbmltYXRpb25fKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgd2UgYXJlbid0IGFuaW1hdGluZyBvciB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBhIGRpZmZlcmVudCBlbGVtZW50LlxuICAgIGlmICghdGhpcy5pc0FuaW1hdGluZ19cbiAgICAgIHx8ICF0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yKGV2dC50YXJnZXQsIE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBzY3JvbGwgdmFsdWUgYnkgdGhlIHNjcm9sbFhJbmNyZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhJbmNyZW1lbnQgVGhlIHZhbHVlIGJ5IHdoaWNoIHRvIGluY3JlbWVudCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCkge1xuICAgIC8vIEVhcmx5IGV4aXQgZm9yIG5vbi1vcGVyYXRpb25hbCBpbmNyZW1lbnQgdmFsdWVzXG4gICAgaWYgKHNjcm9sbFhJbmNyZW1lbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50U2Nyb2xsUlRMXyhzY3JvbGxYSW5jcmVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmluY3JlbWVudFNjcm9sbF8oc2Nyb2xsWEluY3JlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gc2Nyb2xsWCB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsWCkge1xuICAgIGlmICh0aGlzLmlzUlRMXygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxUb1JUTF8oc2Nyb2xsWCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxUb18oc2Nyb2xsWCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiB0aGUgTURDVGFiU2Nyb2xsZXJSVExcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyUlRMfVxuICAgKi9cbiAgZ2V0UlRMU2Nyb2xsZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfKSB7XG4gICAgICB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfID0gdGhpcy5ydGxTY3JvbGxlckZhY3RvcnlfKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucnRsU2Nyb2xsZXJJbnN0YW5jZV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRlWCB2YWx1ZSBmcm9tIGEgQ1NTIG1hdHJpeCB0cmFuc2Zvcm0gZnVuY3Rpb24gc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWUoJ3RyYW5zZm9ybScpO1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgbm8gdHJhbnNmb3JtIGlzIHByZXNlbnRcbiAgICBpZiAodHJhbnNmb3JtVmFsdWUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRyYW5zZm9ybSB2YWx1ZSBjb21lcyBiYWNrIGFzIGEgbWF0cml4IHRyYW5zZm9ybWF0aW9uIGluIHRoZSBmb3JtXG4gICAgLy8gb2YgYG1hdHJpeChhLCBiLCBjLCBkLCB0eCwgdHkpYC4gV2Ugb25seSBjYXJlIGFib3V0IHR4ICh0cmFuc2xhdGVYKSBzb1xuICAgIC8vIHdlJ3JlIGdvaW5nIHRvIGdyYWIgYWxsIHRoZSBwYXJlbnRoZXNpemVkIHZhbHVlcywgc3RyaXAgb3V0IHR4LCBhbmRcbiAgICAvLyBwYXJzZSBpdC5cbiAgICBjb25zdCByZXN1bHRzID0gL1xcKCguKylcXCkvLmV4ZWModHJhbnNmb3JtVmFsdWUpWzFdO1xuICAgIGNvbnN0IHBhcnRzID0gcmVzdWx0cy5zcGxpdCgnLCcpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnRzWzRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGEgc2FmZSBzY3JvbGwgdmFsdWUgdGhhdCBpcyA+IDAgYW5kIDwgdGhlIG1heCBzY3JvbGwgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIGRpc3RhbmNlIHRvIHNjcm9sbFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChlZGdlcy5sZWZ0LCBzY3JvbGxYKSwgZWRnZXMucmlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVDdXJyZW50U2Nyb2xsUG9zaXRpb25SVExfKCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIHJldHVybiB0aGlzLmdldFJUTFNjcm9sbGVyKCkuZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCkge1xuICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3Qgcm9vdFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGgoKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9ICovICh7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGNvbnRlbnRXaWR0aCAtIHJvb3RXaWR0aCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBzY3JvbGwgbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxUb18oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxYID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IHNhZmVTY3JvbGxYID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhzY3JvbGxYKTtcbiAgICBjb25zdCBzY3JvbGxEZWx0YSA9IHNhZmVTY3JvbGxYIC0gY3VycmVudFNjcm9sbFg7XG4gICAgdGhpcy5hbmltYXRlXygvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IHNhZmVTY3JvbGxYLFxuICAgICAgc2Nyb2xsRGVsdGE6IHNjcm9sbERlbHRhLFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSVEwgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsVG9SVExfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmdldFJUTFNjcm9sbGVyKCkuc2Nyb2xsVG9SVEwoc2Nyb2xsWCk7XG4gICAgdGhpcy5hbmltYXRlXyhhbmltYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGluY3JlbWVudCBzY3JvbGwgbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uIGluY3JlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbFggPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsWCA9IHNjcm9sbFggKyBjdXJyZW50U2Nyb2xsWDtcbiAgICBjb25zdCBzYWZlU2Nyb2xsWCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8odGFyZ2V0U2Nyb2xsWCk7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBzYWZlU2Nyb2xsWCAtIGN1cnJlbnRTY3JvbGxYO1xuICAgIHRoaXMuYW5pbWF0ZV8oLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBzYWZlU2Nyb2xsWCxcbiAgICAgIHNjcm9sbERlbHRhOiBzY3JvbGxEZWx0YSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgaW5jcmVtZW5ldCBzY3JvbGwgUlRMIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvbiBSVEwgaW5jcmVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVExfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmdldFJUTFNjcm9sbGVyKCkuaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpO1xuICAgIHRoaXMuYW5pbWF0ZV8oYW5pbWF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlcyB0aGUgdGFiIHNjcm9sbGluZ1xuICAgKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gdG8gYXBwbHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVfKGFuaW1hdGlvbikge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgdHJhbnNsYXRlWCBpcyAwLCB3aGljaCBtZWFucyB0aGVyZSdzIG5vIGFuaW1hdGlvbiB0byBwZXJmb3JtXG4gICAgaWYgKGFuaW1hdGlvbi5zY3JvbGxEZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcFNjcm9sbEFuaW1hdGlvbl8oKTtcbiAgICAvLyBUaGlzIGFuaW1hdGlvbiB1c2VzIHRoZSBGTElQIGFwcHJvYWNoLlxuICAgIC8vIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL2Flcm90d2lzdC5jb20vYmxvZy9mbGlwLXlvdXItYW5pbWF0aW9ucy9cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KGFuaW1hdGlvbi5maW5hbFNjcm9sbFBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgke2FuaW1hdGlvbi5zY3JvbGxEZWx0YX1weClgKTtcbiAgICAvLyBGb3JjZSByZXBhaW50XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3QoKTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCAnbm9uZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHNjcm9sbCBhbmltYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0b3BTY3JvbGxBbmltYXRpb25fKCkge1xuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gZmFsc2U7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVgoMHB4KScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoY3VycmVudFNjcm9sbFBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uXygpIHtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNsYXRlWCA9IHRoaXMuY2FsY3VsYXRlQ3VycmVudFRyYW5zbGF0ZVhfKCk7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UlRMU2Nyb2xsZXIoKS5nZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbihzY3JvbGxMZWZ0LCBjdXJyZW50VHJhbnNsYXRlWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbExlZnQgLSBjdXJyZW50VHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBSVEwgU2Nyb2xsZXIgdG8gdXNlXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlclJUTH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ0bFNjcm9sbGVyRmFjdG9yeV8oKSB7XG4gICAgLy8gQnJvd3NlcnMgaGF2ZSB0aHJlZSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIG9mIHNjcm9sbExlZnQgaW4gUlRMIG1vZGUsXG4gICAgLy8gZGVwZW5kZW50IG9uIHRoZSBicm93c2VyLiBUaGUgYmVoYXZpb3IgaXMgYmFzZWQgb2ZmIHRoZSBtYXggTFRSXG4gICAgLy8gc2Nyb2xsbGVmdCB2YWx1ZSBhbmQgMC5cbiAgICAvL1xuICAgIC8vICogRGVmYXVsdCBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogMFxuICAgIC8vICAgIC0gUmlnaHQtbW9zdCB2YWx1ZTogTWF4IExUUiBzY3JvbGxMZWZ0IHZhbHVlXG4gICAgLy9cbiAgICAvLyAqIE5lZ2F0aXZlIHNjcm9sbGluZyBpbiBSVEwgKlxuICAgIC8vICAgIC0gTGVmdC1tb3N0IHZhbHVlOiBOZWdhdGVkIG1heCBMVFIgc2Nyb2xsTGVmdCB2YWx1ZVxuICAgIC8vICAgIC0gUmlnaHQtbW9zdCB2YWx1ZTogMFxuICAgIC8vXG4gICAgLy8gKiBSZXZlcnNlIHNjcm9sbGluZyBpbiBSVEwgKlxuICAgIC8vICAgIC0gTGVmdC1tb3N0IHZhbHVlOiBNYXggTFRSIHNjcm9sbExlZnQgdmFsdWVcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IDBcbiAgICAvL1xuICAgIC8vIFdlIHVzZSB0aG9zZSBwcmluY2lwbGVzIGJlbG93IHRvIGRldGVybWluZSB3aGljaCBSVEwgc2Nyb2xsTGVmdFxuICAgIC8vIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gICAgY29uc3QgaW5pdGlhbFNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCAtIDEpO1xuICAgIGNvbnN0IG5ld1Njcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG5cbiAgICAvLyBJZiB0aGUgbmV3U2Nyb2xsTGVmdCB2YWx1ZSBpcyBuZWdhdGl2ZSx0aGVuIHdlIGtub3cgdGhhdCB0aGUgYnJvd3NlciBoYXNcbiAgICAvLyBpbXBsZW1lbnRlZCBuZWdhdGl2ZSBSVEwgc2Nyb2xsaW5nLCBzaW5jZSBhbGwgb3RoZXIgaW1wbGVtZW50YXRpb25zIGhhdmVcbiAgICAvLyBvbmx5IHBvc2l0aXZlIHZhbHVlcy5cbiAgICBpZiAobmV3U2Nyb2xsTGVmdCA8IDApIHtcbiAgICAgIC8vIFVuZG8gdGhlIHNjcm9sbExlZnQgdGVzdCBjaGVja1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCk7XG4gICAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMTmVnYXRpdmUodGhpcy5hZGFwdGVyXyk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdENsaWVudFJlY3QgPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvbnRlbnRDbGllbnRSZWN0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3QoKTtcbiAgICBjb25zdCByaWdodEVkZ2VEZWx0YSA9IE1hdGgucm91bmQoY29udGVudENsaWVudFJlY3QucmlnaHQgLSByb290Q2xpZW50UmVjdC5yaWdodCk7XG4gICAgLy8gVW5kbyB0aGUgc2Nyb2xsTGVmdCB0ZXN0IGNoZWNrXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChpbml0aWFsU2Nyb2xsTGVmdCk7XG5cbiAgICAvLyBCeSBjYWxjdWxhdGluZyB0aGUgY2xpZW50UmVjdCBvZiB0aGUgcm9vdCBlbGVtZW50IGFuZCB0aGUgY2xpZW50UmVjdCBvZlxuICAgIC8vIHRoZSBjb250ZW50IGVsZW1lbnQsIHdlIGNhbiBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIHNjcm9sbCB2YWx1ZSBjaGFuZ2VkXG4gICAgLy8gd2hlbiB3ZSBwZXJmb3JtZWQgdGhlIHNjcm9sbExlZnQgc3VidHJhY3Rpb24gYWJvdmUuXG4gICAgaWYgKHJpZ2h0RWRnZURlbHRhID09PSBuZXdTY3JvbGxMZWZ0KSB7XG4gICAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSh0aGlzLmFkYXB0ZXJfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCh0aGlzLmFkYXB0ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNSVExfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZy5cbiAqIEBwcml2YXRlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5sZXQgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF87XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhlaWdodCBvZiBicm93c2VyLXJlbmRlcmVkIGhvcml6b250YWwgc2Nyb2xsYmFycyB1c2luZyBhIHNlbGYtY3JlYXRlZCB0ZXN0IGVsZW1lbnQuXG4gKiBNYXkgcmV0dXJuIDAgKGUuZy4gb24gT1MgWCBicm93c2VycyB1bmRlciBkZWZhdWx0IGNvbmZpZ3VyYXRpb24pLlxuICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRDYWNoZVJlc3VsdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodChkb2N1bWVudE9iaiwgc2hvdWxkQ2FjaGVSZXN1bHQgPSB0cnVlKSB7XG4gIGlmIChzaG91bGRDYWNoZVJlc3VsdCAmJiB0eXBlb2YgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfO1xuICB9XG5cbiAgY29uc3QgZWwgPSBkb2N1bWVudE9iai5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLlNDUk9MTF9URVNUKTtcbiAgZG9jdW1lbnRPYmouYm9keS5hcHBlbmRDaGlsZChlbCk7XG5cbiAgY29uc3QgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgZG9jdW1lbnRPYmouYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cbiAgaWYgKHNob3VsZENhY2hlUmVzdWx0KSB7XG4gICAgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF8gPSBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0O1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gSFRNTEVsZW1lbnRQcm90b3R5cGVcbiAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnRQcm90b3R5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuZXhwb3J0IHtjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCwgZ2V0TWF0Y2hlc1Byb3BlcnR5fTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENDb21wb25lbnQ8IU1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXIgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJ9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDVGFiU2Nyb2xsZXIocm9vdCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuY29udGVudF87XG5cbiAgICAvKiogQHByaXZhdGUgez9FbGVtZW50fSAqL1xuICAgIHRoaXMuYXJlYV87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbig/RXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl87XG5cbiAgICAvKiogQHByaXZhdGUgez9mdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXztcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5hcmVhXyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uc3RyaW5ncy5BUkVBX1NFTEVDVE9SKTtcbiAgICB0aGlzLmNvbnRlbnRfID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbi5zdHJpbmdzLkNPTlRFTlRfU0VMRUNUT1IpO1xuICB9XG5cbiAgaW5pdGlhbFN5bmNXaXRoRE9NKCkge1xuICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fID0gKCkgPT4gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8gPSAoZXZ0KSA9PiB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KTtcblxuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyk7XG4gICAgdGhpcy5hcmVhXy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuY29udGVudF8uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmFyZWFfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMuYXJlYV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLmNvbnRlbnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9ufVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yOiAoZXZ0VGFyZ2V0LCBzZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGV2dFRhcmdldFtNQVRDSEVTXShzZWxlY3Rvcik7XG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgYWRkU2Nyb2xsQXJlYUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLmFyZWFfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5OiAocHJvcCwgdmFsdWUpID0+IHRoaXMuYXJlYV8uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsdWUpLFxuICAgICAgc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT4gdGhpcy5jb250ZW50Xy5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSksXG4gICAgICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZTogKHByb3BOYW1lKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNvbnRlbnRfKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKSxcbiAgICAgIHNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0OiAoc2Nyb2xsWCkgPT4gdGhpcy5hcmVhXy5zY3JvbGxMZWZ0ID0gc2Nyb2xsWCxcbiAgICAgIGdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0OiAoKSA9PiB0aGlzLmFyZWFfLnNjcm9sbExlZnQsXG4gICAgICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuY29udGVudF8ub2Zmc2V0V2lkdGgsXG4gICAgICBnZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuYXJlYV8ub2Zmc2V0V2lkdGgsXG4gICAgICBjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3Q6ICgpID0+IHRoaXMuYXJlYV8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3Q6ICgpID0+IHRoaXMuY29udGVudF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDogKCkgPT4gdXRpbC5jb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodChkb2N1bWVudCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbihhZGFwdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZpc3VhbCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsQ29udGVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRfLm9mZnNldFdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIHNjcm9sbCB2YWx1ZSBieSB0aGUgZ2l2ZW4gYW1vdW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYSW5jcmVtZW50IFRoZSBwaXhlbCB2YWx1ZSBieSB3aGljaCB0byBpbmNyZW1lbnQgdGhlIHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgcGl4ZWwgdmFsdWUgdG8gc2Nyb2xsIHRvXG4gICAqL1xuICBzY3JvbGxUbyhzY3JvbGxYKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zY3JvbGxUbyhzY3JvbGxYKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYlNjcm9sbGVyLCBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24sIHV0aWx9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJEaW1lbnNpb25zfSBmcm9tICdAbWF0ZXJpYWwvdGFiL2FkYXB0ZXInO1xuaW1wb3J0IHtNRENUYWJ9IGZyb20gJ0BtYXRlcmlhbC90YWIvaW5kZXgnO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUYWIgQmFyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRhYiBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RhYkJhckFkYXB0ZXIge1xuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIHBvc2l0aW9uIHRvIHNjcm9sbCB0b1xuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsWCkge31cblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gYnkgdGhlIGdpdmVuIGFtb3VudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWEluY3JlbWVudCBUaGUgYW1vdW50IHRvIGluY3JlbWVudCBzY3JvbGxcbiAgICovXG4gIGluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGwgY29udGVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IGVsZW1lbnQncyBvZmZzZXRXaWR0aFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIFRhYiBCYXIgbGFuZ3VhZ2UgZGlyZWN0aW9uIGlzIFJUTFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gYWN0aXZhdGVcbiAgICovXG4gIHNldEFjdGl2ZVRhYihpbmRleCkge31cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggdGhlIGdpdmVuIGNsaWVudCByZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBhY3RpdmF0ZVxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0fSBjbGllbnRSZWN0IFRoZSBjbGllbnQgcmVjdCBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmUgVGFiIEluZGljYXRvclxuICAgKi9cbiAgYWN0aXZhdGVUYWJBdEluZGV4KGluZGV4LCBjbGllbnRSZWN0KSB7fVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gZGVhY3RpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZVRhYkF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIGZvY3VzXG4gICAqL1xuICBmb2N1c1RhYkF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCByZWN0IG9mIHRoZSB0YWIncyBpbmRpY2F0b3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEByZXR1cm4geyFDbGllbnRSZWN0fVxuICAgKi9cbiAgZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYiBkaW1lbnNpb25zIG9mIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcmV0dXJuIHshTURDVGFiRGltZW5zaW9uc31cbiAgICovXG4gIGdldFRhYkRpbWVuc2lvbnNBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHRhYiBsaXN0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFRhYkxpc3RMZW5ndGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmUgdGFiXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm9jdXNlZCB0YWJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Rm9jdXNlZFRhYkluZGV4KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJ9IHRhYiBUaGUgdGFiIHdob3NlIGluZGV4IHRvIGRldGVybWluXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEluZGV4T2ZUYWIodGFiKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgTURDVGFiQmFyOmFjdGl2YXRlZCBldmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBhY3RpdmF0ZWQgdGFiXG4gICAqL1xuICBub3RpZnlUYWJBY3RpdmF0ZWQoaW5kZXgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkJhckFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBUQUJfQUNUSVZBVEVEX0VWRU5UOiAnTURDVGFiQmFyOmFjdGl2YXRlZCcsXG4gIFRBQl9TQ1JPTExFUl9TRUxFQ1RPUjogJy5tZGMtdGFiLXNjcm9sbGVyJyxcbiAgVEFCX1NFTEVDVE9SOiAnLm1kYy10YWInLFxuICBBUlJPV19MRUZUX0tFWTogJ0Fycm93TGVmdCcsXG4gIEFSUk9XX1JJR0hUX0tFWTogJ0Fycm93UmlnaHQnLFxuICBFTkRfS0VZOiAnRW5kJyxcbiAgSE9NRV9LRVk6ICdIb21lJyxcbiAgRU5URVJfS0VZOiAnRW50ZXInLFxuICBTUEFDRV9LRVk6ICdTcGFjZScsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEVYVFJBX1NDUk9MTF9BTU9VTlQ6IDIwLFxuICBBUlJPV19MRUZUX0tFWUNPREU6IDM3LFxuICBBUlJPV19SSUdIVF9LRVlDT0RFOiAzOSxcbiAgRU5EX0tFWUNPREU6IDM1LFxuICBIT01FX0tFWUNPREU6IDM2LFxuICBFTlRFUl9LRVlDT0RFOiAxMyxcbiAgU1BBQ0VfS0VZQ09ERTogMzIsXG59O1xuXG5leHBvcnQge1xuICBudW1iZXJzLFxuICBzdHJpbmdzLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuaW1wb3J0IHtzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgTURDVGFiQmFyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJEaW1lbnNpb25zfSBmcm9tICdAbWF0ZXJpYWwvdGFiL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuY29uc3QgQUNDRVBUQUJMRV9LRVlTID0gbmV3IFNldCgpO1xuLy8gSUUxMSBoYXMgbm8gc3VwcG9ydCBmb3IgbmV3IFNldCB3aXRoIGl0ZXJhYmxlIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGlzIGJ5IGhhbmRcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5BUlJPV19MRUZUX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuQVJST1dfUklHSFRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5FTkRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5IT01FX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuRU5URVJfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8bnVtYmVyLCBzdHJpbmc+fVxuICovXG5jb25zdCBLRVlDT0RFX01BUCA9IG5ldyBNYXAoKTtcbi8vIElFMTEgaGFzIG5vIHN1cHBvcnQgZm9yIG5ldyBNYXAgd2l0aCBpdGVyYWJsZSBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgdGhpcyBieSBoYW5kXG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5BUlJPV19MRUZUX0tFWUNPREUsIHN0cmluZ3MuQVJST1dfTEVGVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuQVJST1dfUklHSFRfS0VZQ09ERSwgc3RyaW5ncy5BUlJPV19SSUdIVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5EX0tFWUNPREUsIHN0cmluZ3MuRU5EX0tFWSk7XG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5IT01FX0tFWUNPREUsIHN0cmluZ3MuSE9NRV9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5URVJfS0VZQ09ERSwgc3RyaW5ncy5FTlRFUl9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuU1BBQ0VfS0VZQ09ERSwgc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJCYXJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJCYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJCYXJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkJhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgc2Nyb2xsVG86ICgpID0+IHt9LFxuICAgICAgaW5jcmVtZW50U2Nyb2xsOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbENvbnRlbnRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBpc1JUTDogKCkgPT4ge30sXG4gICAgICBzZXRBY3RpdmVUYWI6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGZvY3VzVGFiQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRUYWJJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleE9mVGFiOiAoKSA9PiB7fSxcbiAgICAgIGdldFRhYkxpc3RMZW5ndGg6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5VGFiQWN0aXZhdGVkOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUYWJCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkJhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBhdXRvbWF0aWMgYW5kIG1hbnVhbCBhY3RpdmF0aW9uIG1vZGVzLlxuICAgKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy8jdGFicGFuZWwgZm9yIGV4YW1wbGVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUF1dG9tYXRpY0FjdGl2YXRpb25cbiAgICovXG4gIHNldFVzZUF1dG9tYXRpY0FjdGl2YXRpb24odXNlQXV0b21hdGljQWN0aXZhdGlvbikge1xuICAgIHRoaXMudXNlQXV0b21hdGljQWN0aXZhdGlvbl8gPSB1c2VBdXRvbWF0aWNBY3RpdmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGFjdGl2YXRlVGFiKGluZGV4KSB7XG4gICAgY29uc3QgcHJldmlvdXNBY3RpdmVJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCgpO1xuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8oaW5kZXgpIHx8IGluZGV4ID09PSBwcmV2aW91c0FjdGl2ZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlVGFiQXRJbmRleChwcmV2aW91c0FjdGl2ZUluZGV4KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlVGFiQXRJbmRleChpbmRleCwgdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleChwcmV2aW91c0FjdGl2ZUluZGV4KSk7XG4gICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVRhYkFjdGl2YXRlZChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUga2V5ZG93biBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVLZXlEb3duKGV2dCkge1xuICAgIC8vIEdldCB0aGUga2V5IGZyb20gdGhlIGV2ZW50XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXlGcm9tRXZlbnRfKGV2dCk7XG5cbiAgICAvLyBFYXJseSBleGl0IGlmIHRoZSBldmVudCBrZXkgaXNuJ3Qgb25lIG9mIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uIGtleXNcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IgZm9yIG1vdmVtZW50IGtleXMsIGJ1dCBub3QgZm9yIGFjdGl2YXRpb24ga2V5cywgc2luY2UgOmFjdGl2ZSBpcyB1c2VkIHRvIGFwcGx5IHJpcHBsZVxuICAgIGlmICghdGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fKSB7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8odGhpcy5hZGFwdGVyXy5nZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4KCksIGtleSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGl2ZVRhYihpbmRleCk7XG4gICAgICB0aGlzLnNjcm9sbEludG9WaWV3KGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm9jdXNlZFRhYkluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2VkVGFiSW5kZXgoKTtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZhdGlvbktleV8oa2V5KSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGl2ZVRhYihmb2N1c2VkVGFiSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRldGVybWluZVRhcmdldEZyb21LZXlfKGZvY3VzZWRUYWJJbmRleCwga2V5KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c1RhYkF0SW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3KGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgTURDVGFiOmludGVyYWN0ZWQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVGFiSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIodGhpcy5hZGFwdGVyXy5nZXRJbmRleE9mVGFiKGV2dC5kZXRhaWwudGFiKSk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0YWIgaW5kZXggdG8gbWFrZSB2aXNpYmxlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlldyhpbmRleCkge1xuICAgIC8vIEVhcmx5IGV4aXQgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZVxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8oaW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHNjcm9sbCB0byAwIGlmIHNjcm9sbGluZyB0byB0aGUgMHRoIGluZGV4XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5zY3JvbGxUbygwKTtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgc2Nyb2xsIHRvIHRoZSBtYXggdmFsdWUgaWYgc2Nyb2xsaW5nIHRvIHRoZSBOdGggaW5kZXhcbiAgICAvLyBNRENUYWJTY3JvbGxlci5zY3JvbGxUbygpIHdpbGwgbmV2ZXIgc2Nyb2xsIHBhc3QgdGhlIG1heCBwb3NzaWJsZSB2YWx1ZVxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5zY3JvbGxUbyh0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSW50b1ZpZXdSVExfKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbEludG9WaWV3XyhpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGRldGVybWluaW5nIHRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gdGFiIGJhc2VkIG9uIHdoYXQga2V5IHdhcyBwcmVzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW4gVGhlIG9yaWdpbmFsIGluZGV4IGZyb20gd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBrZXlcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8ob3JpZ2luLCBrZXkpIHtcbiAgICBjb25zdCBpc1JUTCA9IHRoaXMuaXNSVExfKCk7XG4gICAgY29uc3QgbWF4SW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkxpc3RMZW5ndGgoKSAtIDE7XG4gICAgY29uc3Qgc2hvdWxkR29Ub0VuZCA9IGtleSA9PT0gc3RyaW5ncy5FTkRfS0VZO1xuICAgIGNvbnN0IHNob3VsZERlY3JlbWVudCA9IGtleSA9PT0gc3RyaW5ncy5BUlJPV19MRUZUX0tFWSAmJiAhaXNSVEwgfHwga2V5ID09PSBzdHJpbmdzLkFSUk9XX1JJR0hUX0tFWSAmJiBpc1JUTDtcbiAgICBjb25zdCBzaG91bGRJbmNyZW1lbnQgPSBrZXkgPT09IHN0cmluZ3MuQVJST1dfUklHSFRfS0VZICYmICFpc1JUTCB8fCBrZXkgPT09IHN0cmluZ3MuQVJST1dfTEVGVF9LRVkgJiYgaXNSVEw7XG4gICAgbGV0IGluZGV4ID0gb3JpZ2luO1xuXG4gICAgaWYgKHNob3VsZEdvVG9FbmQpIHtcbiAgICAgIGluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSBlbHNlIGlmIChzaG91bGREZWNyZW1lbnQpIHtcbiAgICAgIGluZGV4IC09IDE7XG4gICAgfSBlbHNlIGlmIChzaG91bGRJbmNyZW1lbnQpIHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPiBtYXhJbmRleCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgaW5jcmVtZW50IHRoYXQgd2lsbCBtYWtlIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IHZpc2libGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBuZXh0IHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIFRhYiBCYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50XyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpIHtcbiAgICBjb25zdCBuZXh0VGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgobmV4dEluZGV4KTtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRMZWZ0ID0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudExlZnQgLSBzY3JvbGxQb3NpdGlvbiAtIGJhcldpZHRoO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudFJpZ2h0ID0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb247XG4gICAgY29uc3QgbGVmdEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudFJpZ2h0IC0gbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuICAgIGNvbnN0IHJpZ2h0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50TGVmdCArIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcblxuICAgIGlmIChuZXh0SW5kZXggPCBpbmRleCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGxlZnRJbmNyZW1lbnQsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChyaWdodEluY3JlbWVudCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIGluY3JlbWVudCB0aGF0IHdpbGwgbWFrZSB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB2aXNpYmxlIGluIFJUTFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5leHRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG5leHQgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhcldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgVGFiIEJhclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsQ29udGVudFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbENvbnRlbnRXaWR0aCkge1xuICAgIGNvbnN0IG5leHRUYWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChuZXh0SW5kZXgpO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudExlZnQgPSBzY3JvbGxDb250ZW50V2lkdGggLSBuZXh0VGFiRGltZW5zaW9ucy5jb250ZW50TGVmdCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlbGF0aXZlQ29udGVudFJpZ2h0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCBsZWZ0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50UmlnaHQgKyBudW1iZXJzLkVYVFJBX1NDUk9MTF9BTU9VTlQ7XG4gICAgY29uc3QgcmlnaHRJbmNyZW1lbnQgPSByZWxhdGl2ZUNvbnRlbnRMZWZ0IC0gbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuXG4gICAgaWYgKG5leHRJbmRleCA+IGluZGV4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobGVmdEluY3JlbWVudCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWluKHJpZ2h0SW5jcmVtZW50LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbmRleCBvZiB0aGUgYWRqYWNlbnQgdGFiIGNsb3Nlc3QgdG8gZWl0aGVyIGVkZ2Ugb2YgdGhlIFRhYiBCYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7IU1EQ1RhYkRpbWVuc2lvbnN9IHRhYkRpbWVuc2lvbnMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHRhYiBiYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlXyhpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKSB7XG4gICAgLyoqXG4gICAgICogVGFicyBhcmUgbGFpZCBvdXQgaW4gdGhlIFRhYiBTY3JvbGxlciBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAgICBTY3JvbGwgUG9zaXRpb25cbiAgICAgKiAgICArLS0tK1xuICAgICAqICAgIHwgICB8ICAgQmFyIFdpZHRoXG4gICAgICogICAgfCAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICB8ICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgIHwgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogICAgfCAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICBWICAgfCAgICAgICAgICAgICBUYWIgU2Nyb2xsZXIgICAgICAgICAgfFxuICAgICAqICAgICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICB8ICAgIFRhYiAgICAgfCAgICAgIFRhYiAgICAgfCAgICAgICAgVGFiICAgICAgICB8XG4gICAgICogICAgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKlxuICAgICAqIFRvIGRldGVybWluZSB0aGUgbmV4dCBhZGphY2VudCBpbmRleCwgd2UgbG9vayBhdCB0aGUgVGFiIHJvb3QgbGVmdCBhbmRcbiAgICAgKiBUYWIgcm9vdCByaWdodCwgYm90aCByZWxhdGl2ZSB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBJZiB0aGUgVGFiIHJvb3RcbiAgICAgKiBsZWZ0IGlzIGxlc3MgdGhhbiAwLCB0aGVuIHdlIGtub3cgaXQncyBvdXQgb2YgdmlldyB0byB0aGUgbGVmdC4gSWYgdGhlXG4gICAgICogVGFiIHJvb3QgcmlnaHQgbWludXMgdGhlIGJhciB3aWR0aCBpcyBncmVhdGVyIHRoYW4gMCwgd2Uga25vdyB0aGUgVGFiIGlzXG4gICAgICogb3V0IG9mIHZpZXcgdG8gdGhlIHJpZ2h0LiBGcm9tIHRoZXJlLCB3ZSBlaXRoZXIgaW5jcmVtZW50IG9yIGRlY3JlbWVudFxuICAgICAqIHRoZSBpbmRleC5cbiAgICAgKi9cbiAgICBjb25zdCByZWxhdGl2ZVJvb3RMZWZ0ID0gdGFiRGltZW5zaW9ucy5yb290TGVmdCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlbGF0aXZlUm9vdFJpZ2h0ID0gdGFiRGltZW5zaW9ucy5yb290UmlnaHQgLSBzY3JvbGxQb3NpdGlvbiAtIGJhcldpZHRoO1xuICAgIGNvbnN0IHJlbGF0aXZlUm9vdERlbHRhID0gcmVsYXRpdmVSb290TGVmdCArIHJlbGF0aXZlUm9vdFJpZ2h0O1xuICAgIGNvbnN0IGxlZnRFZGdlSXNDbG9zZXIgPSByZWxhdGl2ZVJvb3RMZWZ0IDwgMCB8fCByZWxhdGl2ZVJvb3REZWx0YSA8IDA7XG4gICAgY29uc3QgcmlnaHRFZGdlSXNDbG9zZXIgPSByZWxhdGl2ZVJvb3RSaWdodCA+IDAgfHwgcmVsYXRpdmVSb290RGVsdGEgPiAwO1xuXG4gICAgaWYgKGxlZnRFZGdlSXNDbG9zZXIpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIDE7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbmRleCBvZiB0aGUgYWRqYWNlbnQgdGFiIGNsb3Nlc3QgdG8gZWl0aGVyIGVkZ2Ugb2YgdGhlIFRhYiBCYXIgaW4gUlRMXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJEaW1lbnNpb25zfSB0YWJEaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSB0YWIgYmFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxDb250ZW50V2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxlciBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZVJUTF8oaW5kZXgsIHRhYkRpbWVuc2lvbnMsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCwgc2Nyb2xsQ29udGVudFdpZHRoKSB7XG4gICAgY29uc3Qgcm9vdExlZnQgPSBzY3JvbGxDb250ZW50V2lkdGggLSB0YWJEaW1lbnNpb25zLnJvb3RMZWZ0IC0gYmFyV2lkdGggLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByb290UmlnaHQgPSBzY3JvbGxDb250ZW50V2lkdGggLSB0YWJEaW1lbnNpb25zLnJvb3RSaWdodCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHJvb3REZWx0YSA9IHJvb3RMZWZ0ICsgcm9vdFJpZ2h0O1xuICAgIGNvbnN0IGxlZnRFZGdlSXNDbG9zZXIgPSByb290TGVmdCA+IDAgfHwgcm9vdERlbHRhID4gMDtcbiAgICBjb25zdCByaWdodEVkZ2VJc0Nsb3NlciA9IHJvb3RSaWdodCA8IDAgfHwgcm9vdERlbHRhIDwgMDtcblxuICAgIGlmIChsZWZ0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cblxuICAgIGlmIChyaWdodEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCBhIGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dCBUaGUga2V5ZG93biBldmVudFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRLZXlGcm9tRXZlbnRfKGV2dCkge1xuICAgIGlmIChBQ0NFUFRBQkxFX0tFWVMuaGFzKGV2dC5rZXkpKSB7XG4gICAgICByZXR1cm4gZXZ0LmtleTtcbiAgICB9XG5cbiAgICByZXR1cm4gS0VZQ09ERV9NQVAuZ2V0KGV2dC5rZXlDb2RlKTtcbiAgfVxuXG4gIGlzQWN0aXZhdGlvbktleV8oa2V5KSB7XG4gICAgcmV0dXJuIGtleSA9PT0gc3RyaW5ncy5TUEFDRV9LRVkgfHwga2V5ID09PSBzdHJpbmdzLkVOVEVSX0tFWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBpcyBpbmNsdXNpdmVseSBiZXR3ZWVuIHRoZSBlbmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gdGVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5kZXhJc0luUmFuZ2VfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldFRhYkxpc3RMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2aWV3J3MgUlRMIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1JUTF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNSVEwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlldyBmb3IgbGVmdC10by1yaWdodCB1c2VyYWdlbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBzY3JvbGwgaW50byB2aWV3XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlld18oaW5kZXgpIHtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCB0YWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChpbmRleCk7XG4gICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5maW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VfKGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpO1xuXG4gICAgaWYgKCF0aGlzLmluZGV4SXNJblJhbmdlXyhuZXh0SW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsSW5jcmVtZW50ID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxJbmNyZW1lbnRfKGluZGV4LCBuZXh0SW5kZXgsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsSW5jcmVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlldyBpbiBSVExcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0YWIgaW5kZXggdG8gbWFrZSB2aXNpYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzY3JvbGxJbnRvVmlld1JUTF8oaW5kZXgpIHtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCB0YWJEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJEaW1lbnNpb25zQXRJbmRleChpbmRleCk7XG4gICAgY29uc3Qgc2Nyb2xsV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlUlRMXyhcbiAgICAgIGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbFdpZHRoKTtcblxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8obmV4dEluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbEluY3JlbWVudCA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbFdpZHRoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmluY3JlbWVudFNjcm9sbChzY3JvbGxJbmNyZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYkJhckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQge01EQ1RhYiwgTURDVGFiRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL3RhYi9pbmRleCc7XG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyfSBmcm9tICdAbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL2luZGV4JztcblxuaW1wb3J0IE1EQ1RhYkJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJCYXJGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDVGFiQmFyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiQmFyIGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8IU1EQ1RhYj59ICovXG4gICAgdGhpcy50YWJMaXN0XztcblxuICAgIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYil9ICovXG4gICAgdGhpcy50YWJGYWN0b3J5XztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P01EQ1RhYlNjcm9sbGVyfSAqL1xuICAgIHRoaXMudGFiU2Nyb2xsZXJfO1xuXG4gICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oIUVsZW1lbnQpOiAhTURDVGFiU2Nyb2xsZXIpfSAqL1xuICAgIHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5XztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P2Z1bmN0aW9uKD9FdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhhbmRsZVRhYkludGVyYWN0aW9uXztcblxuICAgIC8qKiBAcHJpdmF0ZSB7P2Z1bmN0aW9uKD9FdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhhbmRsZUtleURvd25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ1RhYkJhcn1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENUYWJCYXIocm9vdCk7XG4gIH1cblxuICBzZXQgdXNlQXV0b21hdGljQWN0aXZhdGlvbih1c2VBdXRvbWF0aWNBY3RpdmF0aW9uKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRVc2VBdXRvbWF0aWNBY3RpdmF0aW9uKHVzZUF1dG9tYXRpY0FjdGl2YXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCFFbGVtZW50KTogIU1EQ1RhYik9fSB0YWJGYWN0b3J5IEEgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBNRENUYWJcbiAgICogQHBhcmFtIHsoZnVuY3Rpb24oIUVsZW1lbnQpOiAhTURDVGFiU2Nyb2xsZXIpPX0gdGFiU2Nyb2xsZXJGYWN0b3J5IEEgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBNRENUYWJTY3JvbGxlclxuICAgKi9cbiAgaW5pdGlhbGl6ZShcbiAgICB0YWJGYWN0b3J5ID0gKGVsKSA9PiBuZXcgTURDVGFiKGVsKSxcbiAgICB0YWJTY3JvbGxlckZhY3RvcnkgPSAoZWwpID0+IG5ldyBNRENUYWJTY3JvbGxlcihlbCksXG4gICkge1xuICAgIHRoaXMudGFiRmFjdG9yeV8gPSB0YWJGYWN0b3J5O1xuICAgIHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5XyA9IHRhYlNjcm9sbGVyRmFjdG9yeTtcblxuICAgIHRoaXMudGFiTGlzdF8gPSB0aGlzLmdldFRhYkVsZW1lbnRzXygpLm1hcCgoZWwpID0+IHRoaXMudGFiRmFjdG9yeV8oZWwpKTtcblxuICAgIGNvbnN0IHRhYlNjcm9sbGVyRWxlbWVudCA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX1NDUk9MTEVSX1NFTEVDVE9SKTtcbiAgICBpZiAodGFiU2Nyb2xsZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLnRhYlNjcm9sbGVyXyA9IHRoaXMudGFiU2Nyb2xsZXJGYWN0b3J5Xyh0YWJTY3JvbGxlckVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLmhhbmRsZVRhYkludGVyYWN0aW9uXyA9IChldnQpID0+IHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlVGFiSW50ZXJhY3Rpb24oZXZ0KTtcbiAgICB0aGlzLmhhbmRsZUtleURvd25fID0gKGV2dCkgPT4gdGhpcy5mb3VuZGF0aW9uXy5oYW5kbGVLZXlEb3duKGV2dCk7XG5cbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNURURfRVZFTlQsIHRoaXMuaGFuZGxlVGFiSW50ZXJhY3Rpb25fKTtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25fKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWJMaXN0Xy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMudGFiTGlzdF9baV0uYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RFRF9FVkVOVCwgdGhpcy5oYW5kbGVUYWJJbnRlcmFjdGlvbl8pO1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bl8pO1xuICAgIHRoaXMudGFiTGlzdF8uZm9yRWFjaCgodGFiKSA9PiB0YWIuZGVzdHJveSgpKTtcbiAgICB0aGlzLnRhYlNjcm9sbGVyXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1RhYkJhckZvdW5kYXRpb259XG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1RhYkJhckZvdW5kYXRpb24oXG4gICAgICAvKiogQHR5cGUgeyFNRENUYWJCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgICBzY3JvbGxUbzogKHNjcm9sbFgpID0+IHRoaXMudGFiU2Nyb2xsZXJfLnNjcm9sbFRvKHNjcm9sbFgpLFxuICAgICAgICBpbmNyZW1lbnRTY3JvbGw6IChzY3JvbGxYSW5jcmVtZW50KSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCksXG4gICAgICAgIGdldFNjcm9sbFBvc2l0aW9uOiAoKSA9PiB0aGlzLnRhYlNjcm9sbGVyXy5nZXRTY3JvbGxQb3NpdGlvbigpLFxuICAgICAgICBnZXRTY3JvbGxDb250ZW50V2lkdGg6ICgpID0+IHRoaXMudGFiU2Nyb2xsZXJfLmdldFNjcm9sbENvbnRlbnRXaWR0aCgpLFxuICAgICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy5yb290Xy5vZmZzZXRXaWR0aCxcbiAgICAgICAgaXNSVEw6ICgpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdF8pLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgICAgc2V0QWN0aXZlVGFiOiAoaW5kZXgpID0+IHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGVUYWIoaW5kZXgpLFxuICAgICAgICBhY3RpdmF0ZVRhYkF0SW5kZXg6IChpbmRleCwgY2xpZW50UmVjdCkgPT4gdGhpcy50YWJMaXN0X1tpbmRleF0uYWN0aXZhdGUoY2xpZW50UmVjdCksXG4gICAgICAgIGRlYWN0aXZhdGVUYWJBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmRlYWN0aXZhdGUoKSxcbiAgICAgICAgZm9jdXNUYWJBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmZvY3VzKCksXG4gICAgICAgIGdldFRhYkluZGljYXRvckNsaWVudFJlY3RBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0KCksXG4gICAgICAgIGdldFRhYkRpbWVuc2lvbnNBdEluZGV4OiAoaW5kZXgpID0+IHRoaXMudGFiTGlzdF9baW5kZXhdLmNvbXB1dGVEaW1lbnNpb25zKCksXG4gICAgICAgIGdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXg6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFiTGlzdF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYkxpc3RfW2ldLmFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGb2N1c2VkVGFiSW5kZXg6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0YWJFbGVtZW50cyA9IHRoaXMuZ2V0VGFiRWxlbWVudHNfKCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHRhYkVsZW1lbnRzLmluZGV4T2YoYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEluZGV4T2ZUYWI6ICh0YWJUb0ZpbmQpID0+IHRoaXMudGFiTGlzdF8uaW5kZXhPZih0YWJUb0ZpbmQpLFxuICAgICAgICBnZXRUYWJMaXN0TGVuZ3RoOiAoKSA9PiB0aGlzLnRhYkxpc3RfLmxlbmd0aCxcbiAgICAgICAgbm90aWZ5VGFiQWN0aXZhdGVkOiAoaW5kZXgpID0+IHRoaXMuZW1pdChNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX0FDVElWQVRFRF9FVkVOVCwge2luZGV4fSwgdHJ1ZSksXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKi9cbiAgYWN0aXZhdGVUYWIoaW5kZXgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlVGFiKGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4IGludG8gdmlld1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVEhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICovXG4gIHNjcm9sbEludG9WaWV3KGluZGV4KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gIH1cblxuICBnZXRUYWJFbGVtZW50c18oKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKE1EQ1RhYkJhckZvdW5kYXRpb24uc3RyaW5ncy5UQUJfU0VMRUNUT1IpKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1RhYkJhciwgTURDVGFiQmFyRm91bmRhdGlvbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlRhYkJhciA9IGV4cG9ydHMuVGFiID0gZXhwb3J0cy5UYWJJY29uID0gZXhwb3J0cy5UYWJMYWJlbCA9IHZvaWQgMDtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF90YWJCYXIgPSByZXF1aXJlKFwiQG1hdGVyaWFsL3RhYi1iYXJcIik7XG5cbnZhciBfcHJlYWN0ID0gcmVxdWlyZShcInByZWFjdFwiKTtcblxudmFyIF9NYXRlcmlhbENvbXBvbmVudDUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9CYXNlL01hdGVyaWFsQ29tcG9uZW50XCIpKTtcblxudmFyIFRhYkxhYmVsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWF0ZXJpYWxDb21wb25lbnQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiTGFiZWwsIF9NYXRlcmlhbENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGFiTGFiZWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiTGFiZWwpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJMYWJlbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMuY29tcG9uZW50TmFtZSA9ICd0YWJfX3RleHQtbGFiZWwnO1xuICAgIF90aGlzLm1kY1Byb3BzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGFiTGFiZWwsIFt7XG4gICAga2V5OiBcIm1hdGVyaWFsRG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGVyaWFsRG9tKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9wcmVhY3QuaCkoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiTGFiZWw7XG59KF9NYXRlcmlhbENvbXBvbmVudDUuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVGFiTGFiZWwgPSBUYWJMYWJlbDtcblxudmFyIFRhYkljb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXRlcmlhbENvbXBvbmVudDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGFiSWNvbiwgX01hdGVyaWFsQ29tcG9uZW50Mik7XG5cbiAgZnVuY3Rpb24gVGFiSWNvbigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiSWNvbik7XG4gICAgX3RoaXMyID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShUYWJJY29uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBfdGhpczIuY29tcG9uZW50TmFtZSA9ICd0YWJfX2ljb24nO1xuICAgIF90aGlzMi5tZGNQcm9wcyA9IFtdO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWJJY29uLCBbe1xuICAgIGtleTogXCJtYXRlcmlhbERvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRlcmlhbERvbShwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1hdGVyaWFsLWljb25zXCJcbiAgICAgIH0sIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiSWNvbjtcbn0oX01hdGVyaWFsQ29tcG9uZW50NS5kZWZhdWx0KTtcblxuZXhwb3J0cy5UYWJJY29uID0gVGFiSWNvbjtcblxudmFyIFRhYiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hdGVyaWFsQ29tcG9uZW50Mykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUYWIsIF9NYXRlcmlhbENvbXBvbmVudDMpO1xuXG4gIGZ1bmN0aW9uIFRhYigpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiKTtcbiAgICBfdGhpczMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMzLmNvbXBvbmVudE5hbWUgPSAndGFiJztcbiAgICBfdGhpczMubWRjUHJvcHMgPSBbJ2FjdGl2ZSddO1xuICAgIF90aGlzMy5tZGNOb3RpZnlQcm9wcyA9IFsnYWN0aXZlJ107XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRhYiwgW3tcbiAgICBrZXk6IFwibWF0ZXJpYWxEb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0ZXJpYWxEb20ocHJvcHMpIHtcbiAgICAgIHJldHVybiAoMCwgX3ByZWFjdC5oKShcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYlwiLFxuICAgICAgICByb2xlOiBcInRhYlwiLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCJcbiAgICAgIH0sIHByb3BzKSwgKDAsIF9wcmVhY3QuaCkoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYl9fY29udGVudFwiXG4gICAgICB9LCBwcm9wcy5jaGlsZHJlbiksICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItaW5kaWNhdG9yIFwiLmNvbmNhdChwcm9wcy5hY3RpdmUgPyAnbWRjLXRhYi1pbmRpY2F0b3ItLWFjdGl2ZScgOiAnJylcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItaW5kaWNhdG9yX19jb250ZW50IG1kYy10YWItaW5kaWNhdG9yX19jb250ZW50LS11bmRlcmxpbmVcIlxuICAgICAgfSkpLCAoMCwgX3ByZWFjdC5oKShcInNwYW5cIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiX19yaXBwbGVcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiO1xufShfTWF0ZXJpYWxDb21wb25lbnQ1LmRlZmF1bHQpO1xuXG5leHBvcnRzLlRhYiA9IFRhYjtcblxudmFyIFRhYkJhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hdGVyaWFsQ29tcG9uZW50NCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUYWJCYXIsIF9NYXRlcmlhbENvbXBvbmVudDQpO1xuXG4gIGZ1bmN0aW9uIFRhYkJhcigpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFiQmFyKTtcbiAgICBfdGhpczQgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYkJhcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXM0LmNvbXBvbmVudE5hbWUgPSAndGFiLWJhcic7XG4gICAgX3RoaXM0Lm1kY1Byb3BzID0gW107XG4gICAgX3RoaXM0Lm1kY05vdGlmeVByb3BzID0gWydhY3RpdmVUYWJJbmRleCddO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWJCYXIsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFRhYkJhci5wcm90b3R5cGUpLCBcImNvbXBvbmVudERpZE1vdW50XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5NRENvbXBvbmVudCA9IG5ldyBfdGFiQmFyLk1EQ1RhYkJhcih0aGlzLmNvbnRyb2wpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFmdGVyQ29tcG9uZW50RGlkTW91bnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVGFiQmFyLnByb3RvdHlwZSksIFwiY29tcG9uZW50V2lsbFVubW91bnRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXMuTURDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5NRENvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGVyaWFsRG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGVyaWFsRG9tKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9wcmVhY3QuaCkoXCJkaXZcIiwge1xuICAgICAgICBjbGFzczogXCJtZGMtdGFiLWJhclwiLFxuICAgICAgICByb2xlOiBcInRhYmxpc3RcIixcbiAgICAgICAgcmVmOiB0aGlzLnNldENvbnRyb2xSZWZcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYi1zY3JvbGxlclwiXG4gICAgICB9LCAoMCwgX3ByZWFjdC5oKShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzOiBcIm1kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1hcmVhXCJcbiAgICAgIH0sICgwLCBfcHJlYWN0LmgpKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwibWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnRcIlxuICAgICAgfSwgcHJvcHMuY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFiQmFyO1xufShfTWF0ZXJpYWxDb21wb25lbnQ1LmRlZmF1bHQpO1xuXG5leHBvcnRzLlRhYkJhciA9IFRhYkJhcjtcblxudmFyIGRlZmF1bHRfMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1RhYkJhcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShkZWZhdWx0XzEsIF9UYWJCYXIpO1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBkZWZhdWx0XzEpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKGRlZmF1bHRfMSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdF8xO1xufShUYWJCYXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5kZWZhdWx0XzEuVGFiID0gVGFiO1xuZGVmYXVsdF8xLlRhYkxhYmVsID0gVGFiTGFiZWw7XG5kZWZhdWx0XzEuVGFiSWNvbiA9IFRhYkljb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcclxuXHJcbmltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5cclxuY29uc3QgRGF0ZUxpbmVicmVhayA9KHtkYXRldGltZX0pPT57XHJcbiAgICByZXR1cm4gKFxyXG48ZGl2IHN0eWxlPXt7ZGlzcGxheTpcImZsZXhcIn19PlxyXG48ZGl2IHN0eWxlPXt7ZmxleDpcIjFcIn19PjxociAvPjwvZGl2PlxyXG48ZGl2PntuZXcgRGF0ZShkYXRldGltZSkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9PC9kaXY+XHJcbjxkaXYgc3R5bGU9e3tmbGV4OjF9fT48aHIgLz48L2Rpdj5cclxuPC9kaXY+XHJcbilcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0ZUxpbmVicmVhayIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuXHJcbmNvbnN0IE1lc3NhZ2VBbGlnbmVyID0gKHsgY2hpbGRyZW4sIHNpZGUsIHN0eWxlIH0pID0+IHtcclxuICAgIGNvbnN0IGFsaWdubWVudCA9IHNpZGUgPT09IFwibGVmdFwiID8gXCJmbGV4LXN0YXJ0XCIgOiBcImZsZXgtZW5kXCJcclxuICAgIHJldHVybiA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBqdXN0aWZ5Q29udGVudDogYWxpZ25tZW50LCAuLi5zdHlsZSB9fT57Y2hpbGRyZW59PC9kaXY+XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlQWxpZ25lciIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xyXG5cclxuXHJcbmNvbnN0IE1lc3NhZ2VWaWV3ID0gKHsgbWVzc2FnZSwgYmFja2dyb3VuZENvbG9yLCBkYXRldGltZSB9KSA9PiAoXHJcbjxkaXYgc3R5bGU9e3tcclxuICBiYWNrZ3JvdW5kQ29sb3IsXHJcbiAgcGFkZGluZzogNSxcclxuICBtYXJnaW46IDIsXHJcbiAgYm9yZGVyUmFkaXVzOiAxNSxcclxuICBib3JkZXJDb2xvcjogJyM5RTlFOUUnLFxyXG4gIGJvcmRlclN0eWxlOiAnc29saWQnLFxyXG4gIGJvcmRlcldpZHRoOiAyLFxyXG4gIG1heFdpZHRoOiAnMTAwJScsXHJcbiAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcclxuICB3b3JkQnJlYWs6ICdicmVhay1hbGwnLFxyXG4gIG1pbldpZHRoOiAnMzAlJyxcclxufX1cclxuPlxyXG4gICAgPGRpdj57bWVzc2FnZX08L2Rpdj5cclxuICAgIDxkaXYgc3R5bGU9e3tcclxuICAgICAgZm9udFNpemU6IDEwLFxyXG4gICAgICBwYWRkaW5nVG9wOiAyLFxyXG4gICAgICB0ZXh0QWxpZ246ICdlbmQnLFxyXG4gICAgfX1cclxuICAgID5cclxuPGkgc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiAnI2VmZWJlOScgfX0+e25ldyBEYXRlKGRhdGV0aW1lKS50b0xvY2FsZVRpbWVTdHJpbmcoKX08L2k+XHJcblxyXG4gICAgPC9kaXY+XHJcbjwvZGl2PlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZVZpZXc7XHJcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQgTWVzc2FnZSBmcm9tICcuL21lc3NhZ2UtdmlldydcclxuXHJcbmNvbnN0IFN1YnNlcXVlbnRNZXNzYWdlID0gKHsgbWVzc2FnZSwgZGF0ZXRpbWUgfSkgPT4ge1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIG1hcmdpbkxlZnQ6NDUgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZXNzYWdlIG1lc3NhZ2U9e21lc3NhZ2V9IGRhdGV0aW1lPXtkYXRldGltZX0gYmFja2dyb3VuZENvbG9yPVwiI0ZGRUNCM1wiIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdWJzZXF1ZW50TWVzc2FnZSIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xyXG5cclxuY29uc3Qgc3R5bGUgPSB7XHJcbiAgaGVpZ2h0OiAzMCxcclxuICB3aWR0aDogNDAsXHJcbiAgcGFkZGluZzogMyxcclxuICBib3JkZXJSYWRpdXM6IDMwLFxyXG4gIGJhY2tncm91bmRDb2xvcjogJ2RhcmtTbW9rZScsXHJcbiAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXHJcbiAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgZGlzcGxheTogJ2ZsZXgnLFxyXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcclxuICBjb2xvcjogJyMwMDk2ODgnLFxyXG4gIGJvcmRlckNvbG9yOiAnIzgwY2JjNCcsXHJcbn07XHJcblxyXG5cclxuY29uc3QgTWVzc2FnZUF2YXRhciA9ICh7IGxldHRlciA9ICdVJyB9KSA9PiAoPGRpdiBzdHlsZT17c3R5bGV9PjxkaXY+e2xldHRlci50b1VwcGVyQ2FzZSgpfTwvZGl2PjwvZGl2Pik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlQXZhdGFyO1xyXG4iLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9tZXNzYWdlLXZpZXcnXHJcbmltcG9ydCBNZXNzYWdlQXZhdGFyIGZyb20gJy4vbWVzc2FnZS1hdmF0YXInXHJcblxyXG5jb25zdCBGaXJzdE1lc3NhZ2UgPSAoeyBtZXNzYWdlLCBkYXRldGltZSxsZXR0ZXIsbG9jYWwgfSkgPT4ge1xyXG5cclxuICAgIHJldHVybiAoXHJcblxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIgfX0+XHJcbiAgICAgICAgICAgIHshbG9jYWwgJiY8TWVzc2FnZUF2YXRhciBsZXR0ZXI9e2xldHRlcn0gLz59XHJcbiAgICAgICAgICAgIDxNZXNzYWdlIG1lc3NhZ2U9e21lc3NhZ2V9IGRhdGV0aW1lPXtkYXRldGltZX0gYmFja2dyb3VuZENvbG9yPVwiI0ZGRUNCM1wiIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGaXJzdE1lc3NhZ2UiLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nICovXHJcbmltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xyXG5pbXBvcnQgTWVzc2FnZUFsaWduZXIgZnJvbSAnLi9tZXNzYWdlLWFsaWduZXInO1xyXG5pbXBvcnQgRmlyc3RNZXNzYWdlIGZyb20gJy4vZmlyc3QtbWVzc2FnZSc7XHJcbmltcG9ydCBTdWJzZXF1ZW50TWVzc2FnZSBmcm9tICcuL3N1YnNlcXVlbnQtbWVzc2FnZSc7XHJcbmltcG9ydCBEYXRlTGluZWJyZWFrIGZyb20gJy4vZGF0ZS1saW5lYnJlYWsnO1xyXG5cclxuY29uc3QgTWVzc2FnZU9iamVjdE1hcHB0ZXIgPSAocHJvcHMpID0+IHtcclxuICAgIGNvbnN0IHsgb3JkZXIsIGRhdGVTcGFjZSB9ID0gcHJvcHM7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIHtkYXRlU3BhY2UgJiYgPERhdGVMaW5lYnJlYWsgey4uLnByb3BzfSAvPn1cclxuICAgICAgICAgICAgPE1lc3NhZ2VBbGlnbmVyIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID09PSAnRicgPyA8Rmlyc3RNZXNzYWdlIHsuLi5wcm9wc30gLz4gOiA8U3Vic2VxdWVudE1lc3NhZ2Ugey4uLnByb3BzfSAvPlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgPC9NZXNzYWdlQWxpZ25lcj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlT2JqZWN0TWFwcHRlcjtcclxuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCB7dXNlRWZmZWN0LHVzZVN0YXRlfSBmcm9tICdwcmVhY3QvaG9va3MnXHJcblxyXG5jb25zdCB1c2VNZXNzYWdlU29ydGVyID0obWVzc2FnZXMpPT57XHJcbmNvbnN0IFtzb3J0ZWRNZXNzYWdlcyxzZXRTb3J0ZWRNZXNzYWdlc109dXNlU3RhdGUobWVzc2FnZXMpXHJcbnVzZUVmZmVjdCgoKT0+e1xyXG5cclxuICAgIHNldFNvcnRlZE1lc3NhZ2VzKG1lc3NhZ2VzLnNvcnQoKGEsIGIpPT4gYS5kYXRldGltZSAtIGIuZGF0ZXRpbWUpKVxyXG59LFttZXNzYWdlc10pXHJcblxyXG5yZXR1cm57c29ydGVkTWVzc2FnZXN9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHVzZU1lc3NhZ2VTb3J0ZXJcclxuXHJcbiIsImltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQge3VzZVN0YXRlLHVzZUVmZmVjdH0gZnJvbSAncHJlYWN0L2hvb2tzJ1xyXG5cclxuY29uc3QgdXNlTWVzc2FnZXNNYXBwZXIgPShtZXNzYWdlcyk9PntcclxuICBjb25zdCBbbWFwcGVkTWVzc2FnZXMsc2V0TWFwcGVkTWVzc2FnZXNdPXVzZVN0YXRlKG1lc3NhZ2VzKVxyXG4gIGNvbnN0IG1hcE1lc3NhZ2VzID0oKT0+e1xyXG4gICAgY29uc3QgbG9jYWxTaWRlID1cInJpZ2h0XCJcclxuICAgIGNvbnN0IHJlbW90ZVNpZGU9XCJsZWZ0XCJcclxuICAgIGlmKG1lc3NhZ2VzLmxlbmd0aD09PTApe1xyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICAgICAgbGV0IGVtYWlsID0gbWVzc2FnZXNbMF0uZnJvbVxyXG4gICAgICBsZXQgbGFzdERhdGV0aW1lID0gbWVzc2FnZXNbMF0uZGF0ZXRpbWVcclxuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoKG0sIGkpID0+IHtcclxuICBcclxuICAgICAgaWYgKGkgPT09IDAgJiYgbS5sb2NhbCkge1xyXG4gICAgICBcclxuICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IGxvY2FsU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IHRydWUgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpID09PSAwICYmICFtLmxvY2FsKSB7XHJcbiAgICAgXHJcbiAgICAgICAgY29uc3QgbGV0dGVyID0gbS5mcm9tWzBdICE9PXVuZGVmaW5lZCA/IG0uZnJvbVswXTpcIlwiXHJcbiAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiByZW1vdGVTaWRlLCBvcmRlcjogXCJGXCIsIGRhdGVTcGFjZTogdHJ1ZSxsZXR0ZXIgfVxyXG4gICAgICB9XHJcbiAgIFxyXG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgPT09IG0uZnJvbSAmJiBtLmxvY2FsKSB7XHJcbiAgICAgICAgICBpZiAobmV3IERhdGUobGFzdERhdGV0aW1lKS5nZXREYXRlKCkgIT09IG5ldyBEYXRlKG0uZGF0ZXRpbWUpLmdldERhdGUoKSkge1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZW1haWwgPSBtLmZyb21cclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogbG9jYWxTaWRlLCBvcmRlcjogXCJTXCIsIGRhdGVTcGFjZTogdHJ1ZSB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIlNcIiwgZGF0ZVNwYWNlOiBmYWxzZSB9XHJcbiAgICAgICAgICBcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgIT09IG0uZnJvbSAmJiBtLmxvY2FsKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICBpZiAobmV3IERhdGUobGFzdERhdGV0aW1lKS5nZXREYXRlKCkgPT09IG5ldyBEYXRlKG0uZGF0ZXRpbWUpLmdldERhdGUoKSkge1xyXG4gICAgICAgICBcclxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiBsb2NhbFNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiBmYWxzZSB9XHJcbiAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgIGVtYWlsID0gbS5mcm9tXHJcbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxyXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IGxvY2FsU2lkZSwgb3JkZXI6IFwiRlwiLCBkYXRlU3BhY2U6IHRydWUgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgPT09IG0uZnJvbSAmJiAhbS5sb2NhbCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgaWYgKG5ldyBEYXRlKGxhc3REYXRldGltZSkuZ2V0RGF0ZSgpICE9PSBuZXcgRGF0ZShtLmRhdGV0aW1lKS5nZXREYXRlKCkpIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IG0uZnJvbVswXSAhPT11bmRlZmluZWQgPyBtLmZyb21bMF06XCJcIlxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiByZW1vdGVTaWRlLCBvcmRlcjogXCJTXCIsIGRhdGVTcGFjZTogdHJ1ZSxsZXR0ZXIgfVxyXG4gICAgICAgICAgfSBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBsZXR0ZXIgPSBtLmZyb21bMF0gIT09dW5kZWZpbmVkID8gbS5mcm9tWzBdOlwiXCJcclxuICAgICAgICAgICAgICBsYXN0RGF0ZXRpbWUgPSBtLmRhdGV0aW1lXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgc2lkZTogcmVtb3RlU2lkZSwgb3JkZXI6IFwiU1wiLCBkYXRlU3BhY2U6IGZhbHNlLGxldHRlciB9XHJcbiAgICAgICAgICBcclxuICAgICAgfVxyXG4gICAgICBpZiAoaSA+IDAgJiYgZW1haWwgIT09IG0uZnJvbSAmJiAhbS5sb2NhbCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgaWYgKG5ldyBEYXRlKGxhc3REYXRldGltZSkuZ2V0RGF0ZSgpID09PSBuZXcgRGF0ZShtLmRhdGV0aW1lKS5nZXREYXRlKCkpIHtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgICBjb25zdCBsZXR0ZXIgPSBtLmZyb21bMF0gIT09dW5kZWZpbmVkID8gbS5mcm9tWzBdOlwiXCJcclxuICAgICAgICAgICAgICBlbWFpbCA9IG0uZnJvbVxyXG4gICAgICAgICAgICAgIGxhc3REYXRldGltZSA9IG0uZGF0ZXRpbWVcclxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5tLCBzaWRlOiByZW1vdGVTaWRlLCBvcmRlcjogXCJGXCIsIGRhdGVTcGFjZTogZmFsc2UsbGV0dGVyIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IG0uZnJvbVswXSAhPT11bmRlZmluZWQgPyBtLmZyb21bMF06XCJcIlxyXG4gICAgICAgICAgICAgIGVtYWlsID0gbS5mcm9tXHJcbiAgICAgICAgICAgICAgbGFzdERhdGV0aW1lID0gbS5kYXRldGltZVxyXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm0sIHNpZGU6IHJlbW90ZVNpZGUsIG9yZGVyOiBcIkZcIiwgZGF0ZVNwYWNlOiB0cnVlLGxldHRlciB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGxcclxuICB9KVxyXG4gIH1cclxuXHJcbiAgdXNlRWZmZWN0KCgpPT57XHJcbiAgICBzZXRNYXBwZWRNZXNzYWdlcyhtYXBNZXNzYWdlcygpKVxyXG4gIH0sW21lc3NhZ2VzXSlcclxucmV0dXJuIHttYXBwZWRNZXNzYWdlc31cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgdXNlTWVzc2FnZXNNYXBwZXJcclxuIiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLWFycmF5LWluZGV4LWtleSAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nICovXHJcbmltcG9ydCB7aH0gZnJvbSAncHJlYWN0J1xyXG5pbXBvcnQgTWVzc2FnZU9iamVjdE1hcHBlciBmcm9tICcuL21lc3NhZ2Utb2JqZWN0LW1hcHBlcidcclxuXHJcbmNvbnN0IE1lc3NhZ2VDb2xsZWN0aW9uVmlldyA9ICh7IG1lc3NhZ2VzIH0pID0+e1xyXG5cclxuICAgIGlmKG1lc3NhZ2VzLmxlbmd0aD4wKXtcclxuICAgICAgIFxyXG4gICAgICAgIHJldHVybiAgbWVzc2FnZXMubWFwKChtZXNzYWdlLCBpKSA9PiA8TWVzc2FnZU9iamVjdE1hcHBlciB7Li4ubWVzc2FnZX0ga2V5PXtpfSAvPilcclxuICAgIH1cclxuICAgICByZXR1cm4gbnVsbFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlQ29sbGVjdGlvblZpZXciLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1kZXByZWNhdGVkICovXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5jb25zdCBNZXNzYWdlVmlld1Njcm9sbGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdlxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoMTgwZGVnKVwiLFxyXG4gICAgICAgIGhlaWdodDogXCI4NSVcIixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2VkZWZmMlwiLFxyXG4gICAgICAgIG92ZXJmbG93OiBcInNjcm9sbFwiLFxyXG4gICAgICAgIHdpZHRoOlwiMTAwJVwiXHJcbiAgICAgIH19XHJcbiAgICA+XHJcbiAgICAgIDxkaXYgc3R5bGU9e3sgdHJhbnNmb3JtOiBcInJvdGF0ZSgxODBkZWcpXCIgfX0+XHJcbiAgICAgICAgeyBjaGlsZHJlbn1cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZVZpZXdTY3JvbGxlcjtcclxuXHJcblxyXG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XHJcblxyXG5jb25zdCBNZXNzYWdlRWRpdG9yRGlzcGxheWVyID0gKHtcclxuICBvbk1lc3NhZ2VDaGFuZ2UsIG1lc3NhZ2UsIHNlbmRNZXNzYWdlLCBpZCA9IDAsIGRpc2FibGVkLFxyXG59KSA9PiAoXHJcbiAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcgfX0+XHJcbiAgICA8aW5wdXQgc3R5bGU9e3sgZmxleDogMSB9fSBkYXRhLXRlc3RpZD17YG1lc3NhZ2Uke2lkfWB9IG9uSW5wdXQ9e29uTWVzc2FnZUNoYW5nZX0gdmFsdWU9e21lc3NhZ2V9IG5hbWU9XCJtZXNzYWdlXCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIkVudGVyIG1lc3NhZ2UgdGV4dFwiIC8+XHJcbiAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JyB9fT5cclxuICAgICAgICAgIDxidXR0b24gZGF0YS10ZXN0aWQ9e2BzZW5kTWVzc2FnZSR7aWR9YH0gZGlzYWJsZWQ9e21lc3NhZ2UgPT09ICcnIHx8IGRpc2FibGVkfSBzdHlsZT17eyBtYXJnaW5MZWZ0OiAyLCB3aWR0aDogJzEwMCUnIH19IG9uQ2xpY2s9e3NlbmRNZXNzYWdlfT5cclxuXHJcbiAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0yLjAxIDIxTDIzIDEyIDIuMDEgMyAyIDEwbDE1IDItMTUgMnpcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG4pO1xyXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlRWRpdG9yRGlzcGxheWVyO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1zaGFkb3cgKi9cclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHVzZU1lc3NhZ2VTb3J0ZXIgZnJvbSBcIi4vdXNlTWVzc2FnZVNvcnRlclwiO1xyXG5pbXBvcnQgdXNlTWVzc2FnZU1hcHBlciBmcm9tIFwiLi91c2VNZXNzYWdlTWFwcGVyXCI7XHJcbmltcG9ydCBNZXNzYWdlQ29sbGVjdGlvblZpZXcgZnJvbSBcIi4vbWVzc2FnZS1jb2xsZWN0aW9uLXZpZXdcIjtcclxuaW1wb3J0IE1lc3NhZ2VWaWV3U2Nyb2xsZXIgZnJvbSBcIi4vbWVzc2FnZXMtdmlldy1zY3JvbGxlclwiO1xyXG5pbXBvcnQgTWVzc2FnZUVkaXRvckRpc3BsYXllciBmcm9tIFwiLi4vLi4vbWVzc2FnZS1lZGl0b3ItZGlzcGxheWVyXCI7XHJcblxyXG5jb25zdCBNZXNzYWdlc0Rpc3BsYXllciA9ICh7XHJcbiAgbWVzc2FnZXMsXHJcbiAgc29ja2V0LFxyXG4gIGlkLFxyXG4gIG1lc3NhZ2VUZXh0LFxyXG4gIHNlbmRNZXNzYWdlLFxyXG4gIGhhbmRsZU1lc3NhZ2VDaGFuZ2VcclxufSkgPT4ge1xyXG4gIGNvbnN0IHsgc29ydGVkTWVzc2FnZXMgfSA9IHVzZU1lc3NhZ2VTb3J0ZXIobWVzc2FnZXMpO1xyXG4gIGNvbnN0IHsgbWFwcGVkTWVzc2FnZXMgfSA9IHVzZU1lc3NhZ2VNYXBwZXIoc29ydGVkTWVzc2FnZXMpO1xyXG4gIHJldHVybiBbXHJcblxyXG4gICAgICA8TWVzc2FnZVZpZXdTY3JvbGxlcj5cclxuICAgICAgICA8TWVzc2FnZUNvbGxlY3Rpb25WaWV3IG1lc3NhZ2VzPXttYXBwZWRNZXNzYWdlc30gLz5cclxuICAgICAgPC9NZXNzYWdlVmlld1Njcm9sbGVyPixcclxuICAgICAgPE1lc3NhZ2VFZGl0b3JEaXNwbGF5ZXJcclxuICAgICAgICBkaXNhYmxlZD17c29ja2V0ID09PSBudWxsfVxyXG4gICAgICAgIGlkPXtpZH1cclxuICAgICAgICBtZXNzYWdlPXttZXNzYWdlVGV4dH1cclxuICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1lc3NhZ2V9XHJcbiAgICAgICAgb25NZXNzYWdlQ2hhbmdlPXtoYW5kbGVNZXNzYWdlQ2hhbmdlfVxyXG4gICAgICAvPlxyXG5cclxuICBdO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZXNEaXNwbGF5ZXI7XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCBNZXNzYWdlRGlzcGxheWVyIGZyb20gXCIuLi8uLi8uLi8uLi9ydGNqcy9yZXVzYWJsZS11aS9tZXNzYWdlcy1kaXNwbGF5ZXJcIjtcclxuaW1wb3J0ICcuL3N0eWxlLmNzcydcclxuY29uc3QgQ2hhdFVzZXIgPSAoe1xyXG4gIG5hbWUsXHJcbiAgdGFyZ2V0TmFtZSxcclxuICBzb2NrZXQsXHJcbiAgZXJyb3JzLFxyXG4gIG1lc3NhZ2VzLFxyXG4gIGhhbmRsZU1lc3NhZ2VDaGFuZ2UsXHJcbiAgbWVzc2FnZVRleHQsXHJcbiAgc2VuZE1lc3NhZ2VcclxufSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RcIiBzdHlsZT17eyBoZWlnaHQ6IFwiOTclXCIsIHdpZHRoOlwiNTAlXCIgfX0+XHJcbiAgICAgIDxNZXNzYWdlRGlzcGxheWVyXHJcbiAgICAgICAgZXJyb3JzPXtlcnJvcnN9XHJcbiAgICAgICAgc29ja2V0PXtzb2NrZXR9XHJcbiAgICAgICAgbWVzc2FnZXM9e21lc3NhZ2VzfVxyXG4gICAgICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U9e2hhbmRsZU1lc3NhZ2VDaGFuZ2V9XHJcbiAgICAgICAgbWVzc2FnZVRleHQ9e21lc3NhZ2VUZXh0fVxyXG4gICAgICAgIHNlbmRNZXNzYWdlPXtzZW5kTWVzc2FnZX1cclxuICAgICAgLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGF0VXNlcjtcclxuIiwiZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImltcG9ydCB7aCwgQ29tcG9uZW50fSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCB7dXNlU3RhdGUsIHVzZUVmZmVjdH0gZnJvbSAncHJlYWN0L2hvb2tzJ1xyXG5cclxuY29uc3QgdXNlU29ja2V0TWVzc2FnaW5nID0oe3NvY2tldCx0YXJnZXROYW1lfSk9PntcclxuY29uc3QgW21lc3NhZ2VUZXh0LHNldE1lc3NhZ2VUZXh0XT11c2VTdGF0ZSgnJylcclxuY29uc3QgW21lc3NhZ2VSZWNpZXZlZCxzZXRNZXNzYWdlUmVjaWV2ZWRdPXVzZVN0YXRlKG51bGwpXHJcbmNvbnN0IFttZXNzYWdlU2VudCxzZXRNZXNzYWdlU2VudF09dXNlU3RhdGUobnVsbClcclxuY29uc3QgW2Nvbm5lY3RlZCxzZXRDb25uZWN0ZWRdPXVzZVN0YXRlKGZhbHNlKVxyXG5jb25zdCBbZXJyb3JzLHNldEVycm9yXT11c2VTdGF0ZShbXSlcclxuICBjb25zdCAgIHNlbmRNZXNzYWdlID0gKCkgPT4ge1xyXG4gIGNvbnN0IGRhdGV0aW1lID0gIG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgc29ja2V0LmVtaXQoXCJ0ZXh0X21lc3NhZ2VcIix7XHJcbiAgICByZWNpZXZlcjp0YXJnZXROYW1lLFxyXG4gICAgbWVzc2FnZTogbWVzc2FnZVRleHQsXHJcbiAgICBkYXRldGltZX0pO1xyXG4gIHNldE1lc3NhZ2VTZW50KHtyZWNpZXZlcjp0YXJnZXROYW1lLGRhdGV0aW1lLG1lc3NhZ2U6bWVzc2FnZVRleHR9KVxyXG4gIHNldE1lc3NhZ2VUZXh0KCcnKVxyXG59XHJcblxyXG5jb25zdCBoYW5kbGVNZXNzYWdlQ2hhbmdlID0oZSk9PntcclxuXHJcbnNldE1lc3NhZ2VUZXh0KGUudGFyZ2V0LnZhbHVlKVxyXG5cclxufVxyXG5cclxuICB1c2VFZmZlY3QoKCk9PntcclxuICAgIGlmKHNvY2tldCAhPT1udWxsKXtcclxuXHJcbiAgICAgXHJcbiAgICAgIHNvY2tldC5vbihcInRleHRfbWVzc2FnZVwiLCBkYXRhID0+IHtcclxuICAgICAgICBjb25zdCB7IHNlbmRlciAsIG1lc3NhZ2UsIGRhdGV0aW1lIH0gPSBkYXRhO1xyXG4gICAgICAgXHJcbiAgICAgIHNldE1lc3NhZ2VSZWNpZXZlZCh7c2VuZGVyLG1lc3NhZ2UsZGF0ZXRpbWV9KVxyXG4gICAgICB9KTtcclxuICAgICAgc29ja2V0Lm9uKFwiY29ubmVjdFwiLCgpPT57XHJcbiAgICAgICBcclxuICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSlcclxuICAgICAgfSlcclxuICBcclxuICAgICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCgpPT57XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0Q29ubmVjdGVkKGZhbHNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsKGVycm9yKT0+e1xyXG4gICAgICAgIHNldEVycm9yKFsuLi5lcnJvcnMsZXJyb3JdKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICB9KVxyXG5cclxuXHJcblxyXG5yZXR1cm4ge21lc3NhZ2VSZWNpZXZlZCxtZXNzYWdlU2VudCxtZXNzYWdlVGV4dCxzZW5kTWVzc2FnZSxoYW5kbGVNZXNzYWdlQ2hhbmdlLGVycm9ycyxjb25uZWN0ZWR9XHJcblxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHVzZVNvY2tldE1lc3NhZ2luZ1xyXG5cclxuIiwiaW1wb3J0IHtofSBmcm9tICdwcmVhY3QnXHJcbmltcG9ydCB7dXNlU3RhdGUsdXNlRWZmZWN0fSBmcm9tICdwcmVhY3QvaG9va3MnXHJcblxyXG5jb25zdCB1c2VDaGF0TG9nID0oe25hbWUsbWVzc2FnZVJlY2lldmVkLG1lc3NhZ2VTZW50fSk9PntcclxuICBjb25zdCBbbWVzc2FnZXMsc2V0TWVzc2FnZXNdPXVzZVN0YXRlKFtdKVxyXG4gIFxyXG4gIGNvbnN0IHNhdmVUb0xvY2FsU3RvcmFnZSA9IChtLCBrZXkpID0+IHtcclxuICAgIGNvbnN0IHBlcnNpc3RlZE1lc3NhZ2VzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKSA9PT0gbnVsbCA/IFttXSA6IFsuLi5KU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpLCBtXVxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShwZXJzaXN0ZWRNZXNzYWdlcykpO1xyXG4gICAgcmV0dXJuIHBlcnNpc3RlZE1lc3NhZ2VzXHJcbn1cclxuICAvLyBjb21wb25lbnREaWRNb3VudFxyXG4gIHVzZUVmZmVjdCgoKT0+e1xyXG4gICAgc2V0TWVzc2FnZXMoSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKSkgPT09IG51bGwgP1xyXG4gICAgIFtdIDogWy4uLkpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkpXSlcclxuICAgICBcclxuICB9LFtdKVxyXG4gIC8vIHNhdmVSZW1vdGVNZXNzYWdlXHJcbiB1c2VFZmZlY3QoKCk9PntcclxuICAgaWYobWVzc2FnZVJlY2lldmVkIT09bnVsbClcclxuICAge1xyXG4gICAgY29uc3QgeyBkYXRldGltZSwgbWVzc2FnZSwgc2VuZGVyIH0gPSBtZXNzYWdlUmVjaWV2ZWRcclxuICAgIGNvbnN0IGxvY2FsID0gZmFsc2VcclxuICBzZXRNZXNzYWdlcyhzYXZlVG9Mb2NhbFN0b3JhZ2UoIHsgbWVzc2FnZSwgZnJvbTogc2VuZGVyLCBsb2NhbCwgZGF0ZXRpbWUsIHRvOiBuYW1lIH0sbmFtZSkpXHJcbiAgIH1cclxuICBcclxuIH0sW21lc3NhZ2VSZWNpZXZlZF0pXHJcblxyXG4gIC8vIHNhdmVMb2NhbE1lc3NhZ2VcclxuICB1c2VFZmZlY3QoKCk9PntcclxuICAgIGlmKG1lc3NhZ2VTZW50IT09bnVsbCl7XHJcbiAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0ZXRpbWUsIG1lc3NhZ2UsIHJlY2lldmVyIH0gPSBtZXNzYWdlU2VudFxyXG4gICAgICBjb25zdCBsb2NhbCA9IHRydWVcclxuICAgICAgY29uc3QgZnJvbSA9bmFtZVxyXG4gICAgc2V0TWVzc2FnZXMoc2F2ZVRvTG9jYWxTdG9yYWdlKCB7IG1lc3NhZ2UsIGZyb20sIGxvY2FsLCBkYXRldGltZSwgdG86IHJlY2lldmVyIH0sbmFtZSkpXHJcblxyXG4gICAgfVxyXG59LFttZXNzYWdlU2VudF0pXHJcbiBcclxuICByZXR1cm4ge21lc3NhZ2VzfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB1c2VDaGF0TG9nXHJcblxyXG4iLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cblx0Ki9cblx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRcdC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcblxuXHRcdC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0Ly8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0Ly8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0cmV0dXJuIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuXHRcdGNvbnNvbGUubG9nICYmXG5cdFx0Y29uc29sZS5sb2coLi4uYXJncyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCAodXJpLCBsb2MpIHtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICBsb2MgPSBsb2MgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYXRpb24pO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbmV4cG9ydCBkZWZhdWx0IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuXG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSAnLi9iYXNlNjQnXG5pbXBvcnQgKiBhcyBpZWVlNzU0IGZyb20gJy4vaWVlZTc1NCdcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheSdcblxuZXhwb3J0IHZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHJ1ZVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG52YXIgX2tNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcbmV4cG9ydCB7X2tNYXhMZW5ndGggYXMga01heExlbmd0aH07XG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHJldHVybiB0cnVlO1xuICAvLyByb2xsdXAgaXNzdWVzXG4gIC8vIHRyeSB7XG4gIC8vICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gIC8vICAgYXJyLl9fcHJvdG9fXyA9IHtcbiAgLy8gICAgIF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsXG4gIC8vICAgICBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgLy8gICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgLy8gICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgLy8gfSBjYXRjaCAoZSkge1xuICAvLyAgIHJldHVybiBmYWxzZVxuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgLy8gICB2YWx1ZTogbnVsbCxcbiAgICAvLyAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIC8vIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZVxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxudmFyIHdpdGhOYXRpdmVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbic7XG52YXIgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopIDogKG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAod2l0aE5hdGl2ZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgICAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpO1xufVxuIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXScpO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbnZhciBFUlJPUl9QQUNLRVQgPSBleHBvcnRzLkVSUk9SICsgJ1wiZW5jb2RlIGVycm9yXCInO1xuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHZhciBzdHIgPSAnJyArIG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG4gICAgc3RyICs9IG9iai5uc3AgKyAnLCc7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5U3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHN0ciArPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZW5jb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHtcbiAgICByZXR1cm4gZXJyb3IoJ3Vua25vd24gcGFja2V0IHR5cGUgJyArIHAudHlwZSk7XG4gIH1cblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9PSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIHZhciBpc1BheWxvYWRWYWxpZCA9IHBheWxvYWQgIT09IGZhbHNlICYmIChwLnR5cGUgPT09IGV4cG9ydHMuRVJST1IgfHwgaXNBcnJheShwYXlsb2FkKSk7XG4gICAgaWYgKGlzUGF5bG9hZFZhbGlkKSB7XG4gICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3IoJ2ludmFsaWQgcGF5bG9hZCcpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yOiAnICsgbXNnXG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKlxuICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG4gKlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9jb3JzLmpzXG4gKi9cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgc2VsZltbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0dmFyIHZhbHVlO1xuXHR2YXIgZXh0cmE7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIHZhbHVlO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0fVxuXHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdH1cblx0dmFyIHN5bWJvbCA9ICcnO1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0fVxuXHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSAweEZGRkQ7XG5cdFx0fVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0fVxuXHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRyZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIGNvZGVQb2ludDtcblx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdH1cblx0cmV0dXJuIGJ5dGVTdHJpbmc7XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0fVxuXG5cdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuXHR2YXIgYnl0ZTE7XG5cdHZhciBieXRlMjtcblx0dmFyIGJ5dGUzO1xuXHR2YXIgYnl0ZTQ7XG5cdHZhciBjb2RlUG9pbnQ7XG5cblx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0fVxuXG5cdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRieXRlSW5kZXgrKztcblxuXHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRyZXR1cm4gYnl0ZTE7XG5cdH1cblxuXHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xufVxuXG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0Ynl0ZUluZGV4ID0gMDtcblx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0dmFyIHRtcDtcblx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdH1cblx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR2ZXJzaW9uOiAnMi4xLjInLFxuXHRlbmNvZGU6IHV0ZjhlbmNvZGUsXG5cdGRlY29kZTogdXRmOGRlY29kZVxufTtcbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcbiIsIi8qKlxyXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxyXG4gKi9cclxuXHJcbnZhciBCbG9iQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IFdlYktpdEJsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTVNCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNU0Jsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBcclxuICBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XHJcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcclxuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xyXG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xyXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcclxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xyXG4gIHJldHVybiBhcnkubWFwKGZ1bmN0aW9uKGNodW5rKSB7XHJcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxyXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2h1bms7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgIGJiLmFwcGVuZChwYXJ0KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQmxvYihtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSksIG9wdGlvbnMgfHwge30pO1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XHJcbiAgQmxvYkNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IEJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59KSgpO1xyXG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogZnIucmVzdWx0IH0sIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWJhc2U2NGVuY29kZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgZmFsc2UsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcblxuICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgIGkgKz0gbjtcbiAgICBsZW5ndGggPSAnJztcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PT0gMjU1KSBicmVhaztcblxuICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBvcHRzLndpdGhDcmVkZW50aWFscztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gcmVzdWx0cyBvZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBkZXRlY3Rpb25cbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gb3B0cy5pc1JlYWN0TmF0aXZlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyogZ2xvYmFsIGF0dGFjaEV2ZW50ICovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuICBvcHRzLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgb3B0cy5yZXF1ZXN0VGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdHMpIHtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBvcHRzLndpdGhDcmVkZW50aWFscztcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc3VwcG9ydHNCaW5hcnkgJiYgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtOyBjaGFyc2V0PVVURi04Jykge1xuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih0eXBlb2YgeGhyLnN0YXR1cyA9PT0gJ251bWJlcicgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtOyBjaGFyc2V0PVVURi04Jykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0ZXJtaW5hdGlvbkV2ZW50ID0gJ29ucGFnZWhpZGUnIGluIHNlbGYgPyAncGFnZWhpZGUnIDogJ3VubG9hZCc7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0ZXJtaW5hdGlvbkV2ZW50LCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlciAoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogVW50aWwgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsIGlzIHNoaXBwZWQuXG4gKi9cbmZ1bmN0aW9uIGdsb2IgKCkge1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xufVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIHZhciBnbG9iYWwgPSBnbG9iKCk7XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbyA9IChnbG9iYWwuX19fZWlvIHx8IFtdKTtcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7fTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcblxudmFyIEJyb3dzZXJXZWJTb2NrZXQsIE5vZGVXZWJTb2NrZXQ7XG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICBCcm93c2VyV2ViU29ja2V0ID0gV2ViU29ja2V0O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IHNlbGYuV2ViU29ja2V0IHx8IHNlbGYuTW96V2ViU29ja2V0O1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0SW1wbCA9IEJyb3dzZXJXZWJTb2NrZXQgfHwgTm9kZVdlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1MgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0ICYmICFvcHRzLmZvcmNlTm9kZTtcbiAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcbiAgaWYgKCF0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgIFdlYlNvY2tldEltcGwgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9XG4gICAgICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCAmJiAhdGhpcy5pc1JlYWN0TmF0aXZlXG4gICAgICAgID8gcHJvdG9jb2xzXG4gICAgICAgICAgPyBuZXcgV2ViU29ja2V0SW1wbCh1cmksIHByb3RvY29scylcbiAgICAgICAgICA6IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSlcbiAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmksIHByb3RvY29scywgb3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ25vZGVidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFXZWJTb2NrZXRJbXBsICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0SW1wbCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2UgIT09IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBvcHRzLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIGRldGVjdCBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudFxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnKTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIG9yIFJlYWN0TmF0aXZlIGNsaWVudFxuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaXNSZWFjdE5hdGl2ZSkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzIHx8IHRoaXMud2l0aENyZWRlbnRpYWxzLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBvcHRpb25zLnRpbWVzdGFtcFJlcXVlc3RzIHx8IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiBvcHRpb25zLnBvbGljeVBvcnQgfHwgdGhpcy5wb2xpY3lQb3J0LFxuICAgIHBmeDogb3B0aW9ucy5wZnggfHwgdGhpcy5wZngsXG4gICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UgfHwgdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCB8fCB0aGlzLmNlcnQsXG4gICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMgfHwgdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogb3B0aW9ucy5mb3JjZU5vZGUgfHwgdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCB0aGlzLnJlcXVlc3RUaW1lb3V0LFxuICAgIHByb3RvY29sczogb3B0aW9ucy5wcm90b2NvbHMgfHwgdm9pZCAoMCksXG4gICAgaXNSZWFjdE5hdGl2ZTogdGhpcy5pc1JlYWN0TmF0aXZlXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5mbGFncyA9IHt9O1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogKHRoaXMuZmxhZ3MuYmluYXJ5ICE9PSB1bmRlZmluZWQgPyB0aGlzLmZsYWdzLmJpbmFyeSA6IGhhc0JpbihhcmdzKSkgPyBwYXJzZXIuQklOQVJZX0VWRU5UIDogcGFyc2VyLkVWRU5ULFxuICAgIGRhdGE6IGFyZ3NcbiAgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHRoaXMuZmxhZ3MgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnkgPSB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG4gICAgICBkZWJ1Zygnc2VuZGluZyBjb25uZWN0IHBhY2tldCB3aXRoIHF1ZXJ5ICVzJywgcXVlcnkpO1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gcGFja2V0Lm5zcCA9PT0gdGhpcy5uc3A7XG4gIHZhciByb290TmFtZXNwYWNlRXJyb3IgPSBwYWNrZXQudHlwZSA9PT0gcGFyc2VyLkVSUk9SICYmIHBhY2tldC5uc3AgPT09ICcvJztcblxuICBpZiAoIXNhbWVOYW1lc3BhY2UgJiYgIXJvb3ROYW1lc3BhY2VFcnJvcikgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGJpbmFyeSBmbGFnXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRoZSBlbWl0dGVkIGRhdGEgY29udGFpbnMgYmluYXJ5XG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gIHRoaXMuZmxhZ3MuYmluYXJ5ID0gYmluYXJ5O1xuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB2YXIgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2VuZXJhdGUgYHNvY2tldC5pZGAgZm9yIHRoZSBnaXZlbiBgbnNwYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuc3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG4gIHJldHVybiAobnNwID09PSAnLycgPyAnJyA6IChuc3AgKyAnIycpKSArIHRoaXMuZW5naW5lLmlkO1xufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChwYWNrZXQucXVlcnkgJiYgcGFja2V0LnR5cGUgPT09IDApIHBhY2tldC5uc3AgKz0gJz8nICsgcGFja2V0LnF1ZXJ5O1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNMZW5ndGg7IGkrKykge1xuICAgIHZhciBzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKTtcbiAgICBzdWIuZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IGlvIGZyb20gXCJzb2NrZXQuaW8tY2xpZW50XCI7XHJcblxyXG5jb25zdCB1c2VTb2NrZXQgPSAoe3VzZXJuYW1lLHJvdXRlPScvYW5vbnltb3VzJyxzZXJ2ZXJVcmx9KSA9PiB7XHJcbiAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gIGNvbnN0IFtjb25uZWN0ZWQsIHNldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3NvY2tldEVycm9yLCBzZXRTb2NrZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoVG9rZW4oKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyb3V0ZSwge1xyXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWUgfSksXHJcbiAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgICAgc2V0U29ja2V0KGlvKHNlcnZlclVybCwgeyBxdWVyeTogYHRva2VuPSR7ZGF0YS50b2tlbn1gIH0pKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBzZXRTb2NrZXRFcnJvcihlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZldGNoVG9rZW4oKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc29ja2V0ICE9PSBudWxsKSB7XHJcbiAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIGVycm9yID0+IHtcclxuICAgICAgICBzZXRTb2NrZXRFcnJvcihlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcclxuICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzb2NrZXQub24oXCJtZXNzYWdlXCIsKCk9PntcclxuXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSwgW3NvY2tldF0pO1xyXG4gIHJldHVybiB7IHNvY2tldCwgY29ubmVjdGVkLCBzb2NrZXRFcnJvciB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdXNlU29ja2V0O1xyXG4iLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IHVzZVNvY2tldE1lc3NhZ2luZyBmcm9tIFwiLi91c2VTb2NrZXRNZXNzYWdpbmdcIjtcclxuaW1wb3J0IHVzZUNoYXRMb2cgZnJvbSBcIi4uL3VzZUNoYXRMb2dcIjtcclxuaW1wb3J0IHVzZVNvY2tldCBmcm9tIFwiLi91c2VTb2NrZXRcIlxyXG5jb25zdCB1c2VTb2NrZXRDbGllbnQgPSh7IG5hbWUsIHRhcmdldE5hbWUscm91dGUsc2VydmVyVXJsIH0pPT57XHJcbiAgIGNvbnN0IHtzb2NrZXQsIGNvbm5lY3RlZCwgc29ja2V0RXJyb3J9ID0gdXNlU29ja2V0KHt1c2VybmFtZTpuYW1lLHJvdXRlLHNlcnZlclVybH0pXHJcbiAgICBjb25zdCB7XHJcbiBcclxuICAgICAgICBlcnJvcnMsXHJcbiAgICAgICAgaGFuZGxlTWVzc2FnZUNoYW5nZSxcclxuICAgICAgICBtZXNzYWdlUmVjaWV2ZWQsXHJcbiAgICAgICAgbWVzc2FnZVNlbnQsXHJcbiAgICAgICAgbWVzc2FnZVRleHQsXHJcbiAgICAgICAgc2VuZE1lc3NhZ2VcclxuICAgICAgfSA9IHVzZVNvY2tldE1lc3NhZ2luZyh7IHNvY2tldCwgdGFyZ2V0TmFtZSB9KTtcclxuICAgICAgY29uc3QgeyBtZXNzYWdlcyB9ID0gdXNlQ2hhdExvZyh7IG5hbWUsIG1lc3NhZ2VSZWNpZXZlZCwgbWVzc2FnZVNlbnQgfSk7XHJcblxyXG4gICAgICByZXR1cm4ge21lc3NhZ2VzLG1lc3NhZ2VSZWNpZXZlZCxtZXNzYWdlU2VudCxtZXNzYWdlVGV4dCxzZW5kTWVzc2FnZSxlcnJvcnMsY29ubmVjdGVkLGhhbmRsZU1lc3NhZ2VDaGFuZ2V9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHVzZVNvY2tldENsaWVudCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCBUYWJCYXIgZnJvbSBcInByZWFjdC1tYXRlcmlhbC1jb21wb25lbnRzL1RhYkJhclwiO1xyXG5pbXBvcnQgXCJwcmVhY3QtbWF0ZXJpYWwtY29tcG9uZW50cy9UYWJCYXIvc3R5bGUuY3NzXCI7XHJcbmltcG9ydCBcInByZWFjdC1tYXRlcmlhbC1jb21wb25lbnRzL1RhYnMvc3R5bGUuY3NzXCI7XHJcblxyXG5pbXBvcnQgQ2hhdFVzZXIgZnJvbSBcIi4vQ2hhdFVzZXJcIjtcclxuaW1wb3J0IFwiLi9zdHlsZS5jc3NcIjtcclxuaW1wb3J0IHVzZVNvY2tldENsaWVudCBmcm9tIFwic29ja2V0LWlvLW1lc3NhZ2luZy91c2VTb2NrZXRDbGllbnRcIjtcclxuXHJcbmNvbnN0IENoYXRSb29tID0gKCkgPT4ge1xyXG4gIGNvbnN0IFttc2dGb3JNYXJpbywgc2V0TXNnRm9yTWFyaW9dID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgW21zZ0ZvckRyYWdvcywgc2V0TXNnRm9yRHJhZ29zXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtzZWxlY3RlZEl0ZW0sIHNldFNlbGVjdGVkSXRlbV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgY29uc3Qge1xyXG4gICAgbWVzc2FnZXM6IG1zZ01hcmlvLFxyXG4gICAgbWVzc2FnZVJlY2lldmVkOiBtc2dSZWNNYXJpbyxcclxuICAgIG1lc3NhZ2VTZW50OiBtc2dTbnRNYXJpbyxcclxuICAgIG1lc3NhZ2VUZXh0OiBtc2dUeHRNYXJpbyxcclxuICAgIHNlbmRNZXNzYWdlOiBzZW5kTXNnTWFyaW8sXHJcbiAgICBlcnJvcnM6IGVyck1hcmlvLFxyXG4gICAgY29ubmVjdGVkOiBjbnRNYXJpbyxcclxuICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U6IGhkbGVNZXNzYWdlQ2hhZ2VNYXJpbyxcclxuICAgIHNvY2tldDogbWFyaW9Tb2NrZXRcclxuICB9ID0gdXNlU29ja2V0Q2xpZW50KHtcclxuICAgIG5hbWU6IFwibWFyaW9cIixcclxuICAgIHRhcmdldE5hbWU6IFwiZHJhZ29zXCIsXHJcbiAgICBzZXJ2ZXJVcmw6UkVBQ1RfQVBQX1NPQ0tFVF9VUkwsXHJcbiAgICByb3V0ZTonL2Fub255bW91cydcclxuICBcclxuICB9KTtcclxuICBjb25zdCB7XHJcbiAgICBtZXNzYWdlczogbXNnRHJhZ29zLFxyXG4gICAgbWVzc2FnZVJlY2lldmVkOiBtc2dSZWNEcmFnb3MsXHJcbiAgICBtZXNzYWdlU2VudDogbXNnU250RHJhZ29zLFxyXG4gICAgbWVzc2FnZVRleHQ6IG1zZ1R4dERyYWdvcyxcclxuICAgIHNlbmRNZXNzYWdlOiBzZW5kTXNnRHJhZ29zLFxyXG4gICAgZXJyb3JzOiBlcnJEcmFnb3MsXHJcbiAgICBjb25uZWN0ZWQ6IGNudERyYWdvcyxcclxuICAgIGhhbmRsZU1lc3NhZ2VDaGFuZ2U6IGhkbGVNZXNzYWdlQ2hhZ2VEcmFnb3MsXHJcbiAgICBzb2NrZXQ6IGRyYWdvc1NvY2tldFxyXG4gIH0gPSB1c2VTb2NrZXRDbGllbnQoe1xyXG4gICAgbmFtZTogXCJkcmFnb3NcIixcclxuICAgIHRhcmdldE5hbWU6IFwibWFyaW9cIixcclxuICAgIHNlcnZlclVybDpSRUFDVF9BUFBfU09DS0VUX1VSTCxcclxuICAgIHJvdXRlOicvYW5vbnltb3VzJ1xyXG4gIH0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYobXNnRm9yRHJhZ29zICE9PW51bGwpXHJcbiAgICBzZXRNc2dGb3JEcmFnb3MocHJldlN0YXRlID0+IHByZXZTdGF0ZSArIDEpO1xyXG4gIH0sIFttc2dSZWNEcmFnb3NdKTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYobXNnRm9yTWFyaW8gIT09bnVsbClcclxuICAgIHNldE1zZ0Zvck1hcmlvKHByZXZTdGF0ZSA9PiBwcmV2U3RhdGUgKyAxKTtcclxuICB9LCBbbXNnUmVjTWFyaW9dKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChzZWxlY3RlZEl0ZW0gPT09IDApIHtcclxuICAgICAgc2V0TXNnRm9yTWFyaW8oMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRNc2dGb3JEcmFnb3MoMCk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkSXRlbV0pO1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9fT5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YWItYmFyXCI+XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgPFRhYkJhcj5cclxuICAgICAgICA8VGFiQmFyLlRhYiBhY3RpdmUgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRJdGVtKDApfT5cclxuICAgICAgICAgIDxUYWJCYXIuVGFiTGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCJ9fT5cclxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiBjbnRNYXJpbyA/IFwiZ3JlZW5cIiA6IFwib3JhbmdlXCJ9fT5tYXJpbzwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNoaXBcIlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtc2dGb3JNYXJpbyA+IDAgPyBcImdyZWVuXCIgOiBcImRhcmtncmV5XCJcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge21zZ0Zvck1hcmlvfVxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvVGFiQmFyLlRhYkxhYmVsPlxyXG4gICAgICAgIDwvVGFiQmFyLlRhYj5cclxuICAgICAgICA8VGFiQmFyLlRhYiBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZEl0ZW0oMSl9PlxyXG4gICAgICAgICAgPFRhYkJhci5UYWJMYWJlbD5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgYWxpZ25JdGVtczogXCJjZW50ZXJcIiB9fT5cclxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiBjbnREcmFnb3MgPyBcImdyZWVuXCIgOiBcIm9yYW5nZVwiIH19PlxyXG4gICAgICAgICAgICAgICAgZHJhZ29zXHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2hpcFwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1zZ0ZvckRyYWdvcyA+IDAgPyBcImdyZWVuXCIgOiBcImRhcmtncmV5XCJcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge21zZ0ZvckRyYWdvc31cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L1RhYkJhci5UYWJMYWJlbD5cclxuICAgICAgICA8L1RhYkJhci5UYWI+XHJcbiAgICAgIDwvVGFiQmFyPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIHtzZWxlY3RlZEl0ZW0gPT09IDAgJiYgKFxyXG4gICAgICAgIDxDaGF0VXNlclxyXG4gICAgICAgICAgaGFuZGxlTWVzc2FnZUNoYW5nZT17aGRsZU1lc3NhZ2VDaGFnZU1hcmlvfVxyXG4gICAgICAgICAgY29ubmVjdGVkPXtjbnRNYXJpb31cclxuICAgICAgICAgIGVycm9ycz17ZXJyTWFyaW99XHJcbiAgICAgICAgICBtZXNzYWdlU2VudD17bXNnU250TWFyaW99XHJcbiAgICAgICAgICBtZXNzYWdlVGV4dD17bXNnVHh0TWFyaW99XHJcbiAgICAgICAgICBtZXNzYWdlcz17bXNnTWFyaW99XHJcbiAgICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1zZ01hcmlvfVxyXG4gICAgICAgICAgbWVzc2FnZVJlY2lldmVkPXttc2dSZWNNYXJpb31cclxuICAgICAgICAgIHNvY2tldD17ZHJhZ29zU29ja2V0fVxyXG4gICAgICAgICAgbmFtZT1cIm1hcmlvXCJcclxuICAgICAgICAgIHRhcmdldE5hbWU9XCJkcmFnb3NcIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICl9XHJcbiAgICAgIHtzZWxlY3RlZEl0ZW0gPT09IDEgJiYgKFxyXG4gICAgICAgIDxDaGF0VXNlclxyXG4gICAgICAgICAgaGFuZGxlTWVzc2FnZUNoYW5nZT17aGRsZU1lc3NhZ2VDaGFnZURyYWdvc31cclxuICAgICAgICAgIGNvbm5lY3RlZD17Y250RHJhZ29zfVxyXG4gICAgICAgICAgZXJyb3JzPXtlcnJEcmFnb3N9XHJcbiAgICAgICAgICBtZXNzYWdlU2VudD17bXNnU250RHJhZ29zfVxyXG4gICAgICAgICAgbWVzc2FnZVRleHQ9e21zZ1R4dERyYWdvc31cclxuICAgICAgICAgIG1lc3NhZ2VzPXttc2dEcmFnb3N9XHJcbiAgICAgICAgICBzZW5kTWVzc2FnZT17c2VuZE1zZ0RyYWdvc31cclxuICAgICAgICAgIG1lc3NhZ2VSZWNpZXZlZD17bXNnUmVjRHJhZ29zfVxyXG4gICAgICAgICAgc29ja2V0PXtkcmFnb3NTb2NrZXR9XHJcbiAgICAgICAgICBuYW1lPVwiZHJhZ29zXCJcclxuICAgICAgICAgIHRhcmdldE5hbWU9XCJtYXJpb1wiXHJcbiAgICAgICAgLz5cclxuICAgICAgKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IENoYXRSb29tO1xyXG4iLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuaW1wb3J0IENoYXRSb29tIGZyb20gJy4vQ2hhdFJvb20nXHJcblxyXG5jb25zdCBTb2NrZXRJT01lc3NhZ2luZyA9KCk9PntcclxuXHJcbiAgICByZXR1cm4oXHJcbiAgICAgIDxDaGF0Um9vbSAvPlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU29ja2V0SU9NZXNzYWdpbmciLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuXHJcbmNvbnN0IFdlYlJUQ01lc3NhZ2luZyA9KCk9PntcclxuXHJcbiAgICByZXR1cm4oXHJcbiAgICAgICAgPGRpdiBzdHlsZT17e21hcmdpblRvcDoyMDB9fT5XZWJSVEMgTWVzc2FnaW5nPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJSVENNZXNzYWdpbmciLCJpbXBvcnQge2h9IGZyb20gJ3ByZWFjdCdcclxuXHJcbmNvbnN0IFdlYlJUQ1ZpZGVvQ2hhdCA9KCk9PntcclxuXHJcbiAgICByZXR1cm4oXHJcbiAgICAgICAgPGRpdiBzdHlsZT17e21hcmdpblRvcDoyMDB9fT5cclxuICAgICAgICAgICAgV2ViUlRDVmlkZW9DaGF0XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYlJUQ1ZpZGVvQ2hhdCJdLCJuYW1lcyI6WyJNRENGb3VuZGF0aW9uIiwiY3NzQ2xhc3NlcyIsInN0cmluZ3MiLCJudW1iZXJzIiwiZGVmYXVsdEFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsImFkYXB0ZXIiLCJhZGFwdGVyXyIsImluaXQiLCJkZXN0cm95IiwiTURDQ29tcG9uZW50IiwiYXR0YWNoVG8iLCJyb290IiwiZm91bmRhdGlvbiIsInVuZGVmaW5lZCIsImFyZ3MiLCJyb290XyIsImluaXRpYWxpemUiLCJmb3VuZGF0aW9uXyIsImdldERlZmF1bHRGb3VuZGF0aW9uIiwiaW5pdGlhbFN5bmNXaXRoRE9NIiwiRXJyb3IiLCJsaXN0ZW4iLCJldnRUeXBlIiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1bmxpc3RlbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlbWl0IiwiZXZ0RGF0YSIsInNob3VsZEJ1YmJsZSIsImV2dCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiYnViYmxlcyIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiUk9PVCIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwiVkFSX0xFRlQiLCJWQVJfVE9QIiwiVkFSX0ZHX1NJWkUiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfVFJBTlNMQVRFX1NUQVJUIiwiVkFSX0ZHX1RSQU5TTEFURV9FTkQiLCJQQURESU5HIiwiSU5JVElBTF9PUklHSU5fU0NBTEUiLCJERUFDVElWQVRJT05fVElNRU9VVF9NUyIsIkZHX0RFQUNUSVZBVElPTl9NUyIsIlRBUF9ERUxBWV9NUyIsInN1cHBvcnRzQ3NzVmFyaWFibGVzXyIsInN1cHBvcnRzUGFzc2l2ZV8iLCJkZXRlY3RFZGdlUHNldWRvVmFyQnVnIiwid2luZG93T2JqIiwibm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhhc1BzZXVkb1ZhckJ1ZyIsImJvcmRlclRvcFN0eWxlIiwicmVtb3ZlIiwic3VwcG9ydHNDc3NWYXJpYWJsZXMiLCJmb3JjZVJlZnJlc2giLCJzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCIsIkNTUyIsInN1cHBvcnRzIiwiZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyIsIndlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyIsImFwcGx5UGFzc2l2ZSIsImdsb2JhbE9iaiIsIndpbmRvdyIsImlzU3VwcG9ydGVkIiwicGFzc2l2ZSIsImUiLCJnZXRNYXRjaGVzUHJvcGVydHkiLCJIVE1MRWxlbWVudFByb3RvdHlwZSIsImZpbHRlciIsInAiLCJwb3AiLCJnZXROb3JtYWxpemVkRXZlbnRDb29yZHMiLCJldiIsInBhZ2VPZmZzZXQiLCJjbGllbnRSZWN0IiwieCIsInkiLCJkb2N1bWVudFgiLCJsZWZ0IiwiZG9jdW1lbnRZIiwidG9wIiwibm9ybWFsaXplZFgiLCJub3JtYWxpemVkWSIsInR5cGUiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMiLCJhY3RpdmF0ZWRUYXJnZXRzIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsImJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMiLCJpc1VuYm91bmRlZCIsImlzU3VyZmFjZUFjdGl2ZSIsImlzU3VyZmFjZURpc2FibGVkIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJ1cGRhdGVDc3NWYXJpYWJsZSIsImNvbXB1dGVCb3VuZGluZ1JlY3QiLCJnZXRXaW5kb3dQYWdlT2Zmc2V0IiwiT2JqZWN0IiwiYXNzaWduIiwibGF5b3V0RnJhbWVfIiwiZnJhbWVfIiwid2lkdGgiLCJoZWlnaHQiLCJhY3RpdmF0aW9uU3RhdGVfIiwiZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8iLCJpbml0aWFsU2l6ZV8iLCJtYXhSYWRpdXNfIiwiYWN0aXZhdGVIYW5kbGVyXyIsImFjdGl2YXRlXyIsImRlYWN0aXZhdGVIYW5kbGVyXyIsImRlYWN0aXZhdGVfIiwiZm9jdXNIYW5kbGVyXyIsImhhbmRsZUZvY3VzIiwiYmx1ckhhbmRsZXJfIiwiaGFuZGxlQmx1ciIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJzdXBwb3J0c1ByZXNzUmlwcGxlXyIsImlzQWN0aXZhdGVkIiwiaGFzRGVhY3RpdmF0aW9uVVhSdW4iLCJ3YXNBY3RpdmF0ZWRCeVBvaW50ZXIiLCJ3YXNFbGVtZW50TWFkZUFjdGl2ZSIsImFjdGl2YXRpb25FdmVudCIsImlzUHJvZ3JhbW1hdGljIiwic3VwcG9ydHNQcmVzc1JpcHBsZSIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImxheW91dEludGVybmFsXyIsImNsZWFyVGltZW91dCIsInJlbW92ZUNzc1ZhcnNfIiwiZGVyZWdpc3RlclJvb3RIYW5kbGVyc18iLCJkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwiZm9yRWFjaCIsInJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwia2V5cyIsImsiLCJpbmRleE9mIiwiYWN0aXZhdGlvblN0YXRlIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnQiLCJpc1NhbWVJbnRlcmFjdGlvbiIsImhhc0FjdGl2YXRlZENoaWxkIiwibGVuZ3RoIiwic29tZSIsInRhcmdldCIsInJlc2V0QWN0aXZhdGlvblN0YXRlXyIsInB1c2giLCJjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyIsImFuaW1hdGVBY3RpdmF0aW9uXyIsImtleSIsImtleUNvZGUiLCJhY3RpdmF0ZSIsImV2ZW50IiwidHJhbnNsYXRlU3RhcnQiLCJ0cmFuc2xhdGVFbmQiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfIiwicm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfIiwic2V0VGltZW91dCIsImFjdGl2YXRpb25IYXNFbmRlZCIsInN0YXRlIiwiZXZ0T2JqZWN0IiwiYW5pbWF0ZURlYWN0aXZhdGlvbl8iLCJkZWFjdGl2YXRlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtYXhEaW0iLCJNYXRoIiwibWF4IiwiZ2V0Qm91bmRlZFJhZGl1cyIsImh5cG90ZW51c2UiLCJzcXJ0IiwicG93IiwidXBkYXRlTGF5b3V0Q3NzVmFyc18iLCJyb3VuZCIsInNldFVuYm91bmRlZCIsInVuYm91bmRlZCIsIk1EQ1JpcHBsZSIsImRpc2FibGVkIiwidW5ib3VuZGVkXyIsInJpcHBsZSIsImNyZWF0ZUFkYXB0ZXIiLCJpbnN0YW5jZSIsIk1BVENIRVMiLCJ1dGlsIiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJjb250YWlucyIsImRvY3VtZW50RWxlbWVudCIsInZhck5hbWUiLCJ2YWx1ZSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiQm9vbGVhbiIsInNldFVuYm91bmRlZF8iLCJkYXRhc2V0IiwiUmlwcGxlQ2FwYWJsZVN1cmZhY2UiLCJBQ1RJVkUiLCJGQURFIiwiTk9fVFJBTlNJVElPTiIsIkNPTlRFTlRfU0VMRUNUT1IiLCJNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIiwiY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0Iiwic2V0Q29udGVudFN0eWxlUHJvcGVydHkiLCJwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QiLCJNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiIsImN1cnJlbnRDbGllbnRSZWN0Iiwid2lkdGhEZWx0YSIsInhQb3NpdGlvbiIsIk1EQ0ZhZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24iLCJNRENUYWJJbmRpY2F0b3IiLCJjb250ZW50XyIsInF1ZXJ5U2VsZWN0b3IiLCJwcm9wIiwiQVJJQV9TRUxFQ1RFRCIsIlJJUFBMRV9TRUxFQ1RPUiIsIlRBQl9JTkRJQ0FUT1JfU0VMRUNUT1IiLCJUQUJJTkRFWCIsIklOVEVSQUNURURfRVZFTlQiLCJNRENUYWJGb3VuZGF0aW9uIiwiaGFzQ2xhc3MiLCJzZXRBdHRyIiwiYWN0aXZhdGVJbmRpY2F0b3IiLCJkZWFjdGl2YXRlSW5kaWNhdG9yIiwibm90aWZ5SW50ZXJhY3RlZCIsImdldE9mZnNldExlZnQiLCJnZXRPZmZzZXRXaWR0aCIsImdldENvbnRlbnRPZmZzZXRMZWZ0IiwiZ2V0Q29udGVudE9mZnNldFdpZHRoIiwiZm9jdXMiLCJoYW5kbGVDbGlja18iLCJoYW5kbGVDbGljayIsImlzQWN0aXZlIiwiY29tcHV0ZURpbWVuc2lvbnMiLCJyb290V2lkdGgiLCJyb290TGVmdCIsImNvbnRlbnRXaWR0aCIsImNvbnRlbnRMZWZ0Iiwicm9vdFJpZ2h0IiwiY29udGVudFJpZ2h0IiwiTURDVGFiIiwicmlwcGxlXyIsInRhYkluZGljYXRvcl8iLCJyaXBwbGVGYWN0b3J5IiwiZWwiLCJ0YWJJbmRpY2F0b3JGYWN0b3J5IiwicmlwcGxlU3VyZmFjZSIsInJpcHBsZUFkYXB0ZXIiLCJyaXBwbGVGb3VuZGF0aW9uIiwidGFiSW5kaWNhdG9yRWxlbWVudCIsImJpbmQiLCJhdHRyIiwic2V0QXR0cmlidXRlIiwidGFiIiwib2Zmc2V0TGVmdCIsIm9mZnNldFdpZHRoIiwiYWN0aXZlIiwiY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QiLCJBTklNQVRJTkciLCJTQ1JPTExfVEVTVCIsIlNDUk9MTF9BUkVBX1NDUk9MTCIsIkFSRUFfU0VMRUNUT1IiLCJNRENUYWJTY3JvbGxlclJUTCIsImdldFNjcm9sbFBvc2l0aW9uUlRMIiwidHJhbnNsYXRlWCIsInNjcm9sbFRvUlRMIiwic2Nyb2xsWCIsImluY3JlbWVudFNjcm9sbFJUTCIsImdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uIiwiTURDVGFiU2Nyb2xsZXJSVExEZWZhdWx0IiwiY3VycmVudFNjcm9sbExlZnQiLCJnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCIsInJpZ2h0IiwiY2FsY3VsYXRlU2Nyb2xsRWRnZXNfIiwiZWRnZXMiLCJjbGFtcGVkU2Nyb2xsTGVmdCIsImNsYW1wU2Nyb2xsVmFsdWVfIiwiZmluYWxTY3JvbGxQb3NpdGlvbiIsInNjcm9sbERlbHRhIiwiZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoIiwiZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoIiwibWluIiwiTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZSIsIk1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSIsIk1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbiIsImV2ZW50VGFyZ2V0TWF0Y2hlc1NlbGVjdG9yIiwiYWRkU2Nyb2xsQXJlYUNsYXNzIiwic2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHkiLCJzZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSIsImdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlIiwic2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQiLCJjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3QiLCJjb21wdXRlU2Nyb2xsQ29udGVudENsaWVudFJlY3QiLCJjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImlzQW5pbWF0aW5nXyIsInJ0bFNjcm9sbGVySW5zdGFuY2VfIiwiaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImdldFNjcm9sbFBvc2l0aW9uIiwiaXNSVExfIiwiY29tcHV0ZUN1cnJlbnRTY3JvbGxQb3NpdGlvblJUTF8iLCJjdXJyZW50VHJhbnNsYXRlWCIsImNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXyIsInNjcm9sbExlZnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsInN0b3BTY3JvbGxBbmltYXRpb25fIiwiaGFuZGxlVHJhbnNpdGlvbkVuZCIsImluY3JlbWVudFNjcm9sbCIsInNjcm9sbFhJbmNyZW1lbnQiLCJpbmNyZW1lbnRTY3JvbGxSVExfIiwiaW5jcmVtZW50U2Nyb2xsXyIsInNjcm9sbFRvIiwic2Nyb2xsVG9SVExfIiwic2Nyb2xsVG9fIiwiZ2V0UlRMU2Nyb2xsZXIiLCJydGxTY3JvbGxlckZhY3RvcnlfIiwidHJhbnNmb3JtVmFsdWUiLCJyZXN1bHRzIiwiZXhlYyIsInBhcnRzIiwic3BsaXQiLCJwYXJzZUZsb2F0IiwiY3VycmVudFNjcm9sbFgiLCJzYWZlU2Nyb2xsWCIsImFuaW1hdGVfIiwiYW5pbWF0aW9uIiwidGFyZ2V0U2Nyb2xsWCIsImN1cnJlbnRTY3JvbGxQb3NpdGlvbiIsImdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uXyIsImluaXRpYWxTY3JvbGxMZWZ0IiwibmV3U2Nyb2xsTGVmdCIsInJvb3RDbGllbnRSZWN0IiwiY29udGVudENsaWVudFJlY3QiLCJyaWdodEVkZ2VEZWx0YSIsImhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfIiwiZG9jdW1lbnRPYmoiLCJzaG91bGRDYWNoZVJlc3VsdCIsIm9mZnNldEhlaWdodCIsImNsaWVudEhlaWdodCIsInJlbW92ZUNoaWxkIiwiTURDVGFiU2Nyb2xsZXIiLCJhcmVhXyIsImhhbmRsZUludGVyYWN0aW9uXyIsImhhbmRsZVRyYW5zaXRpb25FbmRfIiwiZXZ0VGFyZ2V0Iiwic2VsZWN0b3IiLCJwcm9wTmFtZSIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRTY3JvbGxDb250ZW50V2lkdGgiLCJUQUJfQUNUSVZBVEVEX0VWRU5UIiwiVEFCX1NDUk9MTEVSX1NFTEVDVE9SIiwiVEFCX1NFTEVDVE9SIiwiQVJST1dfTEVGVF9LRVkiLCJBUlJPV19SSUdIVF9LRVkiLCJFTkRfS0VZIiwiSE9NRV9LRVkiLCJFTlRFUl9LRVkiLCJTUEFDRV9LRVkiLCJFWFRSQV9TQ1JPTExfQU1PVU5UIiwiQVJST1dfTEVGVF9LRVlDT0RFIiwiQVJST1dfUklHSFRfS0VZQ09ERSIsIkVORF9LRVlDT0RFIiwiSE9NRV9LRVlDT0RFIiwiRU5URVJfS0VZQ09ERSIsIlNQQUNFX0tFWUNPREUiLCJBQ0NFUFRBQkxFX0tFWVMiLCJTZXQiLCJLRVlDT0RFX01BUCIsIk1hcCIsInNldCIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJpc1JUTCIsInNldEFjdGl2ZVRhYiIsImFjdGl2YXRlVGFiQXRJbmRleCIsImRlYWN0aXZhdGVUYWJBdEluZGV4IiwiZm9jdXNUYWJBdEluZGV4IiwiZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXgiLCJnZXRUYWJEaW1lbnNpb25zQXRJbmRleCIsImdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXgiLCJnZXRGb2N1c2VkVGFiSW5kZXgiLCJnZXRJbmRleE9mVGFiIiwiZ2V0VGFiTGlzdExlbmd0aCIsIm5vdGlmeVRhYkFjdGl2YXRlZCIsInVzZUF1dG9tYXRpY0FjdGl2YXRpb25fIiwic2V0VXNlQXV0b21hdGljQWN0aXZhdGlvbiIsInVzZUF1dG9tYXRpY0FjdGl2YXRpb24iLCJhY3RpdmF0ZVRhYiIsImluZGV4IiwicHJldmlvdXNBY3RpdmVJbmRleCIsImluZGV4SXNJblJhbmdlXyIsInNjcm9sbEludG9WaWV3IiwiaGFuZGxlS2V5RG93biIsImdldEtleUZyb21FdmVudF8iLCJpc0FjdGl2YXRpb25LZXlfIiwicHJldmVudERlZmF1bHQiLCJkZXRlcm1pbmVUYXJnZXRGcm9tS2V5XyIsImZvY3VzZWRUYWJJbmRleCIsImhhbmRsZVRhYkludGVyYWN0aW9uIiwic2Nyb2xsSW50b1ZpZXdSVExfIiwic2Nyb2xsSW50b1ZpZXdfIiwib3JpZ2luIiwibWF4SW5kZXgiLCJzaG91bGRHb1RvRW5kIiwic2hvdWxkRGVjcmVtZW50Iiwic2hvdWxkSW5jcmVtZW50IiwiY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50XyIsIm5leHRJbmRleCIsInNjcm9sbFBvc2l0aW9uIiwiYmFyV2lkdGgiLCJuZXh0VGFiRGltZW5zaW9ucyIsInJlbGF0aXZlQ29udGVudExlZnQiLCJyZWxhdGl2ZUNvbnRlbnRSaWdodCIsImxlZnRJbmNyZW1lbnQiLCJyaWdodEluY3JlbWVudCIsImNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudFJUTF8iLCJzY3JvbGxDb250ZW50V2lkdGgiLCJmaW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VfIiwidGFiRGltZW5zaW9ucyIsInJlbGF0aXZlUm9vdExlZnQiLCJyZWxhdGl2ZVJvb3RSaWdodCIsInJlbGF0aXZlUm9vdERlbHRhIiwibGVmdEVkZ2VJc0Nsb3NlciIsInJpZ2h0RWRnZUlzQ2xvc2VyIiwiZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlUlRMXyIsInJvb3REZWx0YSIsImhhcyIsImdldCIsInNjcm9sbEluY3JlbWVudCIsInNjcm9sbFdpZHRoIiwiTURDVGFiQmFyIiwidGFiTGlzdF8iLCJ0YWJGYWN0b3J5XyIsInRhYlNjcm9sbGVyXyIsInRhYlNjcm9sbGVyRmFjdG9yeV8iLCJoYW5kbGVUYWJJbnRlcmFjdGlvbl8iLCJoYW5kbGVLZXlEb3duXyIsInRhYkZhY3RvcnkiLCJ0YWJTY3JvbGxlckZhY3RvcnkiLCJnZXRUYWJFbGVtZW50c18iLCJtYXAiLCJ0YWJTY3JvbGxlckVsZW1lbnQiLCJpIiwidGFiRWxlbWVudHMiLCJhY3RpdmVFbGVtZW50IiwidGFiVG9GaW5kIiwic2xpY2UiLCJjYWxsIiwicXVlcnlTZWxlY3RvckFsbCIsIlRhYiIsIm1kY05vdGlmeVByb3BzIiwiY2xhc3MiLCJEYXRlTGluZWJyZWFrIiwiZGF0ZXRpbWUiLCJkaXNwbGF5IiwiZmxleCIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk1lc3NhZ2VBbGlnbmVyIiwiY2hpbGRyZW4iLCJzaWRlIiwiYWxpZ25tZW50IiwianVzdGlmeUNvbnRlbnQiLCJNZXNzYWdlVmlldyIsIm1lc3NhZ2UiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYWRkaW5nIiwibWFyZ2luIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwibWF4V2lkdGgiLCJ3b3JkV3JhcCIsIndvcmRCcmVhayIsIm1pbldpZHRoIiwiZm9udFNpemUiLCJwYWRkaW5nVG9wIiwidGV4dEFsaWduIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiU3Vic2VxdWVudE1lc3NhZ2UiLCJhbGlnbkl0ZW1zIiwibWFyZ2luTGVmdCIsIk1lc3NhZ2UiLCJjb2xvciIsIk1lc3NhZ2VBdmF0YXIiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsIkZpcnN0TWVzc2FnZSIsImxvY2FsIiwiTWVzc2FnZU9iamVjdE1hcHB0ZXIiLCJwcm9wcyIsIm9yZGVyIiwiZGF0ZVNwYWNlIiwidXNlTWVzc2FnZVNvcnRlciIsIm1lc3NhZ2VzIiwidXNlU3RhdGUiLCJzb3J0ZWRNZXNzYWdlcyIsInNldFNvcnRlZE1lc3NhZ2VzIiwidXNlRWZmZWN0Iiwic29ydCIsImEiLCJiIiwidXNlTWVzc2FnZXNNYXBwZXIiLCJtYXBwZWRNZXNzYWdlcyIsInNldE1hcHBlZE1lc3NhZ2VzIiwibWFwTWVzc2FnZXMiLCJsb2NhbFNpZGUiLCJyZW1vdGVTaWRlIiwiZW1haWwiLCJmcm9tIiwibGFzdERhdGV0aW1lIiwibSIsImdldERhdGUiLCJfZXh0ZW5kcyIsIm1vZHVsZSIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiYXBwbHkiLCJNZXNzYWdlQ29sbGVjdGlvblZpZXciLCJNZXNzYWdlT2JqZWN0TWFwcGVyIiwiTWVzc2FnZVZpZXdTY3JvbGxlciIsInRyYW5zZm9ybSIsIm92ZXJmbG93IiwiTWVzc2FnZUVkaXRvckRpc3BsYXllciIsIm9uTWVzc2FnZUNoYW5nZSIsInNlbmRNZXNzYWdlIiwiaWQiLCJNZXNzYWdlc0Rpc3BsYXllciIsInNvY2tldCIsIm1lc3NhZ2VUZXh0IiwiaGFuZGxlTWVzc2FnZUNoYW5nZSIsInVzZU1lc3NhZ2VNYXBwZXIiLCJDaGF0VXNlciIsIm5hbWUiLCJ0YXJnZXROYW1lIiwiZXJyb3JzIiwiTWVzc2FnZURpc3BsYXllciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsImFyciIsIkFycmF5IiwiaXNBcnJheSIsImFycjIiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidG9TdHJpbmciLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwidXNlU29ja2V0TWVzc2FnaW5nIiwic2V0TWVzc2FnZVRleHQiLCJtZXNzYWdlUmVjaWV2ZWQiLCJzZXRNZXNzYWdlUmVjaWV2ZWQiLCJtZXNzYWdlU2VudCIsInNldE1lc3NhZ2VTZW50IiwiY29ubmVjdGVkIiwic2V0Q29ubmVjdGVkIiwic2V0RXJyb3IiLCJnZXRUaW1lIiwicmVjaWV2ZXIiLCJvbiIsImRhdGEiLCJzZW5kZXIiLCJlcnJvciIsInVzZUNoYXRMb2ciLCJzZXRNZXNzYWdlcyIsInNhdmVUb0xvY2FsU3RvcmFnZSIsInBlcnNpc3RlZE1lc3NhZ2VzIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ0byIsInJlIiwicGFyc2V1cmkiLCJzdHIiLCJzcmMiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidXJpIiwiaG9zdCIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJzIiwiaCIsImQiLCJ3IiwidmFsIiwib3B0aW9ucyIsImlzRmluaXRlIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIlN0cmluZyIsIm1hdGNoIiwibiIsInRvTG93ZXJDYXNlIiwibXMiLCJtc0FicyIsImFicyIsInBsdXJhbCIsImlzUGx1cmFsIiwic2V0dXAiLCJlbnYiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiZGVmYXVsdCIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiaHVtYW5pemUiLCJyZXF1aXJlJCQwIiwiaW5zdGFuY2VzIiwibmFtZXMiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJjaGFyQ29kZUF0IiwiY29sb3JzIiwicHJldlRpbWUiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImZvcm1hdCIsImZvcm1hdHRlciIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsInVzZUNvbG9ycyIsImV4dGVuZCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwibmFtZXNwYWNlcyIsInNhdmUiLCJsZW4iLCJSZWdFeHAiLCJzdWJzdHIiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJ0ZXN0IiwicmVnZXhwIiwic3RhY2siLCJsb2FkIiwiZXhwb3J0cyIsImxvY2Fsc3RvcmFnZSIsInByb2Nlc3MiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJXZWJraXRBcHBlYXJhbmNlIiwiY29uc29sZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiJDEiLCJjIiwibGFzdEMiLCJzdG9yYWdlIiwicmVtb3ZlSXRlbSIsInIiLCJERUJVRyIsImoiLCJ2IiwidXJsIiwibG9jIiwibG9jYXRpb24iLCJwcm90b2NvbCIsImNoYXJBdCIsInBvcnQiLCJwYXRoIiwiaXB2NiIsImhyZWYiLCJpc05hTiIsImZsb29yIiwiY2VpbCIsImNocm9tZSIsImVyciIsIkZ1bmN0aW9uIiwiRW1pdHRlciIsIm1peGluIiwiZm4iLCJfY2FsbGJhY2tzIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiY2FsbGJhY2tzIiwiY2IiLCJsaXN0ZW5lcnMiLCJoYXNMaXN0ZW5lcnMiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiaW5pdGVkIiwiY29kZSIsInRvQnl0ZUFycmF5IiwiYjY0IiwibCIsInRtcCIsInBsYWNlSG9sZGVycyIsIkwiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsInJlYWQiLCJidWZmZXIiLCJvZmZzZXQiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsIkluZmluaXR5Iiwid3JpdGUiLCJydCIsIkxOMiIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiQnVmZmVyIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsImtNYXhMZW5ndGgiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsIl9fcHJvdG9fXyIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0IiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYnl0ZUxlbmd0aCIsImFjdHVhbCIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJpbnRlcm5hbElzQnVmZmVyIiwiY29weSIsImlzbmFuIiwiaXNCdWZmZXIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiY29uY2F0IiwibGlzdCIsInBvcyIsImJ1ZiIsImlzVmlldyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJ0b0pTT04iLCJfYXJyIiwiYmFzZTY0IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwiaWVlZTc1NCIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidHJpbSIsInVuaXRzIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0Zhc3RCdWZmZXIiLCJpc1Nsb3dCdWZmZXIiLCJpc0J1ZiIsIndpdGhOYXRpdmVCdWZmZXIiLCJ3aXRoTmF0aXZlQXJyYXlCdWZmZXIiLCJ3aXRoTmF0aXZlQmxvYiIsIkJsb2IiLCJ3aXRoTmF0aXZlRmlsZSIsIkZpbGUiLCJwYWNrZXQiLCJidWZmZXJzIiwicGFja2V0RGF0YSIsInBhY2siLCJfZGVjb25zdHJ1Y3RQYWNrZXQiLCJhdHRhY2htZW50cyIsInBsYWNlaG9sZGVyIiwiX3BsYWNlaG9sZGVyIiwibmV3RGF0YSIsIl9yZWNvbnN0cnVjdFBhY2tldCIsImNhbGxiYWNrIiwiX3JlbW92ZUJsb2JzIiwiY3VyS2V5IiwiY29udGFpbmluZ09iamVjdCIsInBlbmRpbmdCbG9icyIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVzdWx0IiwiYmxvYmxlc3NEYXRhIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJFbmNvZGVyIiwiRGVjb2RlciIsIkVSUk9SX1BBQ0tFVCIsIkVSUk9SIiwiZW5jb2RlIiwiQklOQVJZX0VWRU5UIiwiQklOQVJZX0FDSyIsImVuY29kZUFzQmluYXJ5IiwiZW5jb2RlQXNTdHJpbmciLCJuc3AiLCJwYXlsb2FkIiwidHJ5U3RyaW5naWZ5Iiwid3JpdGVFbmNvZGluZyIsImRlY29uc3RydWN0aW9uIiwiYmluYXJ5IiwiZGVjb25zdHJ1Y3RQYWNrZXQiLCJyZW1vdmVCbG9icyIsInJlY29uc3RydWN0b3IiLCJkZWNvZGVTdHJpbmciLCJCaW5hcnlSZWNvbnN0cnVjdG9yIiwicmVjb25QYWNrIiwidGFrZUJpbmFyeURhdGEiLCJ0eXBlcyIsIm5leHQiLCJ0cnlQYXJzZSIsImlzUGF5bG9hZFZhbGlkIiwiZmluaXNoZWRSZWNvbnN0cnVjdGlvbiIsImJpbkRhdGEiLCJyZWNvbnN0cnVjdFBhY2tldCIsIm1zZyIsIlhNTEh0dHBSZXF1ZXN0Iiwib3B0cyIsInhkb21haW4iLCJ4c2NoZW1lIiwiZW5hYmxlc1hEUiIsImhhc0NPUlMiLCJYRG9tYWluUmVxdWVzdCIsImhhc0JpbmFyeSIsImFycmF5YnVmZmVyIiwiYWJ2IiwiaWkiLCJhZnRlciIsImNvdW50IiwiZXJyX2NiIiwiYmFpbCIsIm5vb3AiLCJwcm94eSIsInN0cmluZ0Zyb21DaGFyQ29kZSIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiY2hlY2tTY2FsYXJWYWx1ZSIsInN0cmljdCIsImNyZWF0ZUJ5dGUiLCJzaGlmdCIsImVuY29kZUNvZGVQb2ludCIsInN5bWJvbCIsInV0ZjhlbmNvZGUiLCJieXRlU3RyaW5nIiwicmVhZENvbnRpbnVhdGlvbkJ5dGUiLCJieXRlSW5kZXgiLCJieXRlQ291bnQiLCJjb250aW51YXRpb25CeXRlIiwiZGVjb2RlU3ltYm9sIiwiYnl0ZTEiLCJieXRlMiIsImJ5dGUzIiwiYnl0ZTQiLCJ1dGY4ZGVjb2RlIiwidmVyc2lvbiIsImRlY29kZSIsImNoYXJzIiwiYnVmZmVyTGVuZ3RoIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsImVuY29kZWQzIiwiZW5jb2RlZDQiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiYmxvYlN1cHBvcnRlZCIsImJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyIsImJsb2JCdWlsZGVyU3VwcG9ydGVkIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIm1hcEFycmF5QnVmZmVyVmlld3MiLCJhcnkiLCJjaHVuayIsIkJsb2JCdWlsZGVyQ29uc3RydWN0b3IiLCJiYiIsInBhcnQiLCJCbG9iQ29uc3RydWN0b3IiLCJiYXNlNjRlbmNvZGVyIiwiaXNBbmRyb2lkIiwiaXNQaGFudG9tSlMiLCJkb250U2VuZEJsb2JzIiwicGFja2V0cyIsIm9wZW4iLCJjbG9zZSIsInBpbmciLCJwb25nIiwidXBncmFkZSIsInBhY2tldHNsaXN0Iiwic3VwcG9ydHNCaW5hcnkiLCJlbmNvZGVBcnJheUJ1ZmZlciIsImVuY29kZUJsb2IiLCJlbmNvZGVCYXNlNjRPYmplY3QiLCJlbmNvZGVkIiwidXRmOCIsImVuY29kZUJhc2U2NFBhY2tldCIsImNvbnRlbnRBcnJheSIsInJlc3VsdEJ1ZmZlciIsImVuY29kZUJsb2JBc0FycmF5QnVmZmVyIiwiZnIiLCJlbmNvZGVQYWNrZXQiLCJibG9iIiwicmVhZEFzRGF0YVVSTCIsImI2NGRhdGEiLCJ0eXBlZCIsImJhc2ljIiwiYnRvYSIsImJpbmFyeVR5cGUiLCJkZWNvZGVCYXNlNjRQYWNrZXQiLCJ0cnlEZWNvZGUiLCJhc0FycmF5IiwicmVzdCIsInNsaWNlQnVmZmVyIiwiaXNCaW5hcnkiLCJlbmNvZGVQYXlsb2FkQXNCbG9iIiwiZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIiLCJzZXRMZW5ndGhIZWFkZXIiLCJlbmNvZGVPbmUiLCJkb25lQ2FsbGJhY2siLCJlYWNoIiwiZG9uZSIsImVhY2hXaXRoSW5kZXgiLCJkZWNvZGVQYXlsb2FkQXNCaW5hcnkiLCJjaHIiLCJkZWNvZGVQYWNrZXQiLCJlbmNvZGVkUGFja2V0cyIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwiYWNjIiwicmVzdWx0QXJyYXkiLCJidWZmZXJJbmRleCIsImlzU3RyaW5nIiwiYWIiLCJ2aWV3IiwibGVuU3RyIiwiYmluYXJ5SWRlbnRpZmllciIsImxlbmd0aEFyeSIsImJ1ZmZlclRhaWwiLCJ0YWlsQXJyYXkiLCJtc2dMZW5ndGgiLCJ0b3RhbCIsIlRyYW5zcG9ydCIsImhvc3RuYW1lIiwic2VjdXJlIiwicXVlcnkiLCJ0aW1lc3RhbXBQYXJhbSIsInRpbWVzdGFtcFJlcXVlc3RzIiwicmVhZHlTdGF0ZSIsImFnZW50Iiwid2l0aENyZWRlbnRpYWxzIiwicGZ4IiwicGFzc3BocmFzZSIsImNlcnQiLCJjYSIsImNpcGhlcnMiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJmb3JjZU5vZGUiLCJpc1JlYWN0TmF0aXZlIiwiZXh0cmFIZWFkZXJzIiwibG9jYWxBZGRyZXNzIiwib25FcnJvciIsImRlc2MiLCJkZXNjcmlwdGlvbiIsImRvT3BlbiIsImRvQ2xvc2UiLCJvbkNsb3NlIiwic2VuZCIsIm9uT3BlbiIsIm9uRGF0YSIsInBhcnNlciIsIm9uUGFja2V0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicXMiLCJxcnkiLCJwYWlycyIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhbHBoYWJldCIsInNlZWQiLCJkZWNvZGVkIiwieWVhc3QiLCJub3ciLCJQb2xsaW5nIiwiaGFzWEhSMiIsInJlcXVpcmUkJDEiLCJ4aHIiLCJyZXNwb25zZVR5cGUiLCJmb3JjZUJhc2U2NCIsImluaGVyaXQiLCJwb2xsIiwicGF1c2UiLCJvblBhdXNlIiwicG9sbGluZyIsImRvUG9sbCIsImRlY29kZVBheWxvYWQiLCJjYWxsYmFja2ZuIiwiZW5jb2RlUGF5bG9hZCIsImRvV3JpdGUiLCJzY2hlbWEiLCJzaWQiLCJwYXJzZXFzIiwiWEhSIiwiUmVxdWVzdCIsImVtcHR5IiwicmVxdWVzdFRpbWVvdXQiLCJpc1NTTCIsInhkIiwieHMiLCJyZXF1ZXN0IiwicmVxIiwibWV0aG9kIiwic2VuZFhociIsInBvbGxYaHIiLCJhc3luYyIsImNyZWF0ZSIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInNldFJlcXVlc3RIZWFkZXIiLCJ0aW1lb3V0IiwiaGFzWERSIiwib25Mb2FkIiwib25lcnJvciIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJzdGF0dXMiLCJyZXF1ZXN0c0NvdW50IiwicmVxdWVzdHMiLCJvblN1Y2Nlc3MiLCJjbGVhbnVwIiwiZnJvbUVycm9yIiwiYWJvcnQiLCJyZXNwb25zZSIsImF0dGFjaEV2ZW50IiwidW5sb2FkSGFuZGxlciIsInRlcm1pbmF0aW9uRXZlbnQiLCJKU09OUFBvbGxpbmciLCJyTmV3bGluZSIsInJFc2NhcGVkTmV3bGluZSIsImdsb2IiLCJfX19laW8iLCJzY3JpcHQiLCJwYXJlbnROb2RlIiwiZm9ybSIsImlmcmFtZSIsImluc2VydEF0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJoZWFkIiwiaXNVQWdlY2tvIiwiYXJlYSIsImlmcmFtZUlkIiwicG9zaXRpb24iLCJhY3Rpb24iLCJjb21wbGV0ZSIsImluaXRJZnJhbWUiLCJodG1sIiwic3VibWl0IiwiQnJvd3NlcldlYlNvY2tldCIsIk5vZGVXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXRJbXBsIiwiV1MiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsInVzaW5nQnJvd3NlcldlYlNvY2tldCIsInByb3RvY29scyIsImNoZWNrIiwiaGVhZGVycyIsIndzIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJvbm9wZW4iLCJvbmNsb3NlIiwib25tZXNzYWdlIiwiY29tcHJlc3MiLCJ0aHJlc2hvbGQiLCJ3ZWJzb2NrZXQiLCJqc29ucCIsImZvcmNlSlNPTlAiLCJKU09OUCIsIlNvY2tldCIsInRyYW5zcG9ydHMiLCJ0cmFuc3BvcnRPcHRpb25zIiwid3JpdGVCdWZmZXIiLCJwcmV2QnVmZmVyTGVuIiwicG9saWN5UG9ydCIsInJlbWVtYmVyVXBncmFkZSIsIm9ubHlCaW5hcnlVcGdyYWRlcyIsInByb2R1Y3QiLCJ1cGdyYWRlcyIsInBpbmdJbnRlcnZhbCIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsVGltZXIiLCJwaW5nVGltZW91dFRpbWVyIiwicHJpb3JXZWJzb2NrZXRTdWNjZXNzIiwiY3JlYXRlVHJhbnNwb3J0IiwiY2xvbmUiLCJFSU8iLCJ0cmFuc3BvcnQiLCJvIiwic2V0VHJhbnNwb3J0Iiwib25EcmFpbiIsInByb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwidXBncmFkZUxvc2VzQmluYXJ5IiwidXBncmFkaW5nIiwiZmx1c2giLCJmcmVlemVUcmFuc3BvcnQiLCJvblRyYW5zcG9ydENsb3NlIiwib251cGdyYWRlIiwib25IYW5kc2hha2UiLCJzZXRQaW5nIiwiZmlsdGVyVXBncmFkZXMiLCJvbkhlYXJ0YmVhdCIsInNlbmRQYWNrZXQiLCJ3YWl0Rm9yVXBncmFkZSIsImNsZWFudXBBbmRDbG9zZSIsInJlYXNvbiIsImZpbHRlcmVkVXBncmFkZXMiLCJ0b0FycmF5IiwiZXZlbnRzIiwiY29ubmVjdCIsImNvbm5lY3RfZXJyb3IiLCJjb25uZWN0X3RpbWVvdXQiLCJjb25uZWN0aW5nIiwiZGlzY29ubmVjdCIsInJlY29ubmVjdCIsInJlY29ubmVjdF9hdHRlbXB0IiwicmVjb25uZWN0X2ZhaWxlZCIsInJlY29ubmVjdF9lcnJvciIsInJlY29ubmVjdGluZyIsImlvIiwianNvbiIsImlkcyIsImFja3MiLCJyZWNlaXZlQnVmZmVyIiwic2VuZEJ1ZmZlciIsImRpc2Nvbm5lY3RlZCIsImZsYWdzIiwiYXV0b0Nvbm5lY3QiLCJzdWJFdmVudHMiLCJzdWJzIiwiaGFzQmluIiwiRVZFTlQiLCJDT05ORUNUIiwib25wYWNrZXQiLCJzYW1lTmFtZXNwYWNlIiwicm9vdE5hbWVzcGFjZUVycm9yIiwib25jb25uZWN0Iiwib25ldmVudCIsIkFDSyIsIm9uYWNrIiwiRElTQ09OTkVDVCIsIm9uZGlzY29ubmVjdCIsImFjayIsInNlbnQiLCJlbWl0QnVmZmVyZWQiLCJCYWNrb2ZmIiwiZmFjdG9yIiwiaml0dGVyIiwiYXR0ZW1wdHMiLCJkdXJhdGlvbiIsInJhbmQiLCJyYW5kb20iLCJkZXZpYXRpb24iLCJyZXNldCIsInNldE1pbiIsInNldE1heCIsInNldEppdHRlciIsIk1hbmFnZXIiLCJuc3BzIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmFuZG9taXphdGlvbkZhY3RvciIsImJhY2tvZmYiLCJsYXN0UGluZyIsInBhY2tldEJ1ZmZlciIsIl9wYXJzZXIiLCJlbmNvZGVyIiwiZGVjb2RlciIsImVtaXRBbGwiLCJ1cGRhdGVTb2NrZXRJZHMiLCJnZW5lcmF0ZUlkIiwiZW5naW5lIiwiX3JlY29ubmVjdGlvbiIsIl9yZWNvbm5lY3Rpb25BdHRlbXB0cyIsIl9yZWNvbm5lY3Rpb25EZWxheSIsIl9yYW5kb21pemF0aW9uRmFjdG9yIiwiX3JlY29ubmVjdGlvbkRlbGF5TWF4IiwiX3RpbWVvdXQiLCJtYXliZVJlY29ubmVjdE9uT3BlbiIsImVpbyIsInNraXBSZWNvbm5lY3QiLCJvcGVuU3ViIiwiZXJyb3JTdWIiLCJ0aW1lciIsIm9ucGluZyIsIm9ucG9uZyIsIm9uZGF0YSIsIm9uZGVjb2RlZCIsIm9uQ29ubmVjdGluZyIsInByb2Nlc3NQYWNrZXRRdWV1ZSIsInN1YnNMZW5ndGgiLCJkZWxheSIsIm9ucmVjb25uZWN0IiwiYXR0ZW1wdCIsImNhY2hlIiwibmV3Q29ubmVjdGlvbiIsImZvcmNlTmV3IiwibXVsdGlwbGV4IiwidXNlU29ja2V0IiwidXNlcm5hbWUiLCJyb3V0ZSIsInNlcnZlclVybCIsInNldFNvY2tldCIsInNvY2tldEVycm9yIiwic2V0U29ja2V0RXJyb3IiLCJmZXRjaFRva2VuIiwiZmV0Y2giLCJ0b2tlbiIsInVzZVNvY2tldENsaWVudCIsIkNoYXRSb29tIiwibXNnRm9yTWFyaW8iLCJzZXRNc2dGb3JNYXJpbyIsIm1zZ0ZvckRyYWdvcyIsInNldE1zZ0ZvckRyYWdvcyIsInNlbGVjdGVkSXRlbSIsInNldFNlbGVjdGVkSXRlbSIsIm1zZ01hcmlvIiwibXNnUmVjTWFyaW8iLCJtc2dTbnRNYXJpbyIsIm1zZ1R4dE1hcmlvIiwic2VuZE1zZ01hcmlvIiwiZXJyTWFyaW8iLCJjbnRNYXJpbyIsImhkbGVNZXNzYWdlQ2hhZ2VNYXJpbyIsIm1hcmlvU29ja2V0IiwibXNnRHJhZ29zIiwibXNnUmVjRHJhZ29zIiwibXNnU250RHJhZ29zIiwibXNnVHh0RHJhZ29zIiwic2VuZE1zZ0RyYWdvcyIsImVyckRyYWdvcyIsImNudERyYWdvcyIsImhkbGVNZXNzYWdlQ2hhZ2VEcmFnb3MiLCJkcmFnb3NTb2NrZXQiLCJwcmV2U3RhdGUiLCJTb2NrZXRJT01lc3NhZ2luZyIsIldlYlJUQ01lc3NhZ2luZyIsIm1hcmdpblRvcCIsIldlYlJUQ1ZpZGVvQ2hhdCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQSxNQUFNQSxhQUFOLENBQW9COzthQUVQQyxVQUFYLEdBQXdCOzs7V0FHZixFQUFQOzs7OzthQUlTQyxPQUFYLEdBQXFCOzs7V0FHWixFQUFQOzs7OzthQUlTQyxPQUFYLEdBQXFCOzs7V0FHWixFQUFQOzs7OzthQUlTQyxjQUFYLEdBQTRCOzs7O1dBSW5CLEVBQVA7Ozs7Ozs7RUFNRkMsV0FBVyxDQUFDQyxPQUFPLEdBQUcsRUFBWCxFQUFlOztTQUVuQkMsUUFBTCxHQUFnQkQsT0FBaEI7OztFQUdGRSxJQUFJLEdBQUc7OztFQUlQQyxPQUFPLEdBQUc7Ozs7O0FDcEVaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLEFBRUE7Ozs7QUFHQSxNQUFNQyxZQUFOLENBQW1COzs7OztTQUtWQyxRQUFQLENBQWdCQyxJQUFoQixFQUFzQjs7Ozs7V0FLYixJQUFJRixZQUFKLENBQWlCRSxJQUFqQixFQUF1QixJQUFJWixhQUFKLEVBQXZCLENBQVA7Ozs7Ozs7OztFQVFGSyxXQUFXLENBQUNPLElBQUQsRUFBT0MsVUFBVSxHQUFHQyxTQUFwQixFQUErQixHQUFHQyxJQUFsQyxFQUF3Qzs7U0FFNUNDLEtBQUwsR0FBYUosSUFBYjtTQUNLSyxVQUFMLENBQWdCLEdBQUdGLElBQW5CLEVBSGlEOzs7OztTQU81Q0csV0FBTCxHQUFt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
